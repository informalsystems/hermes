---------------------------- MODULE environment ----------------------------

EXTENDS Naturals, FiniteSets

CONSTANTS MaxHeight \* maximal height of all the chains in the system

VARIABLES chains, \* a function that assigns to each chainID a chain record 
          pendingDatagrams \* a function that assigns to each chainID a set of pending datagrams
          
vars == <<chains, pendingDatagrams>>

ChainIDs == {"chainA", "chainB"}
ClientIDs == {"clA", "clB"}
Heights == 1..MaxHeight

nullClientID == 0
nullHeight == 0

Max(S) == CHOOSE x \in S: \A y \in S: y <= x    

(*** Chains ***
    A set of chain records. 
    A chain record contains the following fields:
    
    - height : an integer between nullHeight and MaxHeight. 
      Stores the current height of the chain.
    
    - counterpartyClientHeight : an integer between nullHeight and MaxHeight
      Stores the height of the client for the counterparty chain.
**************)
Chains ==    
    [
        height : Heights \union {nullHeight},
        counterpartyClientHeight : Heights \union {nullHeight}
    ]
    
(*** Datagrams ***
    A set of datagrams.
******************)
Datagrams ==
    [type : {"CreateClient"}, clientID : ClientIDs, height : Heights]
    \union
    [type : {"ClientUpdate"}, clientID : ClientIDs, height : Heights]    

(***************
Chain helper operators
***************)    
\* get the latest height of the chainID
GetLatestHeight(chainID) ==
    chains[chainID].height     
    
\* get the client height of the client for the counterparty chain    
GetCounterpartyClientHeight(chainID) ==
    chains[chainID].counterpartyClientHeight
 
\* get the client ID of the client for chainID 
GetClientID(chainID) ==
    IF chainID = "chainA" THEN "clA" ELSE "clB"
        
\* get the client ID of the client for the counterparty of chainID           
GetCounterpartyClientID(chainID) ==
    IF chainID = "chainA" THEN "clB" ELSE "clA"       

(***************
Light client update operators
***************)

\* Handle "CreateClient" datagrams
HandleCreateClient(chainID, chain, datagrams) == 
    \* get "CreateClient" datagrams
    LET createClients == {dgr \in datagrams : dgr.type = "CreateClient"} IN
    \* get heights in datagrams with correct counterparty clientID for chainID
    LET createClientHeights == 
            {h \in Heights : \E dgr \in createClients : 
                /\ dgr.clientID = GetCounterpartyClientID(chainID) 
                /\ dgr.height = h} IN  
    
    \* new chain record with clients created
    LET clientsCreated == [
            height |-> chain.height,
            counterpartyClientHeight |-> IF createClientHeights /= {}
                                         THEN Max(createClientHeights)
                                         ELSE chain.counterpartyClientHeight
         ] IN
    clientsCreated     

\* Handle "ClientUpdate" datagrams
HandleUpdateClient(chainID, chain, datagrams) ==      
    \* get "ClientUpdate" datagrams
    LET updateClients == {dgr \in datagrams : dgr.type = "ClientUpdate"} IN
    \* get heights in datagrams with correct counterparty clientID for chainID
    LET updateClientHeights == 
            {h \in Heights : \E dgr \in updateClients : 
                /\ dgr.clientID = GetCounterpartyClientID(chainID) 
                /\ dgr.height = h} IN    

    \* new chain record with clients updated
    LET clientsUpdated == [
            height |-> chain.height,
            counterpartyClientHeight |-> IF updateClientHeights /= {}
                                         THEN Max(updateClientHeights)
                                         ELSE chain.counterpartyClientHeight
         ] IN
    
    clientsUpdated

\* Update the clients on chain with chainID, 
\* using the client datagrams generated by the relayer      
LightClientUpdate(chainID, chain, datagrams) == 
    \* create clients
    LET clientsCreated == HandleCreateClient(chainID, chain, datagrams) IN
    \* update clients
    LET clientsUpdated == HandleUpdateClient(chainID, clientsCreated, datagrams) IN

    clientsUpdated
    
(***************
Connection update operators
***************)

\* Handle "ConnOpenInit" datagrams
HandleConnOpenInit(chainID, chain, datagrams) ==
    \* TODO
    chain

\* Handle "ConnOpenTry" datagrams
HandleConnOpenTry(chainID, chain, datagrams) ==
    \* TODO
    chain

\* Handle "ConnOpenAck" datagrams
HandleConnOpenAck(chainID, chain, datagrams) ==
    \* TODO
    chain

\* Handle "ConnOpenConfirm" datagrams
HandleConnOpenConfirm(chainID, chain, datagrams) ==
    \* TODO
    chain

\* Update the connections on chain with chainID, 
\* using the connection datagrams generated by the relayer
ConnectionUpdate(chainID, chain, datagrams) ==
    \* update chain with "ConnOpenInit" datagrams
    LET connInit == HandleConnOpenInit(chainID, chain, datagrams) IN
    \* update chain with "ConnOpenTry" datagrams
    LET connTry == HandleConnOpenTry(chainID, connInit, datagrams) IN
    \* update chain with "ConnOpenAck" datagrams
    LET connAck == HandleConnOpenAck(chainID, connTry, datagrams) IN
    \* update chain with "ConnOpenConfirm" datagrams
    LET connConfirm == HandleConnOpenConfirm(chainID, connAck, datagrams) IN
    
    connConfirm

(***************
Channel update operators
***************)    

\* Handle "ChanOpenInit" datagrams
HandleChanOpenInit(chainID, chain, datagrams) ==
    \* TODO
    chain

\* Handle "ChanOpenTry" datagrams
HandleChanOpenTry(chainID, chain, datagrams) ==
    \* TODO
    chain

\* Handle "ChanOpenAck" datagrams
HandleChanOpenAck(chainID, chain, datagrams) ==
    \* TODO
    chain

\* Handle "ChanOpenConfirm" datagrams
HandleChanOpenConfirm(chainID, chain, datagrams) ==
    \* TODO
    chain

\* Update the channels on chain with chainID, 
\* using the channel datagrams generated by the relayer
ChannelUpdate(chainID, chain, datagrams) ==
    \* update chain with "ChanOpenInit" datagrams
    LET chanInit == HandleChanOpenInit(chainID, chain, datagrams) IN
    \* update chain with "ChanOpenTry" datagrams
    LET chanTry == HandleChanOpenTry(chainID, chanInit, datagrams) IN
    \* update chain with "ChanOpenAck" datagrams
    LET chanAck == HandleChanOpenAck(chainID, chanTry, datagrams) IN
    \* update chain with "ChanOpenConfirm" datagrams
    LET chanConfirm == HandleChanOpenConfirm(chainID, chanAck, datagrams) IN
    
    chanConfirm
    


(***************
Chain update operators
***************) 
 
\* Update chainID with the received datagrams
\* Currently, only supporting ICS 002: Client updates
UpdateChain(chainID, datagrams) == 
    LET chain == chains[chainID] IN
    \* ICS 002: Client updates
    LET lightClientsUpdated == LightClientUpdate(chainID, chain, datagrams) IN 
    \* ICS 003: Connection updates
    LET connectionsUpdated == ConnectionUpdate(chainID, lightClientsUpdated, datagrams) IN
    \* ICS 004: Channel updates
    LET channelsUpdated == ChannelUpdate(chainID, connectionsUpdated, datagrams) IN
    
    channelsUpdated
    
(***************
Chain actions
***************)       

\* Advance the height of the chain until MaxHeight is reached
AdvanceChain ==
    \E chainID \in ChainIDs :
        /\ chains[chainID].height < MaxHeight
        /\ chains' = [chains EXCEPT 
                        ![chainID].height = chains[chainID].height + 1                                            
                     ]
        /\ UNCHANGED pendingDatagrams

\* Receive the datagrams and update the chain state        
ReceiveDatagrams ==
    \E chainID \in ChainIDs :
        /\ pendingDatagrams[chainID] /= {} 
        /\ chains' = [chains EXCEPT 
                        ![chainID] = UpdateChain(chainID, pendingDatagrams[chainID])
                     ]
                        
        /\ pendingDatagrams' = [pendingDatagrams EXCEPT
                                    ![chainID] = {}
                               ]
\* Initial value of the chain: 
\*      - height is initialized to 1
\*      - the counterparty light client is uninitialized
InitChain ==
    [height |-> 1,
     counterpartyClientHeight |-> nullHeight]

(***************
Specification
***************)

\* Initial state predicate
\*    Initially
\*        - each chain is initialized to InitChain
\*        - pendingDatagrams for each chain is empty
Init ==    
    /\ chains = [chainID \in ChainIDs |-> InitChain]
    /\ pendingDatagrams = [chainID \in ChainIDs |-> {}]

\* Next state action
\*    One of the chains either
\*        - advances its height
\*        - receives datagrams and updates its state
Next == 
    \/ AdvanceChain
    \/ ReceiveDatagrams
    \/ UNCHANGED vars

\* Fairness constraints 
Fairness ==
    /\ WF_vars(AdvanceChain)
    /\ WF_vars(ReceiveDatagrams) 
 
(************
Invariants
************)

\* Type invariant           
TypeOK ==    
    /\ chains \in [ChainIDs -> Chains]
    /\ pendingDatagrams \in [ChainIDs -> SUBSET Datagrams]     

(************
Helper operators used in properties
************)

\* returns true if there is a "CreateClient" datagram
\* in the pending datagrams for chainID
IsCreateClientInPendingDatagrams(chainID) ==
    \E h \in Heights:
        [type |-> "CreateClient", clientID |-> GetCounterpartyClientID(chainID), height |-> h] 
            \in pendingDatagrams[chainID]

\* returns true if there is a "ClientUpdate" datagram
\* in the pending datagrams for chainID and height h           
IsClientUpdateInPendingDatagrams(chainID, h) ==
    [type |-> "ClientUpdate", clientID |-> GetCounterpartyClientID(chainID), height |-> h] 
        \in pendingDatagrams[chainID]
            

\* returns true if the counterparty client is initialized on chainID
IsCounterpartyClientOnChain(chainID) ==
    chains[chainID].counterpartyClientHeight /= nullHeight

\* returns true if the counterparty client height on chainID is greater or equal than height
CounterpartyClientHeightUpdated(chainID, height) ==
    chains[chainID].counterpartyClientHeight >= height

(************
Properties
************)

\* it ALWAYS holds that, for every chainID:
\*    - if   
\*        * there is a "CreateClient" datagram in pending datagrams of chainID 
\*        * a counterparty client does not exist on chainID
\*    - then 
\*        * the counterparty client is EVENTUALLY created on chainID 
ClientCreated ==
    [](\A chainID \in ChainIDs :  
        (/\ IsCreateClientInPendingDatagrams(chainID) 
         /\ ~IsCounterpartyClientOnChain(chainID))
           => (<>(IsCounterpartyClientOnChain(chainID))))  

\* it ALWAYS holds that, for every chainID:
\*    - if   
\*        * there is a "ClientUpdate" datagram in pending datagrams of chainID 
\*          for height h
\*        * the counterparty client height is smaller than h
\*    - then 
\*        * the counterparty client height is EVENTUALLY udpated to at least h  
ClientUpdated ==
    [](\A chainID \in ChainIDs : \A h \in Heights : 
        (/\ IsClientUpdateInPendingDatagrams(chainID, h) 
         /\ GetCounterpartyClientHeight(chainID) < h)
           => (<>(CounterpartyClientHeightUpdated(chainID, h))))

\* for every chainID, it is always the case that the height of the chain
\* does not decrease                      
HeightsDontDecrease ==
    [](\A chainID \in ChainIDs : \A h \in Heights :
        (chains[chainID].height = h) 
            => <>(chains[chainID].height >= h))                       
                        
=============================================================================
\* Modification History
\* Last modified Wed Mar 25 17:34:23 CET 2020 by ilinastoilkovska
\* Created Fri Mar 13 19:48:22 CET 2020 by ilinastoilkovska
