<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concrete Composition - IBC Relayer Framework Guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-technical-background.html"><strong aria-hidden="true">2.</strong> Technical Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02-technical-background/01-simple-greeter.html"><strong aria-hidden="true">2.1.</strong> Simple Greeter</a></li><li class="chapter-item expanded "><a href="../02-technical-background/02-dynamic-typing.html"><strong aria-hidden="true">2.2.</strong> Comparison with Dynamic Typing</a></li><li class="chapter-item expanded "><a href="../02-technical-background/03-generic-context.html"><strong aria-hidden="true">2.3.</strong> Generic Context</a></li><li class="chapter-item expanded "><a href="../02-technical-background/04-error-context.html"><strong aria-hidden="true">2.4.</strong> Error Context</a></li><li class="chapter-item expanded "><a href="../02-technical-background/05-explicit-binding.html"><strong aria-hidden="true">2.5.</strong> Explicit Associated Type Binding</a></li><li class="chapter-item expanded "><a href="../02-technical-background/06-generic-person.html"><strong aria-hidden="true">2.6.</strong> Generic Person</a></li><li class="chapter-item expanded "><a href="../02-technical-background/07-programs-as-types.html"><strong aria-hidden="true">2.7.</strong> Programs as Types</a></li><li class="chapter-item expanded "><a href="../02-technical-background/08-context-implementation.html"><strong aria-hidden="true">2.8.</strong> Context Implementation</a></li><li class="chapter-item expanded "><a href="../02-technical-background/09-dependency-injection.html"><strong aria-hidden="true">2.9.</strong> Compile-Time Dependency Injection</a></li><li class="chapter-item expanded "><a href="../02-technical-background/10-component-composition.html"><strong aria-hidden="true">2.10.</strong> Component Composition</a></li><li class="chapter-item expanded "><a href="../02-technical-background/11-error-injection.html"><strong aria-hidden="true">2.11.</strong> Error Injection</a></li><li class="chapter-item expanded "><a href="../02-technical-background/12-multiple-bindings.html"><strong aria-hidden="true">2.12.</strong> Multiple Type Bindings</a></li><li class="chapter-item expanded "><a href="../02-technical-background/13-concrete-composition.html" class="active"><strong aria-hidden="true">2.13.</strong> Concrete Composition</a></li><li class="chapter-item expanded "><a href="../02-technical-background/14-multi-contexts.html"><strong aria-hidden="true">2.14.</strong> Multiple Context Implementations</a></li><li class="chapter-item expanded "><a href="../02-technical-background/15-generic-store.html"><strong aria-hidden="true">2.15.</strong> Generic Store</a></li><li class="chapter-item expanded "><a href="../02-technical-background/16-querier-consumer.html"><strong aria-hidden="true">2.16.</strong> Querier Consumer</a></li><li class="chapter-item expanded "><a href="../02-technical-background/17-selfless-components.html"><strong aria-hidden="true">2.17.</strong> Selfless Components</a></li><li class="chapter-item expanded "><a href="../02-technical-background/18-store-context-impl.html"><strong aria-hidden="true">2.18.</strong> Store Context Implementation</a></li><li class="chapter-item expanded "><a href="../02-technical-background/19-multi-context-impls.html"><strong aria-hidden="true">2.19.</strong> Multiple Context Implementations</a></li><li class="chapter-item expanded "><a href="../02-technical-background/20-caching-querier.html"><strong aria-hidden="true">2.20.</strong> Caching Querier</a></li><li class="chapter-item expanded "><a href="../02-technical-background/21-caching-app-context.html"><strong aria-hidden="true">2.21.</strong> Caching App Context</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">IBC Relayer Framework Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="concrete-composition"><a class="header" href="#concrete-composition">Concrete Composition</a></h1>
<p>Now that we have both <code>SimpleGreeter</code> and <code>DaytimeGreeter</code> implemented, we
can look at how we can define a fully application context that satisfies the
constraints of both greeters. To better structure our application, we also
separate out different parts of the code into separate modules.</p>
<p>First, we put all the abstract traits into a <code>traits</code> module:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
  mod traits {
    pub trait NamedPerson {
      fn name(&amp;self) -&gt; &amp;str;
    }

    pub trait SimpleTime {
      fn is_daytime(&amp;self) -&gt; bool;
    }

    pub trait ErrorContext {
      type Error;
    }

    pub trait PersonContext {
      type PersonId;
      type Person: NamedPerson;
    }

    pub trait TimeContext {
      type Time;

      fn now(&amp;self) -&gt; Self::Time;
    }
  }

  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This module do not contain any concrete type definition, and thus can have
minimal dependency to external crates.</p>
<p>In practice, the trait definitions can be placed in different sub-modules, so
that we can have more fine grained control of which traits a component depends
on.</p>
<p>Next, we define <code>SimpleGreeter</code> and <code>DaytimeGreeter</code> in separate modules.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
  mod traits {
    // ...
<span class="boring">   pub trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait SimpleTime {
</span><span class="boring">     fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait ErrorContext {
</span><span class="boring">     type Error;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait TimeContext {
</span><span class="boring">     type Time;
</span><span class="boring">
</span><span class="boring">     fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait QueryPersonContext: PersonContext + ErrorContext {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">       -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait Greeter&lt;Context&gt;
</span><span class="boring">   where
</span><span class="boring">     Context: PersonContext + ErrorContext,
</span><span class="boring">   {
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">       -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">   }
</span>  }

  mod simple_greeter {
    use super::traits::{Greeter, NamedPerson, QueryPersonContext};

    pub struct SimpleGreeter;

    impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
    where
      Context: QueryPersonContext,
    {
      fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
        -&gt; Result&lt;(), Context::Error&gt;
      {
        let person = context.query_person(person_id)?;
        println!(&quot;Hello, {}&quot;, person.name());
        Ok(())
      }
    }
  }

  mod daytime_greeter {
    use super::traits::{
      Greeter, ErrorContext, PersonContext,
      TimeContext, SimpleTime,
    };

    pub struct DaytimeGreeter&lt;InGreeter&gt;(pub InGreeter);

    pub struct ShopClosedError&lt;Time&gt; { time: Time }

    impl&lt;Context, InGreeter, Time, Error, PersonId&gt;
      Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
    where
      InGreeter: Greeter&lt;Context&gt;,
      Context: ErrorContext&lt;Error=Error&gt;,
      Context: PersonContext&lt;PersonId=PersonId&gt;,
      Context: TimeContext&lt;Time=Time&gt;,
      Time: SimpleTime,
      Error: From&lt;ShopClosedError&lt;Time&gt;&gt;,
    {
      fn greet(&amp;self, context: &amp;Context, person_id: &amp;PersonId)
        -&gt; Result&lt;(), Error&gt;
      {
        let now = context.now();
        if now.is_daytime() {
          self.0.greet(context, person_id)
        } else {
          Err(ShopClosedError { time: now }.into())
        }
      }
    }
  }

  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The two greeter components do not depend on each other, but they all depend
on the <code>traits</code> crate to make use the abstract definitions. Since these
components do not depend on other crates, they are also <em>abstract</em> components
that can be instantiated with <em>any</em> context types that satisfy the trait
bounds.</p>
<p>Next, we define our concrete <code>AppContext</code> struct that implements all
context traits:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
  mod traits {
    // ...
<span class="boring">   pub trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait SimpleTime {
</span><span class="boring">     fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait ErrorContext {
</span><span class="boring">     type Error;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait TimeContext {
</span><span class="boring">     type Time;
</span><span class="boring">
</span><span class="boring">     fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait QueryPersonContext: PersonContext + ErrorContext {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">       -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait Greeter&lt;Context&gt;
</span><span class="boring">   where
</span><span class="boring">     Context: PersonContext + ErrorContext,
</span><span class="boring">   {
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">       -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">   }
</span>  }

  mod simple_greeter {
    // ...
  }

  mod daytime_greeter {
    pub struct ShopClosedError&lt;Time&gt; { time: Time }
    // ...
  }

  mod context {
    use super::traits::*;
    use super::daytime_greeter::ShopClosedError;

    #[derive(Copy, Clone, PartialEq, Eq)]
    pub enum DummyTime {
      DayTime,
      NightTime,
    }

    pub struct BasicPerson {
      name: String,
    }

    pub struct AppContext {
      database: Database,
      time: DummyTime,
    }

    // Database stubs
    struct Database;
    struct DbError;

    pub enum AppError {
      Database(DbError),
      ShopClosed(ShopClosedError&lt;DummyTime&gt;),
      // ...
    }

    impl ErrorContext for AppContext {
      type Error = AppError;
    }

    impl PersonContext for AppContext {
      type PersonId = String;
      type Person = BasicPerson;
    }

    impl TimeContext for AppContext {
      type Time = DummyTime;

      fn now(&amp;self) -&gt; DummyTime {
        self.time
      }
    }

    impl QueryPersonContext for AppContext {
      fn query_person(&amp;self, person_id: &amp;Self::PersonId)
        -&gt; Result&lt;Self::Person, Self::Error&gt;
      {
        unimplemented!() // database stub
      }
    }

    impl NamedPerson for BasicPerson {
      fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
      }
    }

    impl SimpleTime for DummyTime {
      fn is_daytime(&amp;self) -&gt; bool {
        self == &amp;DummyTime::DayTime
      }
    }

    impl From&lt;ShopClosedError&lt;DummyTime&gt;&gt; for AppError {
      fn from(err: ShopClosedError&lt;DummyTime&gt;) -&gt; Self {
        Self::ShopClosed(err)
      }
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Compared to before, we define a <code>DummyTime</code> struct that
mocks the current time with either day time or night time. We then
implement <code>TimeContext</code> for <code>AppContext</code>, with <code>DummyTime</code> being the
<code>Time</code> type. We also add <code>ShopClosedError&lt;DummyTime&gt;</code> as a variant to
<code>AppError</code>, and define a <code>From</code> instance for it.</p>
<p>As we can see in this exercise, by having all types used by the greeter
components as abstract types, it becomes very easy to mock up dependencies
like time without having to commit to a specific time library. The explicit
dependencies also help us better understand what features are really needed
from the concrete types. If we know that our application only need the
<code>SimpleTime</code> trait, then there are more options out there that we can
try out and switch easily.</p>
<p>It is also worth noting that it doesn't matter whether the concrete types
<code>AppContext</code> and <code>BasicPerson</code> can have private fields or public fields.
Since the components do not have access to the concrete types, all concrete
fields are essentially private and can only be exposed via trait methods.</p>
<p>Finally, we define an <code>instances</code> module to encapsulate the witness of
satisfying all dependencies required from <code>AppContext</code> to implement
the <code>Greeter</code> components:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
  mod traits {
    // ...
<span class="boring">   pub trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait SimpleTime {
</span><span class="boring">     fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait ErrorContext {
</span><span class="boring">     type Error;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait TimeContext {
</span><span class="boring">     type Time;
</span><span class="boring">
</span><span class="boring">     fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait QueryPersonContext: PersonContext + ErrorContext {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">       -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub trait Greeter&lt;Context&gt;
</span><span class="boring">   where
</span><span class="boring">     Context: PersonContext + ErrorContext,
</span><span class="boring">   {
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">       -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">   }
</span>  }

  mod simple_greeter {
    // ...
<span class="boring">   use super::traits::{Greeter, NamedPerson, QueryPersonContext};
</span><span class="boring">
</span><span class="boring">   pub struct SimpleGreeter;
</span><span class="boring">
</span><span class="boring">   impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
</span><span class="boring">   where
</span><span class="boring">     Context: QueryPersonContext,
</span><span class="boring">   {
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">       -&gt; Result&lt;(), Context::Error&gt;
</span><span class="boring">     {
</span><span class="boring">       let person = context.query_person(person_id)?;
</span><span class="boring">       println!(&quot;Hello, {}&quot;, person.name());
</span><span class="boring">       Ok(())
</span><span class="boring">     }
</span><span class="boring">   }
</span>  }

  mod daytime_greeter {
    // ...
<span class="boring">   use super::traits::{
</span><span class="boring">     Greeter, ErrorContext, PersonContext,
</span><span class="boring">     TimeContext, SimpleTime,
</span><span class="boring">   };
</span><span class="boring">
</span><span class="boring">   pub struct DaytimeGreeter&lt;InGreeter&gt;(pub InGreeter);
</span><span class="boring">
</span><span class="boring">   pub struct ShopClosedError&lt;Time&gt; { time: Time }
</span><span class="boring">
</span><span class="boring">   impl&lt;Context, InGreeter, Time, Error, PersonId&gt;
</span><span class="boring">     Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
</span><span class="boring">   where
</span><span class="boring">     InGreeter: Greeter&lt;Context&gt;,
</span><span class="boring">     Context: ErrorContext&lt;Error=Error&gt;,
</span><span class="boring">     Context: PersonContext&lt;PersonId=PersonId&gt;,
</span><span class="boring">     Context: TimeContext&lt;Time=Time&gt;,
</span><span class="boring">     Time: SimpleTime,
</span><span class="boring">     Error: From&lt;ShopClosedError&lt;Time&gt;&gt;,
</span><span class="boring">   {
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;PersonId)
</span><span class="boring">       -&gt; Result&lt;(), Error&gt;
</span><span class="boring">     {
</span><span class="boring">       let now = context.now();
</span><span class="boring">       if now.is_daytime() {
</span><span class="boring">         self.0.greet(context, person_id)
</span><span class="boring">       } else {
</span><span class="boring">         Err(ShopClosedError { time: now }.into())
</span><span class="boring">       }
</span><span class="boring">     }
</span><span class="boring">   }
</span>  }

  mod context {
    // ...
<span class="boring">   use super::traits::*;
</span><span class="boring">   use super::daytime_greeter::ShopClosedError;
</span><span class="boring">
</span><span class="boring">   #[derive(Copy, Clone, PartialEq, Eq)]
</span><span class="boring">   pub enum DummyTime {
</span><span class="boring">     DayTime,
</span><span class="boring">     NightTime,
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub struct BasicPerson {
</span><span class="boring">     name: String,
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub struct AppContext {
</span><span class="boring">     database: Database,
</span><span class="boring">     time: DummyTime,
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   // Database stubs
</span><span class="boring">   struct Database;
</span><span class="boring">   struct DbError;
</span><span class="boring">
</span><span class="boring">   pub enum AppError {
</span><span class="boring">     Database(DbError),
</span><span class="boring">     ShopClosed(ShopClosedError&lt;DummyTime&gt;),
</span><span class="boring">     // ...
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   impl ErrorContext for AppContext {
</span><span class="boring">     type Error = AppError;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   impl PersonContext for AppContext {
</span><span class="boring">     type PersonId = String;
</span><span class="boring">     type Person = BasicPerson;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   impl TimeContext for AppContext {
</span><span class="boring">     type Time = DummyTime;
</span><span class="boring">
</span><span class="boring">     fn now(&amp;self) -&gt; DummyTime {
</span><span class="boring">       self.time
</span><span class="boring">     }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   impl QueryPersonContext for AppContext {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">       -&gt; Result&lt;Self::Person, Self::Error&gt;
</span><span class="boring">     {
</span><span class="boring">       unimplemented!() // database stub
</span><span class="boring">     }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   impl NamedPerson for BasicPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str {
</span><span class="boring">       &amp;self.name
</span><span class="boring">     }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   impl SimpleTime for DummyTime {
</span><span class="boring">     fn is_daytime(&amp;self) -&gt; bool {
</span><span class="boring">       self == &amp;DummyTime::DayTime
</span><span class="boring">     }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   impl From&lt;ShopClosedError&lt;DummyTime&gt;&gt; for AppError {
</span><span class="boring">     fn from(err: ShopClosedError&lt;DummyTime&gt;) -&gt; Self {
</span><span class="boring">       Self::ShopClosed(err)
</span><span class="boring">     }
</span><span class="boring">   }
</span>  }

  mod instances {
    use super::traits::Greeter;
    use super::context::AppContext;
    use super::simple_greeter::SimpleGreeter;
    use super::daytime_greeter::DaytimeGreeter;

    pub fn base_greeter() -&gt; impl Greeter&lt;AppContext&gt; {
      SimpleGreeter
    }

    pub fn app_greeter() -&gt; impl Greeter&lt;AppContext&gt; {
      DaytimeGreeter(base_greeter())
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>We first have a <code>base_greeter</code> function which witnesses that <code>SimpleGreeter</code>
implements <code>Greeter&lt;AppContext&gt;</code>. We then define an <code>app_greeter</code> function
which witnesses that <code>DaytimeGreeter&lt;SimpleGreeter&gt;</code> <em>also</em> implements
<code>Greeter&lt;AppContext&gt;</code>.</p>
<p>Notice that in the <code>app_greeter</code> body, we construct the greeter with
<code>DaytimeGreeter(base_greeter())</code> instead of <code>DaytimeGreeter(SimpleGreeter)</code>.
In theory, both expressions are valid and have the same effect. But by calling
<code>base_greeter</code> inside <code>app_greeter</code>, we are stating that <code>app_greeter</code> do
<em>not</em> actually care which concrete type of the base greeter has, aside from
it implementing <code>Greeter&lt;AppContext&gt;</code>.</p>
<p>Having separate witness functions can also help us debug any error in
dependencies much more easily. Let's say if we forgot to implement
<code>QueryPersonContext</code> for <code>AppContext</code>, the dependency for <code>SimpleGreeter</code>
would not be satisfied, and we would get a type error in <code>base_greeter</code>.
On the other hand, the body of <code>app_greeter</code> would not get any error,
because it is not aware of the base greeter being <code>SimpleGreeter</code>.</p>
<p>If we were to write the complex expression in one go, like
<code>DaytimeGreeter(SimpleGreeter)</code>, it would be less clear which part of the
expression caused the type error. Things would get worse if we have more
complex component composition. Therefore it is always a good practice to
define the component instantiation in multiple smaller functions, so that
it is clear to the reader whether the dependencies are being resolved
correctly.</p>
<h2 id="reader-monad"><a class="header" href="#reader-monad">Reader Monad</a></h2>
<p>Readers from functional programming background such as Haskellers may notice
that the context pattern look similar to the reader monad pattern. This is
correct, as we are defining a global <code>Context</code> type and pass it as a function
argument to all code that requires the context. Additionally, we make use
of the trait (typeclass) system in Rust for compile-time dependency injection,
and the same pattern can be applied for the context type used in reader monads.</p>
<p>For Rust readers, the main difference of the pattern described here with the
reader monad is that we are passing the context value as explicit argument
without using any monadic construct. This is slightly more verbose, but
the benefit is we still get to enjoy much of the benefits of reader monad
without requiring Rust programmers to learn what a monad really is.
(hint: if you know how to use <code>Result</code> and <code>Option</code>, you might already
understand monad without realizing it).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../02-technical-background/12-multiple-bindings.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../02-technical-background/14-multi-contexts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../02-technical-background/12-multiple-bindings.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../02-technical-background/14-multi-contexts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
