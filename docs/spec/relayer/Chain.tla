---------------------------- MODULE Chain ----------------------------

EXTENDS Integers, FiniteSets, Sequences, RelayerDefinitions, 
        ClientHandlers, ConnectionHandlers, ChannelHandlers, PacketHandlers
        
CONSTANTS MaxHeight, \* maximal chain height
          ChainID, \* chain identifier
          ChannelOrdering, \* indicate whether the channels are ordered or unordered  
          MaxPacketSeq \* maximal packet sequence number

VARIABLES chainStore, \* chain store, containing client heights, a connection end, a channel end 
          incomingDatagrams, \* set of incoming datagrams
          packetLog, \* packet log
          appPacketSeq, \* packet sequence number from the application on the chain
          history \* history variables

vars == <<chainStore, incomingDatagrams, packetLog, appPacketSeq, history>>
Heights == 1..MaxHeight \* set of possible heights of the chains in the system          

(***************************************************************************
 Client update operators
 ***************************************************************************)
\* Update the clients on chain with chainID, 
\* using the client datagrams generated by the relayer      
\* (Handler operators defined in ClientHandlers.tla)
LightClientUpdate(chainID, store, datagrams) == 
    \* create clients
    LET clientCreatedStore == HandleCreateClient(chainID, store, datagrams) IN
    \* update clients
    LET clientUpdatedStore == HandleUpdateClient(chainID, clientCreatedStore, datagrams) IN

    clientUpdatedStore
    
(***************************************************************************
 Connection update operators
 ***************************************************************************)
\* Update the connections on chain with chainID, 
\* using the connection datagrams generated by the relayer
\* (Handler operators defined in ConnectionHandlers.tla)
ConnectionUpdate(chainID, store, hist, datagrams) ==
    \* update the chain store with "ConnOpenInit" datagrams, as well as the history variable
    LET connOpenInitRes == HandleConnOpenInit(chainID, store, hist, datagrams) IN
    LET connOpenInitStore == AsChainStore(connOpenInitRes.store) IN
    LET connOpenInitHistory == AsHistory(connOpenInitRes.history) IN
    
    \* update the chain store with "ConnOpenTry" datagrams, as well as the history variable 
    LET connOpenTryRes == HandleConnOpenTry(chainID, connOpenInitStore, connOpenInitHistory, datagrams) IN
    LET connOpenTryStore == AsChainStore(connOpenTryRes.store) IN
    LET connOpenTryHistory == AsHistory(connOpenTryRes.history) IN
    
    \* update the chain store with "ConnOpenAck" datagrams, as well as the history variable 
    LET connOpenAckRes == HandleConnOpenAck(chainID, connOpenTryStore, connOpenTryHistory, datagrams) IN
    LET connOpenAckStore == AsChainStore(connOpenAckRes.store) IN
    LET connOpenAckHistory == AsHistory(connOpenAckRes.history) IN
    
    \* update the chain store with "ConnOpenConfirm" datagrams, as well as the history variable
    LET connOpenConfirmRes == HandleConnOpenConfirm(chainID, connOpenAckStore, connOpenAckHistory, datagrams) IN
    
    \* output both the updated chain store and updated history variable
    connOpenConfirmRes

(***************************************************************************
 Channel update operators
 ***************************************************************************)
\* Update the channel on chain with chainID, 
\* using the channel datagrams generated by the relayer
\* (Handler operators defined in ChannelHandlers.tla)
ChannelUpdate(chainID, store, hist, datagrams) ==
    \* update the chain store with "ChanOpenInit" datagrams, as well as the history variable
    LET chanOpenInitRes == HandleChanOpenInit(chainID, store, hist, datagrams) IN
    LET chanOpenInitStore == AsChainStore(chanOpenInitRes.store) IN
    LET chanOpenInitHistory == AsHistory(chanOpenInitRes.history) IN
    
    \* update the chain store with "ChanOpenTry" datagrams, as well as the history variable
    LET chanOpenTryRes == HandleChanOpenTry(chainID, chanOpenInitStore, chanOpenInitHistory, datagrams) IN
    LET chanOpenTryStore == AsChainStore(chanOpenTryRes.store) IN
    LET chanOpenTryHistory == AsHistory(chanOpenTryRes.history) IN
    
    \* update the chain store with "ChanOpenAck" datagrams, as well as the history variable
    LET chanOpenAckRes == HandleChanOpenAck(chainID, chanOpenTryStore, chanOpenTryHistory, datagrams) IN
    LET chanOpenAckStore == AsChainStore(chanOpenAckRes.store) IN
    LET chanOpenAckHistory == AsHistory(chanOpenAckRes.history) IN
    
    \* update the chain store with "ChanOpenConfirm" datagrams, as well as the history variable
    LET chanOpenConfirmRes == HandleChanOpenConfirm(chainID, chanOpenAckStore, chanOpenAckHistory, datagrams) IN
    LET chanOpenConfirmStore == AsChainStore(chanOpenConfirmRes.store) IN
    LET chanOpenConfirmHistory == AsHistory(chanOpenConfirmRes.history) IN
    
    \* update the chain store with "ChanCloseInit" datagrams, as well as the history variable
    LET chanCloseInitRes == HandleChanCloseInit(chainID, chanOpenConfirmStore, chanOpenConfirmHistory, datagrams) IN
    LET chanCloseInitStore == AsChainStore(chanCloseInitRes.store) IN
    LET chanCloseInitHistory == AsHistory(chanCloseInitRes.history) IN
    
    \* update the chain store with "ChanCloseConfirm" datagrams, as well as the history variable
    LET chanCloseConfirmRes == HandleChanCloseConfirm(chainID, chanCloseInitStore, chanCloseInitHistory, datagrams) IN
    
    chanCloseConfirmRes

(***************************************************************************
 Packet update operators
 ***************************************************************************)
\* Update the chain store of the chain with chainID, 
\* using the packet datagrams generated by the relayer
\* (Handler operators defined in PacketHandlers.tla)    
PacketUpdate(chainID, store, datagrams) ==
    \* update the chain store with "PacketRecv" datagrams
    LET packetRecvStore == HandlePacketRecv(chainID, store, datagrams) IN
    \* update the chain store with "PacketRecv" datagrams 
    LET packetAckStore == HandlePacketAck(chainID, packetRecvStore, datagrams) IN 
    
    packetAckStore
        

(***************************************************************************
 Chain update operators
 ***************************************************************************)
\* Update chainID with the received datagrams
\* Supports ICS2 (Clients), ICS3 (Connections), and ICS4 (Channels).
UpdateChainStoreAndHistory(chainID, datagrams) == 
    \* ICS 002: Client updates
    LET clientUpdatedStore == LightClientUpdate(chainID, chainStore, datagrams) IN
     
    \* ICS 003: Connection updates
    LET connectionUpdatedRes == ConnectionUpdate(chainID, clientUpdatedStore, history, datagrams) IN
    LET connectionUpdatedStore == AsChainStore(connectionUpdatedRes.store) IN
    LET connectionUpdatedHistory == AsHistory(connectionUpdatedRes.history) IN
    
    \* ICS 004: Channel updates
    LET channelUpdatedRes == ChannelUpdate(chainID, connectionUpdatedStore, connectionUpdatedHistory, datagrams) IN
    LET channelUpdatedStore == AsChainStore(channelUpdatedRes.store) IN
    LET channelUpdatedHistory == AsHistory(channelUpdatedRes.history) IN
    
    \* ICS 004: Packet transmission
\*    LET packetsUpdatedStore == PacketUpdate(chainID, channelUpdatedStore, datagrams) IN
    
    \* update height
    LET updatedChainStore == 
        IF /\ chainStore /= channelUpdatedStore
           /\ chainStore.height + 1 \in Heights 
        THEN [channelUpdatedStore EXCEPT !.height = chainStore.height + 1]
        ELSE channelUpdatedStore
    IN
    
    [store |-> AsChainStore(updatedChainStore), 
     history |-> AsHistory(channelUpdatedHistory)] 

(***************************************************************************
 Chain actions
 ***************************************************************************)       
\* Advance the height of the chain until MaxHeight is reached
AdvanceChain ==
    /\ chainStore.height + 1 \in Heights
    /\ chainStore' = [chainStore EXCEPT !.height = chainStore.height + 1]
    /\ UNCHANGED <<incomingDatagrams, packetLog, appPacketSeq, history>>

\* Send a packet
SendPacket ==   
    \* Create a packet 
    \* Abstract away from packet data, ports, and timestamp. 
    \* Assume timeoutHeight is MaxHeight  
    LET packet == [
        sequence |-> appPacketSeq,
        timeoutHeight |-> MaxHeight,
        srcChannelID |-> GetChannelID(ChainID),
        dsrChannelID |-> GetChannelID(GetCounterpartyChainID(ChainID))
    ] IN
    LET connectionEnd == chainStore.connectionEnd IN
    LET channelEnd == chainStore.connectionEnd.channelEnd IN
    LET latestClientHeight == GetMaxCounterpartyClientHeight(chainStore) IN
    \* channel end is neither null nor closed
    /\ channelEnd.state \notin {"UNINIT", "CLOSED"}
    \* connection end is initialized
    /\ connectionEnd.state /= "UNINIT"
    \* timeout height has not passed
    /\ packet.timeoutHeight = 0 \/ latestClientHeight < packet.timeoutHeight
    \* either the channel is unordered, or packetSeq is nextSentSeq
    \* update the chain store accordingly
    /\ \/ /\ channelEnd.order = "UNORDERED"
          /\ chainStore' = [chainStore EXCEPT 
                !.packetCommitment =  
                    chainStore.packetCommitment \union {[channelID |-> packet.srcChannelID,
                                                          sequence |-> packet.sequence,
                                                          timeoutHeight |-> packet.timeoutHeight]}
              ]               
       \/ /\ packet.sequence = channelEnd.nextSentSeq
          /\ packet.sequence <= MaxPacketSeq
          /\ chainStore' = [chainStore EXCEPT 
                !.packetCommitment =  
                    chainStore.packetCommitment \union {[channelID |-> packet.srcChannelID,
                                                          sequence |-> packet.sequence,
                                                          timeoutHeight |-> packet.timeoutHeight]},
                !.connectionEnd.channelEnd.nextSentSeq = channelEnd.nextSentSeq + 1
              ]               
    \* log sent packet
    /\ packetLog' = AsPacketLog(packetLog \union {[type |-> "sent", 
                                       srcChainID |-> ChainID,  
                                       sequence |-> packet.sequence ,
                                       timeoutHeight |-> packet.timeoutHeight]})
    \* increase application packet sequence
    /\ appPacketSeq' = appPacketSeq + 1

\* Handle the datagrams and update the chain state        
HandleIncomingDatagrams ==
    LET updateRes == UpdateChainStoreAndHistory(ChainID, incomingDatagrams) IN
    /\ incomingDatagrams /= AsSetDatagrams({}) 
    /\ chainStore' = updateRes.store
    /\ history' = updateRes.history
    /\ incomingDatagrams' = AsSetDatagrams({})
    /\ UNCHANGED <<appPacketSeq, packetLog>>

(***************************************************************************
 Specification
 ***************************************************************************)
\* Initial state predicate
\* Initially
\*  - each chain is initialized to InitChain (defined in RelayerDefinitions.tla)
\*  - pendingDatagrams for each chain is empty
\*  - the packetSeq is set to 1
Init == 
    /\ chainStore = InitChainStore(ChannelOrdering)
    /\ incomingDatagrams = AsSetDatagrams({})
    /\ appPacketSeq = AsInt(1)
    /\ history = InitHistory

\* Next state action
\* The chain either
\*  - advances its height
\*  - receives datagrams and updates its state
\*  - sends a packet
Next ==
    \/ AdvanceChain
    \/ HandleIncomingDatagrams
\*    \/ SendPacket
    \/ UNCHANGED vars
    
Fairness ==
    /\ WF_vars(AdvanceChain)
    /\ WF_vars(HandleIncomingDatagrams)
        
(***************************************************************************
 Invariants
 ***************************************************************************)
\* Type invariant   
\* ChainStores and Datagrams are defined in RelayerDefinitions.tla        
TypeOK ==    
    /\ chainStore \in ChainStores(MaxHeight, ChannelOrdering, MaxPacketSeq)
    /\ incomingDatagrams \in SUBSET Datagrams(MaxHeight, MaxPacketSeq)
    /\ appPacketSeq \in 1..MaxPacketSeq
    /\ history \in Histories
    /\ packetLog \in SUBSET Packets(MaxHeight, MaxPacketSeq)
    
(***************************************************************************
 Properties
 ***************************************************************************)    
\* it ALWAYS holds that the height of the chain does not EVENTUALLY decrease
HeightDoesntDecrease ==
    [](\A h \in Heights : chainStore.height = h 
        => <>(chainStore.height >= h))

=============================================================================
\* Modification History
\* Last modified Tue Aug 11 10:57:03 CEST 2020 by ilinastoilkovska
\* Created Fri Jun 05 16:56:21 CET 2020 by ilinastoilkovska
