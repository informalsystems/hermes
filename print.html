<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hermes (IBC Relayer CLI) Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hermes (IBC Relayer CLI) Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hermes-guide-v1132"><a class="header" href="#hermes-guide-v1132">Hermes Guide (v1.13.2)</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Hermes is an open-source Rust implementation of a relayer for the
<a href="https://ibc.cosmos.network">Inter-Blockchain Communication protocol</a> (<strong>IBC</strong>) released under the <a href="https://crates.io/crates/ibc-relayer-cli">ibc-relayer-cli</a> crate. It provides a CLI to relay packets between Cosmos SDK chains, exposes <a href="https://prometheus.io/">Prometheus</a> metrics and offers a REST API.</p>
<p>This guide can help you set up, configure, operate and monitor Hermes to relay
packets between two or more IBC-enabled chains.</p>
<h2 id="about-hermes"><a class="header" href="#about-hermes">About Hermes</a></h2>
<p>An IBC relayer is an off-chain process responsible for relaying IBC datagrams between any two chains. The way it does so is by scanning chain states, building transactions based on these states, and submitting the transactions to the chains involved in the network.</p>
<p>The relayer is a central element in the IBC network architecture. This is because chain modules in this architecture are not directly sending messages to each other over networking infrastructure, but instead they create and store the data to be retrieved and used by a relayer to build the IBC datagrams.</p>
<p>We sometimes refer to Hermes as "IBC Relayer CLI", to make it clear that this is a relayer CLI (i.e., a binary) and distinguish it from the relayer core library (that is the crate called ibc-relayer).</p>
<p>Hermes is actively developed and maintained by <a href="https://informal.systems">Informal Systems</a> in the <a href="https://github.com/informalsystems/hermes"><code>informalsystems/hermes</code></a> repository.</p>
<blockquote>
<p>Note that Hermes is packaged as part of the <code>ibc-relayer-cli</code> crate and not the <code>hermes</code> crate, which is unrelated.</p>
</blockquote>
<h2 id="where-to-go"><a class="header" href="#where-to-go">Where to go</a></h2>
<ul>
<li>
<p><strong><a href="./glossary.html">Glossary</a></strong></p>
<ul>
<li>This section provides some definitions of terms used throughout the guide.</li>
</ul>
</li>
<li>
<p><strong><a href="./quick-start/index.html">Quick start</a></strong></p>
<ul>
<li>This section helps you install Hermes.</li>
</ul>
</li>
<li>
<p><strong><a href="./tutorials/index.html">Tutorials</a></strong></p>
<ul>
<li><strong><a href="./tutorials/local-chains/index.html">Prerequisites for local chains</a></strong>
<ul>
<li>Install <code>Gaia</code> and <code>gm</code> (Gaia Manager) for tutorials using local chains.</li>
</ul>
</li>
<li><strong><a href="./tutorials/local-chains/index.html">Two Local Chains</a></strong>
<ul>
<li>Start two local <a href="https://github.com/cosmos/gaia"><code>Cosmos Gaia</code></a> chains that support the <code>IBC</code> protocol and learn the fundamentals of IBC.</li>
</ul>
</li>
<li><strong><a href="./tutorials/more-chains/index.html">More Local Chains</a></strong>
<ul>
<li>Learn how to relay on an arbitrary topology of more than two chains by using packet filters and to run multiple instances of Hermes.</li>
</ul>
</li>
<li><strong><a href="./tutorials/production/index.html">Relaying in production</a></strong>
<ul>
<li>Learn how to set up, configure and run <code>hermes</code> on IBC-enabled chains in production.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><a href="./advanced/index.html">Advanced</a></strong></p>
<ul>
<li><strong><a href="./advanced/features.html">Features</a></strong>
<ul>
<li>This section summarizes Hermes' features and includes a comparison between the Cosmos Go relayer and Hermes.</li>
</ul>
</li>
<li><strong><a href="./advanced/troubleshooting/index.html">Troubleshooting</a></strong>
<ul>
<li>Learn the general guidelines regarding troubleshooting.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><a href="./documentation/index.html">Documentation</a></strong></p>
<ul>
<li><strong><a href="./documentation/configuration/index.html">Configuration</a></strong>
<ul>
<li>This section includes everything you need to know to configure Hermes.</li>
</ul>
</li>
<li><strong><a href="./documentation/telemetry/index.html">Telemetry</a></strong>
<ul>
<li>This section describes all Prometheus metrics and how to use them efficiently.</li>
</ul>
</li>
<li><strong><a href="./documentation/rest-api.html">REST API</a></strong>
<ul>
<li>This section presents Hermes' REST API.</li>
</ul>
</li>
<li><strong><a href="./documentation/commands/index.html">Commands Reference</a></strong>
<ul>
<li>This section describes the command line interface from which you can interact with Hermes.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Educational resources</p>
<ul>
<li><a href="https://ibc.cosmos.network/">About IBC</a>
<ul>
<li>The official IBC-Go documentation.</li>
</ul>
</li>
<li><a href="https://tutorials.cosmos.network/academy/3-ibc/1-what-is-ibc.html">Cosmos network tutorial</a>
<ul>
<li>Learn the basics of IBC in the official tutorial.</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=_xQDTj1PcEw&amp;t=4289s">Connect IBC enabled chains with Hermes</a>
<ul>
<li>Video demonstration of Hermes at Hackatom 2021.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/informalsystems/hermes/discussions/2472">Hermes FAQ Page</a>
<ul>
<li>The official FAQ of Hermes.</li>
</ul>
</li>
<li><a href="https://github.com/informalsystems/hermes">Hermes GitHub repository</a>
<ul>
<li>The official GitHub repository for Hermes.</li>
</ul>
</li>
<li><a href="https://github.com/cosmos/ics">IBC GitHub repository</a>
<ul>
<li>The official repository for the Inter-blockchain protocol (IBC).</li>
</ul>
</li>
<li><a href="https://www.ibcprotocol.dev">IBC Protocol</a>
<ul>
<li>The official IBC protocol page.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<ul>
<li>Request a <a href="index.html#new-feature-request">new feature</a> via the <a href="https://github.com/informalsystems/hermes/issues/new?assignees=&amp;labels=&amp;template=feature-request.md">feature request</a> issue template;</li>
<li>Consult the <a href="https://github.com/informalsystems/hermes/issues">list of reported issues</a> and search by relevant keywords to see if you're dealing with a known problem;</li>
<li>We would be grateful if you can submit a <a href="https://github.com/informalsystems/hermes/issues/new?assignees=&amp;labels=&amp;template=bug-report.md">bug report</a> discussing any problem you find, and from there on we can look at the problem together;</li>
<li>Reach Hermes developers and other relayer operators in the <code>#hermes</code> channel on the <a href="https://discord.com/invite/A9VqJSyUXU">IBC Gang Discord</a>.</li>
</ul>
<p>Lastly, for general questions, you can reach us at <code>hello@informal.systems</code>, or on Twitter <a href="https://twitter.com/informalinc">@informalinc</a>.</p>
<hr />
<p><strong>Disclaimer</strong> As with all software offered by Informal Systems, Hermes is offered on an “as is” basis and you use at your own risk.
Informal makes no warranties of any kind, express or implied, relating to Hermes, including no warranties of a “bug-free” nature.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>In order to run Hermes, please make sure you have all the
<a href="quick-start/./pre-requisites.html">prerequisites</a> installed on your machine.</p>
<p>Once you have these prerequisites, you can
<a href="quick-start/./installation.html">build and run Hermes</a>.</p>
<blockquote>
<p>The instructions in this guide have been tested on <code>Linux</code> and <code>MacOS</code>
environments. Most of the commands should work on both environments. It is
currently impossible to build and run <code>Hermes</code> on <code>Windows</code>.</p>
</blockquote>
<hr />
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><strong><a href="quick-start/./pre-requisites.html">Prerequisites</a></strong>
<ul>
<li>Install the latest versions of <code>Rust</code> and <code>Golang</code>.</li>
</ul>
</li>
<li><strong><a href="quick-start/./installation.html">Installation</a></strong>
<ul>
<li>Install Hermes.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-requisites"><a class="header" href="#pre-requisites">Pre-requisites</a></h1>
<h2 id="1-rust"><a class="header" href="#1-rust">1. Rust</a></h2>
<p>The IBC Relayer is developed with the <a href="https://www.rust-lang.org">Rust</a> programming language. In order to build and run the relayer you need to install and configure <code>Rust</code> on your machine.</p>
<h3 id="fresh-rust-installation"><a class="header" href="#fresh-rust-installation">Fresh Rust installation</a></h3>
<p>For instructions on how to install <code>Rust</code> on your machine please follow the official <a href="https://www.rust-lang.org/tools/install"><code>Notes about Rust Installation</code></a>.</p>
<p>The provided instructions will install all the Rust tool chain including <code>rustc</code>, <code>cargo</code>, and <code>rustup</code> that are required to build the project.</p>
<h3 id="version-requirements"><a class="header" href="#version-requirements">Version requirements</a></h3>
<p>Hermes is developed and tested using the latest stable version of Rust. To check that your tool chain is up-to-date run:</p>
<pre><code class="language-shell">rustc --version
</code></pre>
<p>In case you already had installed the Rust tool chain in the past, you can
update your installation by running <code>rustup update</code>.</p>
<h3 id="testing-the-installation"><a class="header" href="#testing-the-installation">Testing the installation</a></h3>
<p>After you install the <code>Rust</code> tool chain you can execute the following command:</p>
<pre><code class="language-shell">cargo version
</code></pre>
<p>This should display the <code>cargo</code> version and confirm the proper installation.</p>
<h2 id="2-golang"><a class="header" href="#2-golang">2. Golang</a></h2>
<p>You will also need the <strong>Go</strong> programming language installed and configured on your machine. This is a requirement for the section <a href="quick-start/../tutorials/pre-requisites/gaia.html">Installing Gaia</a>.</p>
<p>To install and configure Golang on your machine please follow the <a href="https://golang.org/doc/install">Golang official documentation</a>.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Next, go to the <a href="quick-start/./installation.html">Installation</a> section to learn how to build Hermes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-hermes"><a class="header" href="#install-hermes">Install Hermes</a></h1>
<p>There are two main approaches for obtaining Hermes:</p>
<ol>
<li>
<p>Installation:</p>
<ol>
<li>If you are running on a Unix machine (Linux/macOS), then the simplest
option is to <a href="quick-start/installation.html#install-by-downloading">download the latest binary</a>.</li>
<li>You can also install via <a href="quick-start/installation.html#install-via-cargo">Cargo</a>.</li>
</ol>
</li>
<li>
<p>Alternatively, <a href="quick-start/installation.html#build-from-source">build Hermes directly from source</a>.</p>
</li>
</ol>
<h2 id="install-by-downloading"><a class="header" href="#install-by-downloading">Install by downloading</a></h2>
<p>Simply head to the GitHub <a href="https://github.com/informalsystems/hermes/releases">Releases</a> page and download the latest
version of Hermes binary matching your platform:</p>
<ul>
<li>macOS: <code>hermes-v1.13.2-x86_64-apple-darwin.tar.gz</code> (or .zip),</li>
<li>Linux: <code>hermes-v1.13.2-x86_64-unknown-linux-gnu.tar.gz</code> (or .zip).</li>
</ul>
<p>The step-by-step instruction below should carry you through the whole process:</p>
<ol>
<li>
<p>Make the directory where we'll place the binary:</p>
<pre><code class="language-shell">mkdir -p $HOME/.hermes/bin
</code></pre>
</li>
<li>
<p>Extract the binary archive:</p>
<pre><code class="language-shell">tar -C $HOME/.hermes/bin/ -vxzf $ARCHIVE_NAME
</code></pre>
</li>
<li>
<p>Update your path, by adding this line in your <code>.bashrc</code> or <code>.zshrc</code> shell
configuration file:</p>
<pre><code class="language-shell">export PATH="$HOME/.hermes/bin:$PATH"
</code></pre>
</li>
</ol>
<blockquote>
<p>NOTE: The binary may be initially prevented from running if you're
on macOS.
See the <a href="https://support.apple.com/HT202491">"Open Anyway" instructions from this support forum</a>
if that is the case.</p>
</blockquote>
<p>You should now be able to run Hermes by invoking the <code>hermes</code> executable.</p>
<pre><code class="language-shell">hermes version

</code></pre>
<p>Which should be:</p>
<pre><code>hermes v1.13.2
</code></pre>
<h2 id="install-via-cargo"><a class="header" href="#install-via-cargo">Install via Cargo</a></h2>
<blockquote>
<p>NOTE: This approach assumes you have installed all
the <a href="quick-start/./pre-requisites.html">prerequisites</a> on your machine.</p>
</blockquote>
<p>Hermes is packaged in the <code>ibc-relayer-cli</code> Rust crate.
To install the latest release of Hermes, run the following command in a terminal:</p>
<pre><code class="language-shell">cargo install ibc-relayer-cli --bin hermes --locked
</code></pre>
<p>This will download and build the crate <code>ibc-relayer-cli</code>, and install the
<code>hermes</code> binary in <code>$HOME/.cargo/bin</code>.</p>
<blockquote>
<p>If you have not installed Rust and Cargo via <a href="https://rustup.rs">rustup.rs</a>, you may need to
add the <code>$HOME/.cargo/bin</code> directory to your <code>PATH</code> environment variable.
For most shells, this can be done by adding the following line to your
<code>.bashrc</code> or <code>.zshrc</code> configuration file:</p>
<pre><code class="language-shell">export PATH="$HOME/.cargo/bin:$PATH"
</code></pre>
</blockquote>
<p>You should now be able to run Hermes by invoking the <code>hermes</code> executable.</p>
<pre><code class="language-shell">hermes version

</code></pre>
<p>Which should be:</p>
<pre><code>hermes v1.13.2
</code></pre>
<h2 id="build-from-source"><a class="header" href="#build-from-source">Build from source</a></h2>
<h3 id="clone-the-repository"><a class="header" href="#clone-the-repository">Clone the repository</a></h3>
<p>Open a terminal and clone the <code>hermes</code> repository:</p>
<pre><code class="language-shell">git clone https://github.com/informalsystems/hermes.git

</code></pre>
<p>Change to the repository directory</p>
<pre><code class="language-shell">cd hermes
</code></pre>
<h3 id="checkout-the-latest-release"><a class="header" href="#checkout-the-latest-release">Checkout the latest release</a></h3>
<p>Go to the <a href="https://github.com/informalsystems/hermes/releases">hermes releases</a> page to see what is the most recent release.</p>
<p>Then checkout the release, for example if the most recent release is <code>v1.13.2 </code> then execute the command:</p>
<pre><code class="language-shell">git checkout v1.13.2
</code></pre>
<h3 id="building-with-cargo-build"><a class="header" href="#building-with-cargo-build">Building with <code>cargo build</code></a></h3>
<p>This command builds all the crates from the <a href="https://github.com/informalsystems/hermes"><strong><code>hermes</code></strong></a> repository, namely: the <a href="https://github.com/informalsystems/hermes/tree/master/crates/relayer"><strong><code>ibc-relayer</code></strong></a> crate, and the <a href="https://github.com/informalsystems/hermes/tree/master/crates/relayer-cli"><strong><code>ibc-relayer-cli</code></strong></a> crate.
The last of these crates contains the <code>hermes</code> binary.</p>
<pre><code class="language-shell">cargo build --release --bin hermes
</code></pre>
<p><a name="telemetry-support"></a></p>
<blockquote>
<p>By default, Hermes bundles a <a href="quick-start/../documentation/telemetry/index.html">telemetry service and server</a>.
To build Hermes without telemetry support, and get a smaller executable,
supply the <code>--no-default-features flag</code> to <code>cargo build</code>:</p>
<pre><code class="language-shell">cargo build --release --no-default-features --bin hermes
</code></pre>
</blockquote>
<p>If the build is successful, the <code>hermes</code> executable will be located in the following location:</p>
<pre><code class="language-shell">./target/release/hermes
</code></pre>
<p><strong>Troubleshooting</strong>:
In case the <code>cargo build</code> command above fails, as a first course of action we
recommend trying to run the same command with the additional <code>locked</code> flag:</p>
<pre><code class="language-shell">cargo build --release --bin hermes --locked
</code></pre>
<h3 id="running-for-the-first-time"><a class="header" href="#running-for-the-first-time">Running for the first time</a></h3>
<p>If you run the <code>hermes</code> without any additional parameters you should see the usage and help information:</p>
<pre><code class="language-shell">./target/release/hermes
</code></pre>
<pre><code>DESCRIPTION:
Informal Systems &lt;hello@informal.systems&gt;
  Hermes is an IBC Relayer written in Rust

USAGE:
    hermes [OPTIONS] [SUBCOMMAND]

OPTIONS:
        --config &lt;CONFIG&gt;    Path to configuration file
        --debug &lt;DEBUG&gt;      Enable debug output for the given section(s), comma separated, can be
                             repeated. [possible values: rpc, profiling, profiling-json]
    -h, --help               Print help information
        --json               Enable JSON output
    -V, --version            Print version information

SUBCOMMANDS:
    clear           Clear objects, such as outstanding packets on a channel
    config          Generate a new Hermes configuration file or validate an existing one
    create          Create objects (client, connection, or channel) on chains
    evidence        Listen to block events and handles evidence
    fee             Interact with the fee middleware
    health-check    Performs a health check of all chains in the config
    help            Print this message or the help of the given subcommand(s)
    keys            Manage keys in the relayer for each chain
    listen          Listen to and display IBC events emitted by a chain
    logs            Update tracing log directives
    misbehaviour    Listen to client update IBC events and handle misbehaviour
    query           Query objects from the chain
    start           Start the relayer in multi-chain mode
    tx              Create and send IBC transactions
    update          Update objects (clients) on chains
    upgrade         Upgrade objects (clients) after chain upgrade
    completions     Generate auto-complete scripts for different shells
</code></pre>
<h3 id="creating-an-alias-for-the-executable"><a class="header" href="#creating-an-alias-for-the-executable">Creating an alias for the executable</a></h3>
<p>It might be easier to create an alias for <code>hermes</code>, so you can just run it by specifying the executable name instead of the whole path. In order to create an alias execute the following command:</p>
<pre><code class="language-shell">alias hermes='cargo run --manifest-path $IBCFOLDER/Cargo.toml --release --bin hermes --'
</code></pre>
<h2 id="shell-auto-completions"><a class="header" href="#shell-auto-completions">Shell auto-completions</a></h2>
<p>The <code>completions</code> sub-command of Hermes can be used to output a completion script
for a choice of widely used command-line shells.
Refer to <code>hermes completions --help</code> for the list. Some shell-specific examples
of setting up auto-completion with this command are provided below; check your
shell configuration to decide on the suitable directory in which to install the script
and any further necessary modifications to the shell's startup files.</p>
<h3 id="bash"><a class="header" href="#bash">Bash</a></h3>
<pre><code class="language-sh">hermes completions --shell bash
 &gt; ~/.local/share/bash-completion/completions/hermes
</code></pre>
<p>On a macOS installation with Homebrew <code>bash-completion</code> formula installed, use</p>
<pre><code class="language-sh">hermes completions --shell bash
 &gt; $(brew --prefix)/etc/bash_completion.d/hermes.bash-completion
</code></pre>
<h3 id="zsh"><a class="header" href="#zsh">Zsh</a></h3>
<pre><code class="language-sh">hermes completions --shell zsh
 &gt; ~/.zfunc/_hermes
</code></pre>
<p>To make the shell load the script on initialization, add the directory to <code>fpath</code>
in your <code>~/.zshrc</code> before <code>compinit</code>:</p>
<pre><code>fpath+=~/.zfunc
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Go to the <a href="quick-start/../tutorials/index.html"><code>Tutorials</code></a> section to learn the basics of Hermes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>This section includes tutorials to learn the basics of relaying and the main commands. You can also refer to the <a href="tutorials/../documentation/commands/index.html">Commands Reference</a> section to learn more about individual commands.</p>
<hr />
<h2 id="sections-1"><a class="header" href="#sections-1">Sections</a></h2>
<ul>
<li><strong><a href="tutorials/./pre-requisites/index.html">Prerequisites for local chains</a></strong>
<ul>
<li>Install <code>Gaia</code> and <code>gm</code> (Gaia Manager) for tutorials using local chains.</li>
</ul>
</li>
<li><strong><a href="tutorials/./local-chains/index.html">Two Local Chains</a></strong>
<ul>
<li>Start two local <a href="https://github.com/cosmos/gaia"><code>Cosmos Gaia</code></a> chains that support the <code>IBC</code> protocol and learn the fundamentals of IBC.</li>
</ul>
</li>
<li><strong><a href="tutorials/./more-chains/index.html">More Local Chains</a></strong>
<ul>
<li>Learn how to relay on an arbitrary topology of more than two chains by using packet filters and to run multiple instances of Hermes.</li>
</ul>
</li>
<li><strong><a href="tutorials/./production/index.html">Relaying in production</a></strong>
<ul>
<li>Learn how to set up, configure and run <code>hermes</code> on IBC-enabled chains in production.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-requisites-for-local-chains"><a class="header" href="#pre-requisites-for-local-chains">Pre-requisites for local chains</a></h1>
<p>In order to follow the tutorials using local chains, please make sure that <a href="https://github.com/cosmos/gaia">Gaia</a> and <a href="tutorials/pre-requisites/./gaiad-manager.html">Gaiad manager</a> are installed on your machine.</p>
<hr />
<h2 id="sections-2"><a class="header" href="#sections-2">Sections</a></h2>
<ul>
<li>
<p><strong><a href="tutorials/pre-requisites/./gaia.html">Gaia</a></strong></p>
<ul>
<li>Install <code>Gaia</code>, the first implementation of the CosmosHub.</li>
</ul>
</li>
<li>
<p><strong><a href="tutorials/pre-requisites/./gaiad-manager.html">Gaiad Manager</a></strong></p>
<ul>
<li>Install Gaiad Manager, a command-line tool (CLI) that helps manage local <code>gaiad</code> networks.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-gaia"><a class="header" href="#install-gaia">Install Gaia</a></h1>
<p>For <code>gm</code> to start the chains, it requires <code>Gaia</code> to be installed.</p>
<blockquote>
<p><strong>NOTE</strong>: This assumes you have <code>Golang</code> programming language installed on
your machine. If not, please ensure you install before proceeding. See
more details in the <a href="tutorials/pre-requisites/../../quick-start/pre-requisites.html#2-golang">Pre-requisites</a> section.</p>
</blockquote>
<p>Follow the instructions below to install <code>Gaia</code>.</p>
<hr />
<h4 id="clone-gaia"><a class="header" href="#clone-gaia">Clone Gaia</a></h4>
<p>Clone the repository from GitHub:</p>
<pre><code class="language-shell">git clone https://github.com/cosmos/gaia.git ~/go/src/github.com/cosmos/gaia
</code></pre>
<h4 id="build-and-install"><a class="header" href="#build-and-install">Build and Install</a></h4>
<p>Run the <code>make</code> command to build and install <code>gaiad</code></p>
<pre><code class="language-shell">cd ~/go/src/github.com/cosmos/gaia
git checkout v12.0.0
make install
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Specific to M1 macOS, there could be some warnings after running <code>make install</code> which can be safely ignored as long as <code>gaiad</code> binaries are built in <code>$HOME/go/bin</code> directory.
<br /><br />Add the path <code>export PATH=$HOME/go/bin:$PATH</code></p>
</blockquote>
<p>If the command is successful, you can run the following command to ensure it was properly installed:</p>
<pre><code class="language-shell">gaiad version --log_level error --long | head -n4
</code></pre>
<p>Output:</p>
<pre><code class="language-shell">name: gaia
server_name: gaiad
version: v12.0.0
</code></pre>
<hr />
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Go to the <a href="tutorials/pre-requisites/./gaiad-manager.html">next section</a> to install <code>gm</code>, a tool to easily start IBC-enabled local chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="install-gaiad-manager"><a class="header" href="#install-gaiad-manager">Install Gaiad Manager</a></h2>
<p>Gaiad manager (<code>gm</code>) is a command-line tool (CLI) that helps manage local <code>gaiad</code> networks.</p>
<p>Follow the instructions below to install and configure <code>gm</code>.</p>
<hr />
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<ul>
<li>Bourne shell (<code>sh</code>)</li>
<li><a href="https://github.com/freshautomations/sconfig/releases"><code>sconfig</code></a> and
<a href="https://github.com/freshautomations/stoml/releases"><code>stoml</code></a> installed in your PATH (put them in <code>/usr/local/bin</code>)</li>
<li><code>sed</code>, <code>tr</code></li>
<li>For shell-completion Bourne Again Shell (<code>bash</code>) for the local user</li>
</ul>
<h3 id="how-to-run"><a class="header" href="#how-to-run">How to run</a></h3>
<ol>
<li>
<p>Install the dependencies.</p>
<p>On macOS:</p>
<pre><code class="language-bash"># You might need sudo permissions and create the `usr/local/bin` directory

curl -Lo /usr/local/bin/sconfig https://github.com/freshautomations/sconfig/releases/download/v0.1.0/sconfig_darwin_amd64
curl -Lo /usr/local/bin/stoml https://github.com/freshautomations/stoml/releases/download/v0.7.0/stoml_darwin_amd64
chmod 755 /usr/local/bin/sconfig
chmod 755 /usr/local/bin/stoml
</code></pre>
<p>On Linux:</p>
<pre><code class="language-bash">curl -Lo /usr/local/bin/sconfig https://github.com/freshautomations/sconfig/releases/download/v0.1.0/sconfig_linux_amd64
curl -Lo /usr/local/bin/stoml https://github.com/freshautomations/stoml/releases/download/v0.7.0/stoml_linux_amd64
chmod 755 /usr/local/bin/sconfig
chmod 755 /usr/local/bin/stoml
</code></pre>
</li>
<li>
<p>Install <code>gm</code></p>
<pre><code class="language-bash">git clone https://github.com/informalsystems/gm
gm/bin/gm install
</code></pre>
<p>Alternatively, you can create the folder <code>$HOME/.gm/bin</code> and copy the files from <code>gm/bin</code> in there.</p>
</li>
<li>
<p>Activate <code>gm</code></p>
</li>
</ol>
<blockquote>
<p><strong>NOTE</strong>: The <code>shell-support</code> script allows bash-completion as well as creating a <code>gm</code> alias, so you don't need to add more entries to your PATH environment variable.
You can optionally enable bash-completion with <code>gm</code> by doing the following:</p>
<ul>
<li>Add <code>source $HOME/.gm/bin/shell-support</code> to a file that executes when a new terminal window comes up (<code>$HOME/.bash_profile</code> or <code>$HOME/.bashrc</code> or <code>$HOME/.zprofile</code>)</li>
<li>You may need to install <code>bash-completion</code> if adding <code>shell-support</code> raises a <code>command not found: complete</code> error message. You can do so by executing <code>brew install bash-completion</code> on macOS, or <code>apt install bash-completion || yum install bash-completion</code> on Linux.</li>
<li>If you don't want to use this, you can always just add <code>$HOME/.gm/bin</code> to
your path.</li>
</ul>
</blockquote>
<ul>
<li>Restart your terminal</li>
</ul>
<h3 id="the-configuration-gmtoml"><a class="header" href="#the-configuration-gmtoml">The configuration: <code>gm.toml</code></a></h3>
<p><strong>Where</strong>: <code>$HOME/.gm/gm.toml</code>.</p>
<p><strong>Description</strong>: This file contains all the high-level node configuration that <code>gm</code> is aware of. Note that all entries under <code>[global]</code> are also valid entries under any <code>[node]</code> header, and can be used to override the global entries for specific nodes/validators.</p>
<p><strong>Entries</strong>: All entries are defined and documented in the <code>gm.toml</code> example configuration file.</p>
<p>Copy and paste below to <code>$HOME/.gm/gm.toml</code> and set Hermes' binary path according to your setup.</p>
<p>The following configuration you need to specify 2 <code>gaiad</code> chains. <code>hermes</code> will know about these chains.</p>
<pre><code class="language-toml">[global]
  add_to_hermes = false
  auto_maintain_config = true
  extra_wallets = 2
  gaiad_binary = "~/go/bin/gaiad"
  hdpath = ""
  home_dir = "$HOME/.gm"
  ports_start_at = 27000
  validator_mnemonic = ""
  wallet_mnemonic = ""

  [global.hermes]
    binary = "PATH-TO-HERMES-BINARY" #change this path according to your setup
    config = "$HOME/.hermes/config.toml"
    log_level = "info"
    telemetry_enabled = true
    telemetry_host = "127.0.0.1"
    telemetry_port = 3001

[ibc-0]
  ports_start_at = 27010

[ibc-1]
  ports_start_at = 27020

[node-0]
  add_to_hermes = true
  network = "ibc-0"
  ports_start_at = 27030

[node-1]
  add_to_hermes = true
  network = "ibc-1"
  ports_start_at = 27040
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> Go to this page for more details about <a href="https://github.com/informalsystems/gm">Gaiad Manager</a></p>
</blockquote>
<hr />
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next steps</a></h2>
<p>Now that <code>Gaiad Manager</code> is installed on your machine, visit the <a href="tutorials/pre-requisites/../local-chains/index.html">first tutorial</a> to learn the basics of Hermes. You will start two local chains and exchange tokens over IBC transfers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-chains"><a class="header" href="#local-chains">Local chains</a></h1>
<p>In this tutorial, you will test Hermes against two chains using Gaiad manager <code>gm</code>. This is the easiest way to get started.</p>
<p>Using <code>gm</code> you will start two <a href="https://github.com/cosmos/gaia"><code>gaia</code></a> chains that support the <code>IBC</code> protocol.</p>
<p>Make sure that you followed the steps in the <a href="tutorials/local-chains/../pre-requisites/index.html">Prerequisites for local chains</a> section before moving to the <a href="tutorials/local-chains/./start-local-chains.html">next section</a>.</p>
<hr />
<h2 id="sections-3"><a class="header" href="#sections-3">Sections</a></h2>
<ul>
<li>
<p><strong><a href="tutorials/local-chains/./start-local-chains.html">Start Local Chains</a></strong></p>
<ul>
<li>Start two local chains with <code>gm</code> and set up Hermes.</li>
</ul>
</li>
<li>
<p><strong><a href="tutorials/local-chains/./add-a-new-relay-path.html">Add a new relay path</a></strong></p>
<ul>
<li>Add a relay path between the two chains you started.</li>
</ul>
</li>
<li>
<p><strong><a href="tutorials/local-chains/./start-relaying.html">Start relaying</a></strong></p>
<ul>
<li>Exchange and relay packets between two local chains.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="start-the-local-chains"><a class="header" href="#start-the-local-chains">Start the local chains</a></h1>
<p>In this chapter, you will learn how to spawn two Gaia chains, and use Hermes to relay packets between them. The topology of the network will look like this:</p>
<pre class="mermaid">flowchart LR
    A((ibc-0))---B((ibc-1))
</pre>
<p>To spawn the chains and configure Hermes accordingly, we will make use of Gaiad Manager <code>gm</code> that we installed in the last section <a href="tutorials/local-chains/../pre-requisites/gaiad-manager.html">Install Gaiad Manager</a>.</p>
<hr />
<h3 id="reset-your-configuration-and-start-the-chains"><a class="header" href="#reset-your-configuration-and-start-the-chains">Reset your configuration and start the chains</a></h3>
<p>Make sure you have the <code>$HOME/.gm/gm.toml</code> that we configured in the previous section <a href="tutorials/local-chains/../pre-requisites/gaiad-manager.html">Install Gaiad Manager</a>. If this is not the first time you are running the script, you can manually stop the two gaia instances executing the following command to kill all <code>gaiad</code> processes:</p>
<pre><code class="language-shell">gm stop
</code></pre>
<p>Then, reset the configuration of every node and every chain with:</p>
<pre><code class="language-shell">rm -r $HOME/.gm/node-*
rm -r $HOME/.gm/ibc-*
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If you have any <code>Docker</code> containers running that might be using the same ports as <code>gaiad</code> (e.g. port 27010-27012), please ensure you stop them first before proceeding to the next step.</p>
</blockquote>
<p>Finally, start the chains with the <code>start</code> command.</p>
<pre><code class="language-bash">gm start
</code></pre>
<p>This configures and starts two <strong><code>gaiad</code></strong> instances, one named <strong><code>ibc-0</code></strong> and the other named <strong><code>ibc-1</code></strong>:</p>
<pre class="mermaid">graph TD
    A[gm] --&gt;|start| C(start chains)
    C --&gt;|gaiad| D[ibc-0]
    C --&gt;|gaiad| F[ibc-1]
</pre>
<p>If the command runs successfully, it should output something similar to:</p>
<pre><code class="language-shell">Creating ibc-0 config...
ibc-0 started, PID: 11244, LOG: $HOME/.gm/ibc-0/log
Creating ibc-1 config...
ibc-1 started, PID: 11796, LOG: $HOME/.gm/ibc-1/log
Creating node-0 config...
node-0 started, PID: 12342, LOG: $HOME/.gm/node-0/log
Creating node-1 config...
node-1 started, PID: 12885, LOG: $HOME/.gm/node-1/log
</code></pre>
<p>Run the following command to check the status of the chains:</p>
<pre><code class="language-bash">gm status
</code></pre>
<p>If the command is successful, you should see a message similar to:</p>
<pre><code>NODE               PID    RPC   APP  GRPC  HOME_DIR
ibc-0            11244  27010 27011 27012  $HOME/.gm/ibc-0
 node-0          12342  27030 27031 27032  $HOME/.gm/node-0
ibc-1            11796  27020 27021 27022  $HOME/.gm/ibc-1
 node-1          12885  27040 27041 27042  $HOME/.gm/node-1
</code></pre>
<h3 id="configuration-file"><a class="header" href="#configuration-file">Configuration file</a></h3>
<p>Gaiad Manager <code>gm</code> takes care of creating the configuration file. Run the command below to create the <code>$HOME/.hermes/config.toml</code> file:</p>
<pre><code class="language-bash">gm hermes config
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: You can visit the <a href="tutorials/local-chains/../../documentation/configuration/index.html"><code>Configuration</code></a> section for more information about the configuration file.</p>
</blockquote>
<p>Based on the <code>gm.toml</code> we created in the previous section <a href="tutorials/local-chains/../pre-requisites/gaiad-manager.html">Install Gaiad Manager</a>, your <code>$HOME/.hermes/config.toml</code> file should look like below :</p>
<p><strong>config.toml</strong></p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = true

[mode.channels]
enabled = true

[mode.packets]
enabled = true
clear_interval = 100
clear_on_start = true
tx_confirmation = true

[telemetry]
enabled = true
host = '127.0.0.1'
port = 3001

[[chains]]
id = 'ibc-0'
type = "CosmosSdk"
rpc_addr = 'http://localhost:27030'
grpc_addr = 'http://localhost:27032'
event_source = { mode = 'push', url = 'ws://localhost:27030/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

# [chains.packet_filter]
# policy = 'allow'
# list = [
#   ['ica*', '*'],
#   ['transfer', 'channel-0'],
# ]

[[chains]]
id = 'ibc-1'
type = "CosmosSdk"
rpc_addr = 'http://localhost:27040'
grpc_addr = 'http://localhost:27042'
event_source = { mode = 'push', url = 'ws://localhost:27040/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

# [chains.packet_filter]
# policy = 'allow'
# list = [
#   ['ica*', '*'],
#   ['transfer', 'channel-0'],
# ]
</code></pre>
<h3 id="adding-private-keys-to-the-chains"><a class="header" href="#adding-private-keys-to-the-chains">Adding private keys to the chains</a></h3>
<p><code>gm</code> will automatically generate private keys that will be used by <code>hermes</code> to sign transactions.</p>
<p>To see the keys generated by <code>gm</code>, run the command below</p>
<pre><code class="language-bash">gm keys
</code></pre>
<p>This will generate an output similar to the one below (albeit all on the same line):</p>
<details><summary style="font-weight:bold">gm keys output</summary>
<pre><code>"$HOME/go/bin/gaiad" keys list --keyring-backend test --keyring-dir "$HOME/.gm/ibc-0"

- name: validator
address: cosmos1a5545h09sdzwgjpraasgkvu0f585lc33k9h4kx
pubkey: cosmospub1addwnpepqw5j24lg0ya34umnrn7akxuks3as2ktggndxg37cnfsx2fl5xkl8ymte6c2
mnemonic: "confirm path season shiver adjust order quarter now empower crystal busy foam pony web chaos bachelor magnet imitate audit wear spike chunk garlic sport"

- name: wallet
address: cosmos14czpvfgzcr06astyylahshcexzwm0j9ne6h5p5
pubkey: cosmospub1addwnpepqdcmngqappsxp6jp53atfx6kt5p7d6vce4un3mfvsa8gtml5n8lj2yh29q9
mnemonic: "brass exhibit artist beef album canvas liar fine water wave bus rose sunny permit strategy eight stove legal sustain vessel offer great book loan"

- name: wallet1
address: cosmos1qs5nmmf7jall4sm38fjssxfw5ay87mfp22p3xm
pubkey: cosmospub1addwnpepqtxfgjxg8xrc9xrzqyfs3ud6svmu7wrt608s80d0t0g93rylu4kd7kpckj6
mnemonic: "puzzle pole beyond announce clip else cause airport index pencil intact camp leisure pole nasty put meat cover garage ripple chief unfair destroy spatial"

- name: wallet2
address: cosmos1n7qyhjkfp8szpy7ury7vlejd5wcfc2ysdd9xlx
pubkey: cosmospub1addwnpepq2nuh2a9x9wd6ad78dcft3e8tuds5xs4ypeterl0zenw9ejt0tdvk38yd3z
mnemonic: "february slab crane panther harbor judge artefact ghost clay torch stay cave enrich narrow sausage expand tomato margin wool repeat squeeze couch fork unhappy"

"$HOME/go/bin/gaiad" keys list --keyring-backend test --keyring-dir "$HOME/.gm/ibc-1"

- name: validator
address: cosmos14eg9y3kjlrepk8lmdavw8u5l472sl8e6xv99yk
pubkey: cosmospub1addwnpepq0q4f0aaaq2wycg7y3x8j8gfacazdf3xlxujkjguy2k3gq654jwuyn58hhq
mnemonic: "clarify concert lens mobile hover lucky bulk home elite fix school jungle draw soul excess siren advice accuse shallow copper model absorb salon mystery"

- name: wallet
address: cosmos120jm7xkv49erxty6ec9trs85j8yfgjwwdlsrtz
pubkey: cosmospub1addwnpepqgs0llcm64e7yrpx7hs9fmzqefnwxzfxnujf3qgysdpv8w5aalu2z2e86gs
mnemonic: "shine again similar wheel also frozen equal win ask grit artist quality subject twenty pet scrub olympic ladder puppy balcony blood exotic buddy gather"

- name: wallet1
address: cosmos18ccme8td0zdktcy7dafhurdhx7x8xxx0s445y2
pubkey: cosmospub1addwnpepq045d9qjrkvfxdx39849qdcrny0zr8z2elx6z7kjkgezrvw2enepx98pyxf
mnemonic: "join skill day disease canal alpha sweet sing icon donor relief little wheat borrow silver allow child silent teach then flower deliver arena library"

- name: wallet2
address: cosmos1x45ucdaa3fegemh3x2xp0qtnxl2gv533e2fg6g
pubkey: cosmospub1addwnpepq0ryrcm08l8x5wskhd5dczrduj535fxs9w7wky04ux97amljcffe6ewxymg
mnemonic: "wish burden unfair subway club pulp wood helmet whip decline between maid defense sniff cash guard cargo travel donor nasty saddle tumble service fringe"

"$HOME/go/bin/gaiad" keys list --keyring-backend test --keyring-dir "$HOME/.gm/node-0"
[]

"$HOME/go/bin/gaiad" keys list --keyring-backend test --keyring-dir "$HOME/.gm/node-1"
[]
</code></pre>
</details>
<p>Next, we will need to associate a private key with chains <code>ibc-0</code> and <code>ibc-1</code> which <code>hermes</code> will use to sign transactions.</p>
<pre><code class="language-bash">gm hermes keys
</code></pre>
<p>If successful, the command should show an output similar to:</p>
<pre><code>SUCCESS Added key 'wallet' (cosmos1qsl5sq48r7xdfwq085x9pnlfu9ul5seufu3n03) on chain ibc-0
SUCCESS Added key 'wallet2' (cosmos1haaphqucg2u9g8gwgv6z8jzegvca85r4d7yqh9) on chain ibc-0
SUCCESS Added key 'wallet1' (cosmos1cgjf7m9txsxf2pdekxk60ll6xusx0heznqsnxn) on chain ibc-0
SUCCESS Added key 'wallet' (cosmos1zp3t2rp7tjr23wchp36lmw7vhk77gtvvc7lc5s) on chain ibc-1
SUCCESS Added key 'wallet2' (cosmos1644x9c8pyfwcmg43ch2u3vr6hl4rkmkz2weq39) on chain ibc-1
SUCCESS Added key 'wallet1' (cosmos1dsrj2uqjvtssenkwperuvfkgkg2xvmydvpzswy) on chain ibc-1
</code></pre>
<blockquote>
<p><strong>TROUBLESHOOTING</strong>:</p>
<ul>
<li>If the command does not out output anything, make sure the path to Hermes' binary is set in <code>$HOME/.gm/gm.toml</code>.</li>
</ul>
</blockquote>
<h3 id="the-homegm-directory"><a class="header" href="#the-homegm-directory">The <code>$HOME/.gm</code> directory</a></h3>
<p>This directory is created when you install <code>gm</code> and the binaries are stored here but when we start the chains, all the related files and folders are stored here as well.</p>
<p>The <code>$HOME/.gm</code> directory has a tree structure similar to the one below:</p>
<pre><code class="language-shell">.gm
├── bin
│   ├── gm
│   ├── lib-gm
│   └── shell-support
├── gm.toml
├── ibc-0
│   ├── config
│   ├── data
│   ├── init.json
│   ├── keyring-test
│   ├── log
│   ├── pid
│   ├── validator_seed.json
│   ├── wallet1_seed.json
│   ├── wallet2_seed.json
│   └── wallet_seed.json
├── ibc-1
│   ├── config
│   ├── data
│   ├── init.json
│   ├── keyring-test
│   ├── log
│   ├── pid
│   ├── validator_seed.json
│   ├── wallet1_seed.json
│   ├── wallet2_seed.json
│   └── wallet_seed.json
├── node-0
│   ├── config
│   ├── data
│   ├── init.json
│   ├── keyring-test
│   ├── log
│   └── pid
└── node-1
    ├── config
    ├── data
    ├── init.json
    ├── keyring-test
    ├── log
    └── pid
</code></pre>
<blockquote>
<p><strong>Tip</strong>: You can use the command <code>tree $HOME/.gm/ -L 2</code> to view the folder structure above</p>
</blockquote>
<h3 id="the-homehermes-directory"><a class="header" href="#the-homehermes-directory">The <code>$HOME/.hermes</code> directory</a></h3>
<p>By the default <code>hermes</code> expects the configuration file to be in the <strong><code>$HOME/.hermes</code></strong> folder.</p>
<p>It also stores the private keys for each chain in this folder as outlined in the <a href="tutorials/local-chains/../../documentation/commands/keys/index.html">Keys</a> section.</p>
<p>After executing <code>gm start</code>, this is how the folder should look like:</p>
<pre><code class="language-shell">$HOME/.hermes/
├── config.toml
└── keys
    ├── ibc-0
    │   └── keyring-test
    │       └── wallet.json
    |       └── wallet1.json
    |       └── wallet2.json
    └── ibc-1
        └── keyring-test
            └── wallet.json
            └── wallet1.json
            └── wallet2.json
</code></pre>
<hr />
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p><a href="tutorials/local-chains/./add-a-new-relay-path.html">The next section</a> describes how clients, connections and channels are created and how their identifiers are assigned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-a-new-relay-path"><a class="header" href="#add-a-new-relay-path">Add a new relay path</a></h1>
<p>In order to connect two IBC-enabled chains, both chains need an on-chain client that keeps track of the other chain. These two clients can be connected by one or multiple connections. Then, channels need to be created, over a connection, to specify the destination module.</p>
<blockquote>
<p><strong>WARNING</strong>: In production, do not create clients, connections or channels between two chains before checking that a client/connection/channel does not already fulfill the same function.</p>
</blockquote>
<hr />
<h2 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h2>
<p>A chain allocates identifiers when it creates clients, connections and channels. These identifiers can subsequently be used to refer to existing clients, connections, and channels.</p>
<blockquote>
<p>NOTE: If you want to ensure you get the same identifiers while following the tutorials, run each of the commands in this page only <strong>once</strong> or reset the chains as instructed in section <a href="tutorials/local-chains/./start-local-chains.html#reset-your-configuration-and-start-the-chains">Start local chains</a>.</p>
</blockquote>
<p>Chains allocate identifiers using a chain-specific allocation scheme. Currently, the <em>cosmos-sdk</em> implementation uses the following identifiers:</p>
<ul>
<li><code>07-tendermint-&lt;n&gt;</code> for tendermint clients.</li>
<li><code>connection-&lt;n&gt;</code> for connections.</li>
<li><code>channel-&lt;n&gt;</code> for channels.</li>
</ul>
<p>It is possible for two chains to use the same identifier to designate two different objects. For example, two different channels, one on the Hub and one on Osmosis, can both be designated with the <code>channel-0</code> identifier.</p>
<h2 id="create-the-relay-path"><a class="header" href="#create-the-relay-path">Create the relay path</a></h2>
<p>A relay path refers to a specific channel used to interconnect two chains and over which packets are being sent.</p>
<p>Hermes can be started to listen for packet events on the two ends of multiple paths and relay packets over these paths.
This can be done over a new path or over existing paths.</p>
<blockquote>
<p><strong>NOTE</strong>: The following steps decompose every step from the creation of the clients to the channel handshake for educational purposes.
More realistically, you'd use the command <code>hermes create channel --a-chain ibc-0 --b-chain ibc-1 --a-port transfer --b-port transfer --new-client-connection </code> in order to create a new client on each chain, establish a connection, and open a channel, all with a single command.</p>
</blockquote>
<p>You will need to first create a client on both chains and then establish a connection between them. It is possible to have multiple connections between clients, which can be useful in order to support multiple versions of IBC. Finally, you need to create channels over a connection to identify the source and destination modules. You can learn more in the <a href="https://tutorials.cosmos.network/academy/3-ibc/1-what-is-ibc.html">cosmos academy tutorial</a>.</p>
<h3 id="create-clients"><a class="header" href="#create-clients">Create clients</a></h3>
<p>First, create a client on <code>ibc-1</code> tracking the state of <code>ibc-0</code>. It will be assigned <code>07-tendermint-0</code> as its identifier:</p>
<pre><code class="language-shell">hermes create client --host-chain ibc-1 --reference-chain ibc-0

</code></pre>
<p>If the command is successful, the output should be similar to:</p>
<pre><code class="language-json">SUCCESS CreateClient(
    CreateClient(
        Attributes {
            client_id: ClientId(
                "07-tendermint-0",
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 0,
                height: 2,
            },
        },
    ),
)
</code></pre>
<p>Now, create a client on <code>ibc-0</code> tracking <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes create client --host-chain ibc-0 --reference-chain ibc-1

</code></pre>
<p>If the command is successful, the output should be similar to:</p>
<pre><code class="language-json">SUCCESS CreateClient(
    CreateClient(
        Attributes {
            client_id: ClientId(
                "07-tendermint-0",
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 1,
                height: 3,
            },
        },
    ),
)
</code></pre>
<p>As you can see, the identifier is also <code>07-tendermint-0</code> because the client-id is <strong>local to a chain</strong>.</p>
<h3 id="2-create-connections"><a class="header" href="#2-create-connections">2. Create connections</a></h3>
<p>After creating clients on both chains, you have to establish a connection between them. Both chains will assign <code>connection-0</code> as the identifier of their first connection:</p>
<pre><code class="language-shell">hermes create connection --a-chain ibc-0 --a-client 07-tendermint-0 --b-client 07-tendermint-0

</code></pre>
<blockquote>
<p><strong>NOTE</strong>: The command does not take <code>--b-chain</code> as argument as <code>--a-client</code> can only track one chain (<code>ibc-1</code>).</p>
</blockquote>
<p>If the command runs successfully, it should output something similar to:</p>
<details><summary style="font-weight:bold">Create connection output</summary>
<pre><code>2022-08-29T11:16:39.833467Z  INFO ThreadId(01) using default configuration from '$HOME/.hermes/config.toml'
2022-08-29T11:16:39.838071Z  INFO ThreadId(01) Creating a new connection with pre-existing clients 07-tendermint-0 and 07-tendermint-0
2022-08-29T11:16:39.843103Z  INFO ThreadId(15) wait_for_block_commits: waiting for commit of tx hashes(s) F87AE29F8BA86EA9F6533C0CE8A34101C90948B824446E0B4889C4F953A9E094 id=ibc-0
2022-08-29T11:16:41.047867Z  INFO ThreadId(01) 🥂 ibc-0 =&gt; IbcEventWithHeight {
    event: OpenInitConnection(
        OpenInit(
            Attributes {
                connection_id: Some(
                    ConnectionId(
                        "connection-0",
                    ),
                ),
                client_id: ClientId(
                    "07-tendermint-0",
                ),
                counterparty_connection_id: None,
                counterparty_client_id: ClientId(
                    "07-tendermint-0",
                ),
            },
        ),
    ),
    height: Height {
        revision: 0,
        height: 29,
    },
}

2022-08-29T11:16:44.061620Z  INFO ThreadId(15) wait_for_block_commits: waiting for commit of tx hashes(s) AEEAE5846991C6748248ECD81A5B8D83E7E0388322202900788C72518649EF7B id=ibc-0
2022-08-29T11:16:51.249114Z  INFO ThreadId(41) wait_for_block_commits: waiting for commit of tx hashes(s) BFED59B2EBE5D75A19C1CBB1FB931FF6FC81EF02F872CEB3D37AA40DDA5101B4 id=ibc-1
2022-08-29T11:16:52.452619Z  INFO ThreadId(01) 🥂 ibc-1 =&gt; IbcEventWithHeight {
    event: OpenTryConnection(
        OpenTry(
            Attributes {
                connection_id: Some(
                    ConnectionId(
                        "connection-0",
                    ),
                ),
                client_id: ClientId(
                    "07-tendermint-0",
                ),
                counterparty_connection_id: Some(
                    ConnectionId(
                        "connection-0",
                    ),
                ),
                counterparty_client_id: ClientId(
                    "07-tendermint-0",
                ),
            },
        ),
    ),
    height: Height {
        revision: 1,
        height: 31,
    },
}

2022-08-29T11:16:55.459367Z  WARN ThreadId(01) [ibc-0 -&gt; ibc-1:07-tendermint-0] resolving trusted height from the full list of consensus state heights for target height 0-31; this may take a while
2022-08-29T11:16:55.469498Z  INFO ThreadId(41) wait_for_block_commits: waiting for commit of tx hashes(s) D232FCF03549B692604A06AFC1D82494FB1D466E61880E9A8653FEFC2F41BA69 id=ibc-1
2022-08-29T11:17:02.248045Z  INFO ThreadId(15) wait_for_block_commits: waiting for commit of tx hashes(s) 0ABC352714048C0873537CCEBE31393E1CB09F810B5AAE495833436A8F9447C0 id=ibc-0
2022-08-29T11:17:06.159408Z  INFO ThreadId(01) 🥂 ibc-0 =&gt; IbcEventWithHeight {
    event: OpenAckConnection(
        OpenAck(
            Attributes {
                connection_id: Some(
                    ConnectionId(
                        "connection-0",
                    ),
                ),
                client_id: ClientId(
                    "07-tendermint-0",
                ),
                counterparty_connection_id: Some(
                    ConnectionId(
                        "connection-0",
                    ),
                ),
                counterparty_client_id: ClientId(
                    "07-tendermint-0",
                ),
            },
        ),
    ),
    height: Height {
        revision: 0,
        height: 34,
    },
}

2022-08-29T11:17:11.202362Z  INFO ThreadId(41) wait_for_block_commits: waiting for commit of tx hashes(s) F5A344056C7F8775620581756985C2C5DB43F396A18956C017E56EFB4A8FF616 id=ibc-1
2022-08-29T11:17:12.407373Z  INFO ThreadId(01) 🥂 ibc-1 =&gt; IbcEventWithHeight {
    event: OpenConfirmConnection(
        OpenConfirm(
            Attributes {
                connection_id: Some(
                    ConnectionId(
                        "connection-0",
                    ),
                ),
                client_id: ClientId(
                    "07-tendermint-0",
                ),
                counterparty_connection_id: Some(
                    ConnectionId(
                        "connection-0",
                    ),
                ),
                counterparty_client_id: ClientId(
                    "07-tendermint-0",
                ),
            },
        ),
    ),
    height: Height {
        revision: 1,
        height: 35,
    },
}

2022-08-29T11:17:15.409868Z  INFO ThreadId(01) connection handshake already finished for Connection {
    delay_period: 0ns,
    a_side: ConnectionSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: Some(
            ConnectionId(
                "connection-0",
            ),
        ),
    },
    b_side: ConnectionSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: Some(
            ConnectionId(
                "connection-0",
            ),
        ),
    },
}

SUCCESS Connection {
    delay_period: 0ns,
    a_side: ConnectionSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: Some(
            ConnectionId(
                "connection-0",
            ),
        ),
    },
    b_side: ConnectionSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: Some(
            ConnectionId(
                "connection-0",
            ),
        ),
    },
}
</code></pre>
</details>
<h3 id="3-channel-identifiers"><a class="header" href="#3-channel-identifiers">3. Channel identifiers</a></h3>
<p>Finally, after the connection has been established, you can now open a new channel on top of it. Both chains will assign <code>channel-0</code> as the identifier of their first channel:</p>
<pre><code class="language-shell">hermes create channel --a-chain ibc-0 --a-connection connection-0 --a-port transfer --b-port transfer

</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Again, you do not need to specify the counterparty chain as a connection can only be established with a single counterparty. The <code>port</code> specifies the protocol which will be used on this channel.</p>
</blockquote>
<p>If the command runs successfully, it should output something similar to:</p>
<details><summary style="font-weight:bold">Create channel output</summary>
<pre><code>2022-08-29T11:26:28.027659Z  INFO ThreadId(01) using default configuration from '$HOME/.hermes/config.toml'
2022-08-29T11:26:28.040558Z  INFO ThreadId(15) wait_for_block_commits: waiting for commit of tx hashes(s) A7B19D0BB98DD6724B7E41A2CAD8381989D38C8D9E8C141D111DBF9DB5C20DC1 id=ibc-0
2022-08-29T11:26:33.455062Z  INFO ThreadId(01) 🎊  ibc-0 =&gt; IbcEventWithHeight {
    event: OpenInitChannel(
        OpenInit {
            port_id: PortId(
                "transfer",
            ),
            channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
            connection_id: ConnectionId(
                "connection-0",
            ),
            counterparty_port_id: PortId(
                "transfer",
            ),
            counterparty_channel_id: None,
        },
    ),
    height: Height {
        revision: 0,
        height: 147,
    },
}

2022-08-29T11:26:38.199410Z  INFO ThreadId(41) wait_for_block_commits: waiting for commit of tx hashes(s) 31CBCFAA6806315A5A6D96C71AEBFDFD71757F823914037B51893F123332282D id=ibc-1
2022-08-29T11:26:39.704788Z  INFO ThreadId(01) 🎊  ibc-1 =&gt; IbcEventWithHeight {
    event: OpenTryChannel(
        OpenTry {
            port_id: PortId(
                "transfer",
            ),
            channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
            connection_id: ConnectionId(
                "connection-0",
            ),
            counterparty_port_id: PortId(
                "transfer",
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
        },
    ),
    height: Height {
        revision: 1,
        height: 148,
    },
}

2022-08-29T11:26:44.242127Z  INFO ThreadId(15) wait_for_block_commits: waiting for commit of tx hashes(s) 0B6EAF8ABCC7E807EDBD65E73EEE32CEE736BE787D2791C49D1436F2BA810F37 id=ibc-0
2022-08-29T11:26:48.455749Z  INFO ThreadId(01) 🎊  ibc-0 =&gt; IbcEventWithHeight {
    event: OpenAckChannel(
        OpenAck {
            port_id: PortId(
                "transfer",
            ),
            channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
            connection_id: ConnectionId(
                "connection-0",
            ),
            counterparty_port_id: PortId(
                "transfer",
            ),
        },
    ),
    height: Height {
        revision: 0,
        height: 150,
    },
}

2022-08-29T11:26:53.297494Z  INFO ThreadId(41) wait_for_block_commits: waiting for commit of tx hashes(s) 005B0105B4E1541F3ABF56CF5AB340EDA4DE0A81939CF379F1FEA272160C47EE id=ibc-1
2022-08-29T11:26:54.501966Z  INFO ThreadId(01) 🎊  ibc-1 =&gt; IbcEventWithHeight {
    event: OpenConfirmChannel(
        OpenConfirm {
            port_id: PortId(
                "transfer",
            ),
            channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
            connection_id: ConnectionId(
                "connection-0",
            ),
            counterparty_port_id: PortId(
                "transfer",
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
        },
    ),
    height: Height {
        revision: 1,
        height: 151,
    },
}

2022-08-29T11:26:57.503582Z  INFO ThreadId(01) channel handshake already finished for Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
        version: None,
    },
    b_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
        version: None,
    },
    connection_delay: 0ns,
}

SUCCESS Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
        version: None,
    },
    b_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
        version: None,
    },
    connection_delay: 0ns,
}
</code></pre>
</details>
<h2 id="visualize-the-current-network"><a class="header" href="#visualize-the-current-network">Visualize the current network</a></h2>
<p>You can visualize the topology of the current network with:</p>
<pre><code class="language-shell">hermes query channels --show-counterparty --chain ibc-0

</code></pre>
<p>If all the commands were successful, this command should output :</p>
<pre><code>ibc-0: transfer/channel-0 --- ibc-1: transfer/channel-0
</code></pre>
<p>The chains <strong>ibc-0</strong> and <strong>ibc-1</strong> are now set up and configured as so:</p>
<p><strong>Relay path</strong>:</p>
<pre class="mermaid">flowchart LR
    A((ibc-0))---B(transfer&lt;br&gt;channel-0)---C(transfer&lt;br&gt;channel-0)---D((ibc-1))
</pre>
<p>Before going over the next sections, please ensure the commands above are executed.</p>
<hr />
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<p>The <a href="tutorials/local-chains/./start-relaying.html">following section</a> describes how to relay packets over the relay path you just created.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="start-relaying"><a class="header" href="#start-relaying">Start relaying</a></h1>
<p>In the <a href="tutorials/local-chains/./add-a-new-relay-path.html">previous section</a>, you created clients, established a connection between them, and opened a channel on top of it. Now you can start relaying on this path.</p>
<p><strong>Relay path</strong>:</p>
<pre class="mermaid">flowchart LR
    A((ibc-0))---B(transfer&lt;br&gt;channel-0)---C(transfer&lt;br&gt;channel-0)---D((ibc-1))
</pre>
<hr />
<h2 id="query-balances"><a class="header" href="#query-balances">Query balances</a></h2>
<p>Use the following commands to query balances on your local chains:</p>
<ul>
<li>
<p>Balances on ibc-0:</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:27030 query bank balances $(gaiad --home ~/.gm/ibc-0 keys --keyring-backend="test" show wallet -a)
</code></pre>
</li>
<li>
<p>Balances on ibc-1:</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:27040 query bank balances $(gaiad --home ~/.gm/ibc-1 keys --keyring-backend="test" show wallet -a)
</code></pre>
</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> the RPC addresses used in the two commands above are configured in <code>~/.hermes/config.toml</code> file. It can also be found with <code>gm status</code></p>
</blockquote>
<p>At this point in the tutorial, the two commands should output something similar to:</p>
<pre><code>balances:
- amount: "100000000"
  denom: samoleans
- amount: "99994088"
  denom: stake
pagination:
  next_key: null
  total: "0"
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Some <code>stake</code> tokens were used during the connection and channel handshakes.</p>
</blockquote>
<h2 id="exchange-packets"><a class="header" href="#exchange-packets">Exchange packets</a></h2>
<p>Now, let's exchange <code>samoleans</code> between two chains.</p>
<ul>
<li>
<p>Open a new terminal and start Hermes using the <code>start</code> command :</p>
<pre><code class="language-shell">hermes start

</code></pre>
<p>Hermes will first relay the pending packets that have not been relayed and then start passively relaying by listening for and acting on packet events.</p>
</li>
<li>
<p>In a separate terminal, use the <code>ft-transfer</code> command to send <code>100000 samoleans</code> from ibc-0 to ibc-1 over channel-0:</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 1000 --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-0 --amount 100000

</code></pre>
</li>
<li>
<p>Wait a few seconds, then query balances on <code>ibc-1</code> and <code>ibc-0</code>. You should observe something similar to:</p>
<ul>
<li>Balances at ibc-0:
<pre><code>balances:
- amount: "99900000"
denom: samoleans
- amount: "99992054"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
<li>Balances at ibc-1:
<pre><code>balances:
- amount: "100000"
denom: ibc/C1840BD16FCFA8F421DAA0DAAB08B9C323FC7685D0D7951DC37B3F9ECB08A199
- amount: "100000000"
denom: samoleans
- amount: "99989196"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
</ul>
<p>The samoleans were transferred to ibc-1 and are visible under the denomination <code>ibc/C1840...</code>.
The exact denomination you see might be different, make sure to use the denomination assigned in your case in the following.</p>
</li>
<li>
<p>Transfer back these tokens to ibc-0:</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 10000 --denom ibc/C1840BD16FCFA8F421DAA0DAAB08B9C323FC7685D0D7951DC37B3F9ECB08A199 --dst-chain ibc-0 --src-chain ibc-1 --src-port transfer --src-channel channel-0 --amount 100000

</code></pre>
</li>
<li>
<p>Wait a few seconds then query balances on <code>ibc-1</code> and <code>ibc-0</code> again. You should observe something similar to:</p>
<ul>
<li>Balances on ibc-0:
<pre><code>balances:
- amount: "100000000"
denom: samoleans
- amount: "99987927"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
<li>Balances on ibc-1:
<pre><code>balances:
- amount: "100000000"
denom: samoleans
- amount: "99983879"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
</ul>
</li>
<li>
<p>Open your browser and open <code>http://localhost:3001/metrics</code>. At this point, you should observe that the <code>wallet_balance</code> metric corresponds to what you observed in the previous step. All the metrics can be useful and are described in the <a href="tutorials/local-chains/../../documentation/telemetry/index.html">Telemetry</a> section. We will describe a way to use them in the tutorial <a href="tutorials/local-chains/../production/index.html">Relaying in production</a>.</p>
</li>
</ul>
<h2 id="stop-relaying-and-stop-the-chains"><a class="header" href="#stop-relaying-and-stop-the-chains">Stop relaying and stop the chains</a></h2>
<ul>
<li>
<p>Stop Hermes by pressing <code>Ctrl+C</code> on the terminal running <code>hermes start </code>.</p>
</li>
<li>
<p>Stop the chains with <code>gm stop</code>.</p>
</li>
</ul>
<hr />
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next steps</a></h2>
<p>In this tutorial, you learned the basics of relaying by:</p>
<ul>
<li>Creating clients on two chains.</li>
<li>Establishing a connection between them.</li>
<li>Opening a channel.</li>
<li>Visualizing your network.</li>
<li>Exchanging packets.</li>
</ul>
<p>In the <a href="tutorials/local-chains/../more-chains/index.html">next tutorial</a>, you will learn how to relay between multiple chains with multiple instances.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-more-local-chains"><a class="header" href="#even-more-local-chains">Even more local chains</a></h1>
<p>In this tutorial, you will test Hermes against four chains using Gaiad manager <code>gm</code> connected in an arbitrary topology of IBC channels.</p>
<p>Using <code>gm</code> you will start four <a href="https://github.com/cosmos/gaia"><code>gaia</code></a> chains that support the <code>IBC</code> protocol.</p>
<p>Make sure that you followed the steps in the <a href="tutorials/more-chains/../pre-requisites/index.html">Prerequisites for local chains</a> section before moving to the <a href="tutorials/more-chains/./start-local-chains.html">next section</a>.</p>
<hr />
<h2 id="sections-4"><a class="header" href="#sections-4">Sections</a></h2>
<ul>
<li>
<p><strong><a href="tutorials/more-chains/./start-local-chains.html">Start Local Chains</a></strong></p>
<ul>
<li>Start four local chains with <code>gm</code> and set up Hermes.</li>
</ul>
</li>
<li>
<p><strong><a href="tutorials/more-chains/./build-the-topology.html">Build the topology</a></strong></p>
<ul>
<li>Add a relay path between every chain and relay on an arbitrary topology with packet filters.</li>
</ul>
</li>
<li>
<p><strong><a href="tutorials/more-chains/./start-relaying.html">Start relaying</a></strong></p>
<ul>
<li>Exchange and relay packets between these chains.</li>
</ul>
</li>
<li>
<p><strong><a href="tutorials/more-chains/./concurrent-instances.html">Add new instances of Hermes</a></strong></p>
<ul>
<li>Add new instances of Hermes to start relaying on the paths filtered out by the first instance.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="start-the-local-chains-1"><a class="header" href="#start-the-local-chains-1">Start the local chains</a></h1>
<p>In this chapter, you will learn how to spawn four Gaia chains, connect them in an arbitrary topology and use Hermes to transfer tokens between them.</p>
<pre class="mermaid">flowchart LR
    ibc0((ibc-0))
    ibc1((ibc-1))
    ibc2((ibc-2))
    ibc3((ibc-3))

    ibc0---ibc1
    ibc1---ibc2
    ibc2---ibc3
    ibc0---ibc3
    
</pre>
<p>As for the <a href="tutorials/more-chains/../local-chains/index.html">Local chains tutorial</a>, we will make use of Gaiad Manager <code>gm</code> that we installed in <a href="tutorials/more-chains/../pre-requisites/gaiad-manager.html">Install Gaiad Manager</a>.</p>
<hr />
<h3 id="reset-your-configuration"><a class="header" href="#reset-your-configuration">Reset your configuration</a></h3>
<p>First, make sure that no chain is currently running by killing all <code>gaiad</code> processes.</p>
<pre><code class="language-shell">gm stop
</code></pre>
<p>Then, make sure that your folder <code>$HOME/.gm</code> does not contain any <code>ibc-*</code> or <code>node-*</code> file. You can remove them with</p>
<pre><code class="language-shell">rm -r $HOME/.gm/node-*
rm -r $HOME/.gm/ibc-*
</code></pre>
<p>Copy and paste the configuration below to <code>$HOME/.gm/gm.toml</code> and set Hermes' binary path according to your setup. The following contains the configuration of 4 IBC-enabled chains.</p>
<p><strong>gm.toml</strong></p>
<pre><code class="language-toml">[global]
  add_to_hermes = false
  auto_maintain_config = true
  extra_wallets = 2
  gaiad_binary = "~/go/bin/gaiad"
  hdpath = ""
  home_dir = "~/.gm"
  ports_start_at = 27000
  validator_mnemonic = ""
  wallet_mnemonic = ""

  [global.hermes]
    binary = "$HOME/hermes/target/release/hermes" # change this path according to your setup
    config = "~/.hermes/config.toml"
    log_level = "info"
    telemetry_enabled = true
    telemetry_host = "127.0.0.1"
    telemetry_port = 3001

[ibc-0]
  ports_start_at = 27010

[ibc-1]
  ports_start_at = 27020

[ibc-2]
  ports_start_at = 27030

[ibc-3]
  ports_start_at = 27040

[node-0]
  add_to_hermes = true
  network = "ibc-0"
  ports_start_at = 27050

[node-1]
  add_to_hermes = true
  network = "ibc-1"
  ports_start_at = 27060

[node-2]
  add_to_hermes = true
  network = "ibc-2"
  ports_start_at = 27070

[node-3]
  add_to_hermes = true
  network = "ibc-3"
  ports_start_at = 27080
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If you have any <code>Docker</code> containers running that might be using the same ports as <code>gaiad</code> (e.g. port 27010-27012), please ensure you stop them first before proceeding to the next step.</p>
</blockquote>
<p>Finally, start the chains with the <code>start</code> command.</p>
<pre><code class="language-bash">gm start
</code></pre>
<p>This configures and starts four <strong><code>gaiad</code></strong> instances.</p>
<pre class="mermaid">graph TD
    A[gm] --&gt;|start| C(start chains)
    C --&gt;|gaiad| D[ibc-0]
    C --&gt;|gaiad| E[ibc-1]
    C --&gt;|gaiad| F[ibc-2]
    C --&gt;|gaiad| G[ibc-3]
    
</pre>
<p>If the command runs successfully, it should output something similar to:</p>
<pre><code class="language-shell">Creating ibc-0 config...
ibc-0 started, PID: 21330, LOG: $HOME/.gm/ibc-0/log
Creating ibc-1 config...
ibc-1 started, PID: 21888, LOG: $HOME/.gm/ibc-1/log
Creating ibc-2 config...
ibc-2 started, PID: 22443, LOG: $HOME/.gm/ibc-2/log
Creating ibc-3 config...
ibc-3 started, PID: 22999, LOG: $HOME/.gm/ibc-3/log
Creating node-0 config...
node-0 started, PID: 23547, LOG: $HOME/.gm/node-0/log
Creating node-1 config...
node-1 started, PID: 24101, LOG: $HOME/.gm/node-1/log
Creating node-2 config...
node-2 started, PID: 24649, LOG: $HOME/.gm/node-2/log
Creating node-3 config...
node-3 started, PID: 25194, LOG: $HOME/.gm/node-3/log
</code></pre>
<p>Run the following command to check the status of the chains:</p>
<pre><code class="language-bash">gm status
</code></pre>
<p>If the command is successful, you should see a message similar to:</p>
<pre><code>NODE               PID    RPC   APP  GRPC  HOME_DIR
ibc-0            21330  27010 27011 27012  $HOME/.gm/ibc-0
 node-0          23547  27050 27051 27052  $HOME/.gm/node-0
ibc-1            21888  27020 27021 27022  $HOME/.gm/ibc-1
 node-1          24101  27060 27061 27062  $HOME/.gm/node-1
ibc-2            22443  27030 27031 27032  $HOME/.gm/ibc-2
 node-2          24649  27070 27071 27072  $HOME/.gm/node-2
ibc-3            22999  27040 27041 27042  $HOME/.gm/ibc-3
 node-3          25194  27080 27081 27082  $HOME/.gm/node-3
</code></pre>
<h3 id="hermes-configuration-file"><a class="header" href="#hermes-configuration-file">Hermes' configuration file</a></h3>
<p>Gaiad Manager <code>gm</code> takes care of creating the configuration file. Run the command below to create the <code>$HOME/.hermes/config.toml</code> file:</p>
<pre><code class="language-bash">gm hermes config
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: You can visit the <a href="tutorials/more-chains/../../documentation/configuration/index.html"><code>Configuration</code></a> section for more information about the configuration file.</p>
</blockquote>
<p>Based on the <code>gm.toml</code> above, your <code>$HOME/.hermes/config.toml</code> file should look like:</p>
<p><strong>config.toml</strong></p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = true

[mode.channels]
enabled = true

[mode.packets]
enabled = true
clear_interval = 100
clear_on_start = true
tx_confirmation = true

[telemetry]
enabled = true
host = '127.0.0.1'
port = 3001

[[chains]]
id = 'ibc-0'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27050'
grpc_addr = 'http://localhost:27052'
event_source = { mode = 'push', url = 'ws://localhost:27050/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

[[chains]]
id = 'ibc-1'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27060'
grpc_addr = 'http://localhost:27062'
event_source = { mode = 'push', url = 'ws://localhost:27060/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

[[chains]]
id = 'ibc-2'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27070'
grpc_addr = 'http://localhost:27072'
event_source = { mode = 'push', url = 'ws://localhost:27070/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

[[chains]]
id = 'ibc-3'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27080'
grpc_addr = 'http://localhost:27082'
event_source = { mode = 'push', url = 'ws://localhost:27080/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }
</code></pre>
<h3 id="adding-private-keys-to-the-chains-1"><a class="header" href="#adding-private-keys-to-the-chains-1">Adding private keys to the chains</a></h3>
<p>Next, we will need to associate a private key to every chain which <code>hermes</code> will use to sign transactions. <code>gm</code> will automatically generate and associate them with:</p>
<pre><code class="language-bash">gm hermes keys
</code></pre>
<p>If successful, the command should show an output similar to:</p>
<pre><code>SUCCESS Added key 'wallet' (cosmos1qsl5sq48r7xdfwq085x9pnlfu9ul5seufu3n03) on chain ibc-0
SUCCESS Added key 'wallet2' (cosmos1haaphqucg2u9g8gwgv6z8jzegvca85r4d7yqh9) on chain ibc-0
SUCCESS Added key 'wallet1' (cosmos1cgjf7m9txsxf2pdekxk60ll6xusx0heznqsnxn) on chain ibc-0
SUCCESS Added key 'wallet' (cosmos1zp3t2rp7tjr23wchp36lmw7vhk77gtvvc7lc5s) on chain ibc-1
SUCCESS Added key 'wallet2' (cosmos1644x9c8pyfwcmg43ch2u3vr6hl4rkmkz2weq39) on chain ibc-1
SUCCESS Added key 'wallet1' (cosmos1dsrj2uqjvtssenkwperuvfkgkg2xvmydvpzswy) on chain ibc-1
SUCCESS Added key 'wallet' (cosmos1k6c6le34zsmz34yez84a7tquedy3mkc3hy7wg8) on chain ibc-2
SUCCESS Added key 'wallet2' (cosmos1murv55h3utv5ck0a2tk5ue3n88wgglhlhyzyq8) on chain ibc-2
SUCCESS Added key 'wallet1' (cosmos1r8sq88n4k8ajsmq3sscnsd8829lqxvsmue2gf7) on chain ibc-2
SUCCESS Added key 'wallet' (cosmos1eykzqwq20sqdgvhf0tmz6xjq9mlcluwxed77gj) on chain ibc-3
SUCCESS Added key 'wallet2' (cosmos1lz6df9uggl9459z2vusw9tknpy3xn2v7yq60k9) on chain ibc-3
SUCCESS Added key 'wallet1' (cosmos15jxyjskrx7s8yqpfn3xddlrx7qcq0f8r69mp4g) on chain ibc-3
</code></pre>
<blockquote>
<p><strong>TROUBLESHOOTING</strong>:</p>
<ul>
<li>If the command does not out output anything, make sure the path to Hermes' binary is set in <code>$HOME/.gm/gm.toml</code>.</li>
</ul>
</blockquote>
<h3 id="the-homegm-directory-1"><a class="header" href="#the-homegm-directory-1">The <code>$HOME/.gm</code> directory</a></h3>
<p>This directory is created when you install <code>gm</code> and the binaries are stored here but when we start the chains, all the related files and folders are stored here as well.</p>
<p>The <code>$HOME/.gm</code> directory has a tree structure similar to:</p>
<pre><code class="language-shell">.gm
├── bin
│   ├── gm
│   ├── lib-gm
│   └── shell-support
├── gm.toml
├── ibc-0
│   ├── config
│   ├── data
│   ├── init.json
│   ├── keyring-test
│   ├── log
│   ├── pid
│   ├── validator_seed.json
│   ├── wallet1_seed.json
│   ├── wallet2_seed.json
│   └── wallet_seed.json
├── ibc-1
│   ├── config
│   ├── data
│   ├── init.json
│   ├── keyring-test
│   ├── log
│   ├── pid
│   ├── validator_seed.json
│   ├── wallet1_seed.json
│   ├── wallet2_seed.json
│   └── wallet_seed.json
├── ibc-2
│   ├── config
│   ├── data
│   ├── init.json
│   ├── keyring-test
│   ├── log
│   ├── pid
│   ├── validator_seed.json
│   ├── wallet1_seed.json
│   ├── wallet2_seed.json
│   └── wallet_seed.json
├── ibc-3
│   ├── config
│   ├── data
│   ├── init.json
│   ├── keyring-test
│   ├── log
│   ├── pid
│   ├── validator_seed.json
│   ├── wallet1_seed.json
│   ├── wallet2_seed.json
│   └── wallet_seed.json
├── node-0
│   ├── config
│   ├── data
│   ├── init.json
│   ├── log
│   └── pid
├── node-1
│   ├── config
│   ├── data
│   ├── init.json
│   ├── log
│   └── pid
├── node-2
│   ├── config
│   ├── data
│   ├── init.json
│   ├── log
│   └── pid
└── node-3
    ├── config
    ├── data
    ├── init.json
    ├── log
    └── pid

</code></pre>
<blockquote>
<p><strong>Tip</strong>: You can use the command <code>tree $HOME/.gm/ -L 2</code> to view the folder structure above</p>
</blockquote>
<h3 id="the-homehermes-directory-1"><a class="header" href="#the-homehermes-directory-1">The <code>$HOME/.hermes</code> directory</a></h3>
<p>By default, <code>hermes</code> expects the configuration file to be in the <strong><code>$HOME/.hermes</code></strong> folder.</p>
<p>It also stores the private keys for each chain in this folder as outlined in the <a href="tutorials/more-chains/../../documentation/commands/keys/index.html">Keys</a> section.</p>
<p>After executing <code>gm start</code>, this is how the folder should look like:</p>
<pre><code class="language-shell">$HOME/.hermes/
├── config.toml
└── keys
    ├── ibc-0
    │   └── keyring-test
    │       ├── wallet.json
    │       ├── wallet1.json
    │       └── wallet2.json
    ├── ibc-1
    │   └── keyring-test
    │       ├── wallet.json
    │       ├── wallet1.json
    │       └── wallet2.json
    ├── ibc-2
    │   └── keyring-test
    │       ├── wallet.json
    │       ├── wallet1.json
    │       └── wallet2.json
    └── ibc-3
        └── keyring-test
            ├── wallet.json
            ├── wallet1.json
            └── wallet2.json
</code></pre>
<hr />
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<p><a href="tutorials/more-chains/./build-the-topology.html">The next section</a> describes how to create an arbitrary topology between these chains before relaying packets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-the-topology"><a class="header" href="#build-the-topology">Build the topology</a></h1>
<p>At this point in the tutorial, you should have four chains running and Hermes correctly configured. You can perform a <code>health-check</code> with the command :</p>
<pre><code class="language-shell">hermes health-check

</code></pre>
<p>If the command runs successfully, it should output something similar to:</p>
<pre><code>    2022-08-23T15:54:58.150005Z  INFO ThreadId(01) using default configuration from '$HOME/.hermes/config.toml'
    2022-08-23T15:54:58.150179Z  INFO ThreadId(01) [ibc-0] performing health check...
    2022-08-23T15:54:58.163298Z  INFO ThreadId(01) chain is healthy chain=ibc-0
    2022-08-23T15:54:58.163323Z  INFO ThreadId(01) [ibc-1] performing health check...
    2022-08-23T15:54:58.169132Z  INFO ThreadId(01) chain is healthy chain=ibc-1
    2022-08-23T15:54:58.169154Z  INFO ThreadId(01) [ibc-2] performing health check...
    2022-08-23T15:54:58.178418Z  INFO ThreadId(01) chain is healthy chain=ibc-2
    2022-08-23T15:54:58.178445Z  INFO ThreadId(01) [ibc-3] performing health check...
    2022-08-23T15:54:58.184615Z  INFO ThreadId(01) chain is healthy chain=ibc-3
    SUCCESS performed health check for all chains in the config
</code></pre>
<p>In the following tutorial, we will connect all of these chains in a full mesh topology, then use <code>Packet filters</code> to simulate the topology given at the beginning of the <a href="tutorials/more-chains/./start-local-chains.html">previous section</a>.</p>
<blockquote>
<p><strong>NOTE</strong>: It is also possible to only create the channels that you want. However, in production, anyone can open channels and recreate a fully-connected topology.</p>
</blockquote>
<hr />
<h2 id="connect-all-the-chains"><a class="header" href="#connect-all-the-chains">Connect all the chains</a></h2>
<p>Execute the following command:</p>
<pre><code class="language-shell">gm hermes cc 
</code></pre>
<p>If this command runs successfully, it should output the following:</p>
<pre><code class="language-shell">"$HOME/hermes/target/release/hermes" create channel --a-chain ibc-0 --b-chain ibc-1 --a-port transfer --b-port transfer --new-client-connection

"$HOME/hermes/target/release/hermes" create channel --a-chain ibc-0 --b-chain ibc-2 --a-port transfer --b-port transfer --new-client-connection

"$HOME/hermes/target/release/hermes" create channel --a-chain ibc-0 --b-chain ibc-3 --a-port transfer --b-port transfer --new-client-connection

"$HOME/hermes/target/release/hermes" create channel --a-chain ibc-1 --b-chain ibc-2 --a-port transfer --b-port transfer --new-client-connection

"$HOME/hermes/target/release/hermes" create channel --a-chain ibc-1 --b-chain ibc-3 --a-port transfer --b-port transfer --new-client-connection

"$HOME/hermes/target/release/hermes" create channel --a-chain ibc-2 --b-chain ibc-3 --a-port transfer --b-port transfer --new-client-connection

</code></pre>
<p>Executing these commands will:</p>
<ul>
<li>For every pair of chains, create a client on both chain tracking the state of the counterparty chain.</li>
<li>Create a connection between these two clients.</li>
<li>Create a <code>transfer</code> channel over this connection.</li>
</ul>
<p>Use the flag <code>--exec</code> flag to execute these commands:</p>
<pre><code class="language-shell">gm hermes cc --exec
</code></pre>
<p>At this point, your network should be fully connected. It is now time to filter channels. The following chart shows the current state of the network. The channels that we want to filter out are filled in red while the channels we want to relay on are filled in green:</p>
<p><strong>Network topology</strong></p>
<pre class="mermaid">flowchart TD 
    ibc0((ibc-0))
    ibc0ibc1[[channel-0]]
    ibc0ibc2[[channel-1]]
    ibc0ibc3[[channel-2]]

    ibc1((ibc-1))
    ibc1ibc0[[channel-0]]
    ibc1ibc2[[channel-1]]
    ibc1ibc3[[channel-2]]

    ibc2((ibc-2))
    ibc2ibc0[[channel-0]]
    ibc2ibc1[[channel-1]]
    ibc2ibc3[[channel-2]]

    ibc3((ibc-3))
    ibc3ibc0[[channel-0]]
    ibc3ibc1[[channel-1]]
    ibc3ibc2[[channel-2]]

    classDef deny fill:#AA0000,color:#000000;
    classDef allow fill:#00AA00,color:#000000;
    class ibc0ibc1 allow;
    class ibc1ibc0 allow;
    class ibc0ibc3 allow;
    class ibc3ibc0 allow;
    class ibc2ibc1 allow;
    class ibc1ibc2 allow;
    class ibc2ibc3 allow;
    class ibc3ibc2 allow;


    class ibc1ibc3 deny;
    class ibc3ibc1 deny;
    class ibc0ibc2 deny;
    class ibc2ibc0 deny;

    ibc0---ibc0ibc1---ibc1ibc0---ibc1
    ibc0---ibc0ibc2---ibc2ibc0---ibc2
    ibc0---ibc0ibc3---ibc3ibc0---ibc3
    ibc1---ibc1ibc2---ibc2ibc1---ibc2
    ibc1---ibc1ibc3---ibc3ibc1---ibc3
    ibc2---ibc2ibc3---ibc3ibc2---ibc3
</pre>
<p>You can verify that everything is correct with the commands:</p>
<pre><code class="language-shell">hermes query channels --show-counterparty --chain ibc-0

hermes query channels --show-counterparty --chain ibc-1

hermes query channels --show-counterparty --chain ibc-2

hermes query channels --show-counterparty --chain ibc-3

</code></pre>
<p>Which should normally output:</p>
<pre><code>ibc-0: transfer/channel-0 --- ibc-1: transfer/channel-0
ibc-0: transfer/channel-1 --- ibc-2: transfer/channel-0
ibc-0: transfer/channel-2 --- ibc-3: transfer/channel-0

ibc-1: transfer/channel-0 --- ibc-0: transfer/channel-0
ibc-1: transfer/channel-1 --- ibc-2: transfer/channel-1
ibc-1: transfer/channel-2 --- ibc-3: transfer/channel-1

ibc-2: transfer/channel-0 --- ibc-0: transfer/channel-1
ibc-2: transfer/channel-1 --- ibc-1: transfer/channel-1
ibc-2: transfer/channel-2 --- ibc-3: transfer/channel-2

ibc-3: transfer/channel-0 --- ibc-0: transfer/channel-2
ibc-3: transfer/channel-1 --- ibc-1: transfer/channel-2
ibc-3: transfer/channel-2 --- ibc-2: transfer/channel-2
</code></pre>
<h2 id="add-packet-filters"><a class="header" href="#add-packet-filters">Add packet filters</a></h2>
<p>Let's use packet filters to relay only on the green paths specified in the chart. In order to add filters, open your default configuration file <code>$HOME/.hermes/config.toml</code> and add:</p>
<ul>
<li>Under <code>ibc-0</code>'s config:
<pre><code>[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-0'],
    ['transfer', 'channel-2'],
]
</code></pre>
</li>
<li>Under <code>ibc-1</code>'s config:
<pre><code>[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-0'],
    ['transfer', 'channel-1'],
]
</code></pre>
</li>
<li>Under <code>ibc-2</code>'s config:
<pre><code>[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-1'],
    ['transfer', 'channel-2'],
]
</code></pre>
</li>
<li>Under <code>ibc-3</code>'s config:
<pre><code>[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-0'],
    ['transfer', 'channel-2'],
]
</code></pre>
</li>
</ul>
<blockquote>
<p><strong>NOTE</strong>: It is also possible to use a <code>deny</code> policy to filter out the channels you do not want to relay on. However, if other channels exist or are created, Hermes will also relay on them.</p>
</blockquote>
<p>At this point, your config file should look like this:</p>
<details><summary style="font-weight:bold">config.toml</summary>
<pre><code>[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = true

[mode.channels]
enabled = true

[mode.packets]
enabled = true
clear_interval = 100
clear_on_start = true
tx_confirmation = true

[telemetry]
enabled = true
host = '127.0.0.1'
port = 3001

[[chains]]
id = 'ibc-0'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27050'
grpc_addr = 'http://localhost:27052'
event_source = { mode = 'push', url = 'ws://localhost:27050/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-0'],
    ['transfer', 'channel-2'],
]

[[chains]]
id = 'ibc-1'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27060'
grpc_addr = 'http://localhost:27062'
event_source = { mode = 'push', url = 'ws://localhost:27060/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }


[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-0'],
    ['transfer', 'channel-1'],
]

[[chains]]
id = 'ibc-2'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27070'
grpc_addr = 'http://localhost:27072'
event_source = { mode = 'push', url = 'ws://localhost:27070/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-1'],
    ['transfer', 'channel-2'],
]

[[chains]]
id = 'ibc-3'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27080'
grpc_addr = 'http://localhost:27082'
event_source = { mode = 'push', url = 'ws://localhost:27080/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-0'],
    ['transfer', 'channel-2'],
]
</code></pre>
</details>
<p>It is also possible to check that the configuration file is valid with the command:</p>
<pre><code class="language-shell">hermes config validate

</code></pre>
<p>If the command runs successfully, the output should be:</p>
<pre><code>SUCCESS "configuration is valid"
</code></pre>
<hr />
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<p>The <a href="tutorials/more-chains/./start-relaying.html">following section</a> describes how to relay packets between any chain with this topology.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="start-relaying-1"><a class="header" href="#start-relaying-1">Start relaying</a></h1>
<p>In the previous tutorial, you learned about how to relay packets between a pair of chains on a relay path. Now, you will learn how to relay packets on an arbitrary topology.</p>
<blockquote>
<p><strong>WARNING</strong> Before proceeding to the sections below, please first, make sure you followed the steps in the <a href="tutorials/more-chains/./build-the-topology.html">Build the topology section</a>.</p>
</blockquote>
<p>The chains should be fully connected and the relayer should be setup to relay on these channels:</p>
<pre class="mermaid">flowchart TD 
ibc0((ibc-0))
ibc0ibc1[[channel-0]]
ibc0ibc3[[channel-2]]

ibc1((ibc-1))
ibc1ibc0[[channel-0]]
ibc1ibc2[[channel-1]]

ibc2((ibc-2))
ibc2ibc1[[channel-1]]
ibc2ibc3[[channel-2]]

ibc3((ibc-3))
ibc3ibc0[[channel-0]]
ibc3ibc2[[channel-2]]

ibc0---ibc0ibc1---ibc1ibc0---ibc1
ibc0---ibc0ibc3---ibc3ibc0---ibc3
ibc1---ibc1ibc2---ibc2ibc1---ibc2
ibc2---ibc2ibc3---ibc3ibc2---ibc3
</pre>
<hr />
<h2 id="query-balances-1"><a class="header" href="#query-balances-1">Query balances</a></h2>
<ul>
<li>
<p>Balances on <code>ibc-0</code>:</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:27050 query bank balances $(gaiad --home ~/.gm/ibc-0 keys --keyring-backend="test" show wallet -a)
</code></pre>
</li>
<li>
<p>Balances on <code>ibc-1</code>:</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:27060 query bank balances $(gaiad --home ~/.gm/ibc-1 keys --keyring-backend="test" show wallet -a)
</code></pre>
</li>
<li>
<p>Balances on <code>ibc-2</code>:</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:27070 query bank balances $(gaiad --home ~/.gm/ibc-2 keys --keyring-backend="test" show wallet -a)
</code></pre>
</li>
<li>
<p>Balances on <code>ibc-3</code>:</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:27080 query bank balances $(gaiad --home ~/.gm/ibc-3 keys --keyring-backend="test" show wallet -a)
</code></pre>
</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> the RPC addresses used in the two commands above are configured in <code>~/.hermes/config.toml</code> file. It can also be found with <code>gm status</code></p>
</blockquote>
<p>At this point in the tutorial, every command should output something similar to:</p>
<pre><code>balances:
- amount: "100000000"
  denom: samoleans
- amount: "99982481"
  denom: stake
pagination:
  next_key: null
  total: "0"
</code></pre>
<h2 id="start-relaying-2"><a class="header" href="#start-relaying-2">Start relaying</a></h2>
<p>Now, let's exchange <code>samoleans</code> between chains.</p>
<ul>
<li>
<p>Open a new terminal and start Hermes using the <code>start</code> command :</p>
<pre><code class="language-shell">hermes start

</code></pre>
<p>Hermes will first relay the pending packets that have not been relayed and then start passively relaying by listening for and acting on packet events.</p>
</li>
<li>
<p>Let's transfer <code>1000000 samoleans</code> from ibc-1 to ibc-3. There is a direct path between ibc-1 (channel-2) and ibc-3 (channel-1). Let's attempt the transfer on this path.</p>
<ul>
<li>In a separate terminal, use the <code>ft-transfer</code> command to send <code>1000000 samoleans</code> from ibc-1 to ibc-3 from channel-2:</li>
</ul>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 10000 --dst-chain ibc-3 --src-chain ibc-1 --src-port transfer --src-channel channel-2 --amount 1000000

</code></pre>
<ul>
<li>
<p>Wait a few seconds then query balances on <code>ibc-1</code> and <code>ibc-3</code>. You should observe that <code>ibc-1</code> lost 1000000 samoleans but <code>ibc-3</code> did not receive any:</p>
<ul>
<li>Balances at ibc-1 :
<pre><code>balances:
- amount: "99000000"
denom: samoleans
- amount: "99980646"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
<li>Balances at ibc-3 :
<pre><code>balances:
- amount: "100000000"
denom: samoleans
- amount: "99979803"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
</ul>
</li>
<li>
<p>Observe the output on the relaying terminal and verify that no event is processed.</p>
</li>
</ul>
<p>If you correctly created the packet filters in the <a href="tutorials/more-chains/./build-the-topology.html">previous section</a>, Hermes does not relay on this path. So what happened to the 1000000 <code>samoleans</code> you just sent ? It is stuck until a relayer decides to relay this packet to <code>ibc-3</code>. For now, let's forget about these <code>samoleans</code>. We can get as many as we want anyway.</p>
<p>It might be impossible to send packets directly from <code>ibc-1</code> to <code>ibc-3</code>, however, it is possible to use <code>ibc-2</code> as a bridge:</p>
</li>
</ul>
<pre class="mermaid">graph LR;
    A((ibc-1)) --&gt; B((ibc-2)) --&gt; C((ibc-3))
</pre>
<ul>
<li>
<p>In a separate terminal, use the <code>ft-transfer</code> command to send <code>1000000 samoleans</code> from ibc-1 to ibc-2 from channel-1:</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 10000 --dst-chain ibc-2 --src-chain ibc-1 --src-port transfer --src-channel channel-1 --amount 1000000

</code></pre>
</li>
<li>
<p>Wait a few seconds then query balances on <code>ibc-1</code> and <code>ibc-2</code>. You should observe something similar to:</p>
<ul>
<li>Balances on <code>ibc-1</code>:
<pre><code>balances:
- amount: "98000000"
denom: samoleans
- amount: "99979707"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
<li>Balances at ibc-2:
<pre><code>balances:
- amount: "1000000"
denom: ibc/C1840BD16FCFA8F421DAA0DAAB08B9C323FC7685D0D7951DC37B3F9ECB08A199
- amount: "100000000"
denom: samoleans
- amount: "99979154"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
</ul>
<p>The samoleans were transferred to <code>ibc-1</code> and are visible under the denomination <code>ibc/C1840...</code> (it might be a different one for you).</p>
</li>
<li>
<p>Transfer these tokens to <code>ibc-3</code>:</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 10000 --denom ibc/C1840BD16FCFA8F421DAA0DAAB08B9C323FC7685D0D7951DC37B3F9ECB08A199 --dst-chain ibc-3 --src-chain ibc-2 --src-port transfer --src-channel channel-2 --amount 1000000

</code></pre>
</li>
<li>
<p>Wait a few seconds then query balances on <code>ibc-2</code> and <code>ibc-3</code>. You should observe something similar to:</p>
<ul>
<li>Balances on <code>ibc-2</code>:
<pre><code>balances:
- amount: "100000000"
denom: samoleans
- amount: "99977059"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
<li>Balances on <code>ibc-3</code>:
<pre><code>balances:
- amount: "1000000"
denom: ibc/C658F0EB9DE176E080B586D634004141239C3E55676462C976266DB54C56EBE4
- amount: "100000000"
denom: samoleans
- amount: "99978251"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
</ul>
<p>The tokens were correctly received by <code>ibc-3</code> under the denomination <code>ibc/C658...</code>.</p>
</li>
</ul>
<h2 id="send-back-the-tokens"><a class="header" href="#send-back-the-tokens">Send back the tokens</a></h2>
<p>Now let's send some of these coins back to <code>ibc-1</code>. We will dedicate half of them to learn a valuable lesson while the other half will be correctly transferred back.</p>
<h3 id="the-wrong-way"><a class="header" href="#the-wrong-way">The wrong way</a></h3>
<p>Let's start with a common mistake and send back these coins on a different path than the one they were received on:</p>
<p><strong>Another path to ibc-1</strong></p>
<pre class="mermaid">graph LR;
A((ibc-3)) --&gt; B((ibc-0)) --&gt; C((ibc-1));
</pre>
<ul>
<li>
<p>Use the <code>ft-transfer</code> command to transfer <code>500000 ibc/C658...</code> tokens from <code>ibc-3</code> to <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 10000 --denom ibc/C658F0EB9DE176E080B586D634004141239C3E55676462C976266DB54C56EBE4 --dst-chain ibc-0 --src-chain ibc-3 --src-port transfer --src-channel channel-0 --amount 500000

</code></pre>
</li>
<li>
<p>Wait a few seconds, then query balances on <code>ibc-0</code> and <code>ibc-3</code>. You should observe something similar to:</p>
<ul>
<li>Balances on <code>ibc-0</code>:
<pre><code>balances:
- amount: "500000"
denom: ibc/563FDAE5A0D8C15013E4485134A2D2EE3317452278B56B2ED63DDB4EB677DF84
- amount: "100000000"
denom: samoleans
- amount: "99980928"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
<li>Balances on <code>ibc-3</code>:
<pre><code>balances:
- amount: "500000"
denom: ibc/C658F0EB9DE176E080B586D634004141239C3E55676462C976266DB54C56EBE4
- amount: "100000000"
denom: samoleans
- amount: "99976153"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
</ul>
<p>The tokens were correctly received by <code>ibc-0</code> under the denomination <code>ibc/563...</code>.</p>
</li>
<li>
<p>Transfer the <code>ibc/563...</code> tokens from <code>ibc-0</code> to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 10000 --denom ibc/563FDAE5A0D8C15013E4485134A2D2EE3317452278B56B2ED63DDB4EB677DF84 --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-0 --amount 500000

</code></pre>
</li>
<li>
<p>Wait a few seconds then query balances on <code>ibc-0</code> and <code>ibc-3</code>. You should observe something similar to:</p>
<ul>
<li>Balances on <code>ibc-0</code>:
<pre><code>balances:
- amount: "100000000"
denom: samoleans
- amount: "99978828"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
<li>Balances on <code>ibc-1</code>:
<pre><code>balances:
- amount: "500000"
denom: ibc/8F3641F853A1D075C549E733AB624BA8607C8D2FFC26B32717DE660AE6A34A73
- amount: "98000000"
denom: samoleans
- amount: "99978141"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
</ul>
<p>The tokens were successfully received by <code>ibc-1</code> under the denomination <code>ibc/8F3...</code> while they should be recognized as samoleans. Indeed, <strong>it is impossible to transfer back tokens from a different channel than the one they were received from</strong>.</p>
<p>You could get the tokens back to samoleans by transferring them back via the route you sent
them from, but instead let's forget about these tokens.</p>
</li>
</ul>
<h3 id="the-right-way"><a class="header" href="#the-right-way">The right way</a></h3>
<p>Now that you have seen the wrong way to transfer back tokens, let's see the right way. <strong>Tokens should be transferred back on the same path they were received</strong>.</p>
<p><strong>Correct Path</strong>:</p>
<pre class="mermaid">graph LR;
A((ibc-3))--&gt;B((ibc-2))--&gt;C((ibc-1));
</pre>
<ul>
<li>
<p>Use the <code>ft-transfer</code> command to transfer <code>500000 ibc/C658...</code> tokens from <code>ibc-3</code> to <code>ibc-2</code>:</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 10000 --denom ibc/C658F0EB9DE176E080B586D634004141239C3E55676462C976266DB54C56EBE4 --dst-chain ibc-2 --src-chain ibc-3 --src-port transfer --src-channel channel-2 --amount 500000

</code></pre>
</li>
<li>
<p>Wait a few seconds then query balances on <code>ibc-2</code> and <code>ibc-3</code>. You should observe something similar to:</p>
<ul>
<li>Balances at ibc-2:
<pre><code>balances:
- amount: "500000"
denom: ibc/C1840BD16FCFA8F421DAA0DAAB08B9C323FC7685D0D7951DC37B3F9ECB08A199
- amount: "100000000"
denom: samoleans
- amount: "99975713"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
<li>Balances at ibc-3:
<pre><code>balances:
- amount: "100000000"
denom: samoleans
- amount: "99973935"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
</ul>
<p>The tokens were correctly received by <code>ibc-2</code> under the denomination <code>ibc/C184...</code>. The tokens retrieved the denomination they had before they were transferred to ibc-3.</p>
</li>
<li>
<p>Transfer the <code>ibc/C184...</code> tokens from ibc-2 to ibc-1:</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 10000 --denom ibc/C1840BD16FCFA8F421DAA0DAAB08B9C323FC7685D0D7951DC37B3F9ECB08A199 --dst-chain ibc-1 --src-chain ibc-2 --src-port transfer --src-channel channel-1 --amount 500000

</code></pre>
</li>
<li>
<p>Wait a few seconds, then query balances on <code>ibc-1</code> and <code>ibc-2</code>. You should observe something similar to:</p>
<ul>
<li>Balances on <code>ibc-1</code>:
<pre><code>balances:
- amount: "500000"
denom: ibc/8F3641F853A1D075C549E733AB624BA8607C8D2FFC26B32717DE660AE6A34A73
- amount: "98500000"
denom: samoleans
- amount: "99975741"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
<li>Balances on <code>ibc-2</code>:
<pre><code>balances:
- amount: "100000000"
denom: samoleans
- amount: "99974602"
denom: stake
pagination:
next_key: null
total: "0"
</code></pre>
</li>
</ul>
<p>The tokens were successfully received by <code>ibc-1</code> under the denomination <code>samoleans</code>.</p>
</li>
</ul>
<hr />
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<p>In the <a href="tutorials/more-chains/./concurrent-instances.html">next section</a>, you will start new instances of Hermes to relay packets over the channels that were filtered out by the first instance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-new-instances-of-hermes"><a class="header" href="#add-new-instances-of-hermes">Add new instances of Hermes</a></h1>
<p>In the previous section, you attempted a direct transfer between <code>ibc-1</code> and <code>ibc-3</code> which failed because your current instance of Hermes does not relay on that path.</p>
<p>In the following section, you will start new instances of Hermes to relay on the paths which are currently disabled:</p>
<pre class="mermaid">flowchart LR
A((ibc-0))---B[[channel-1]]---C[[channel-0]]---D((ibc-2))

E((ibc-1))---G[[channel-2]]---H[[channel-1]]---F((ibc-3))

classDef deny fill:#AA0000,color:#000000;

class B deny;
class C deny;
class G deny;
class H deny;
</pre>
<p>Running multiple instances of Hermes can have many advantages and disadvantages. It allows for fine-grained control over every channel and can be more stable than running a single instance. However, you will also need to manage more wallets.</p>
<hr />
<h2 id="create-a-new-config-file"><a class="header" href="#create-a-new-config-file">Create a new config file</a></h2>
<p>First, you will have to create a new configuration file with:</p>
<ul>
<li>
<p>New packets filters.</p>
<p>In order to enable the new paths.</p>
</li>
<li>
<p>Different wallets.</p>
<p><strong>Two instances of Hermes can not share the same wallet.</strong></p>
</li>
<li>
<p>A different telemetry port.</p>
<p><strong>Two processes can not share the same port for any of their services.</strong></p>
</li>
</ul>
<p>Create the following configuration file at <code>$HOME/hermes_second_instance.toml</code>:</p>
<p><strong>hermes_second_instance.toml</strong></p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = true

[mode.channels]
enabled = true

[mode.packets]
enabled = true
clear_interval = 100
clear_on_start = true
tx_confirmation = true

[telemetry]
enabled = true
host = '127.0.0.1'
port = 3002

[[chains]]
id = 'ibc-0'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27050'
grpc_addr = 'http://localhost:27052'
event_source = { mode = 'push', url = 'ws://localhost:27050/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-1'],
]

[[chains]]
id = 'ibc-1'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27060'
grpc_addr = 'http://localhost:27062'
event_source = { mode = 'push', url = 'ws://localhost:27060/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-2'],
]

[[chains]]
id = 'ibc-2'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27070'
grpc_addr = 'http://localhost:27072'
event_source = { mode = 'push', url = 'ws://localhost:27070/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-0'],
]

[[chains]]
id = 'ibc-3'
type = 'CosmosSdk'
rpc_addr = 'http://localhost:27080'
grpc_addr = 'http://localhost:27082'
event_source = { mode = 'push', url = 'ws://localhost:27080/websocket', batch_delay = '200ms' }
rpc_timeout = '15s'
trusted_node = true
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.2
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

[chains.packet_filter]
policy = 'allow'
list = [
    ['transfer', 'channel-1'],
]
</code></pre>
<p>In order to make use of this config, specify it with the <code>--config</code> flag:</p>
<pre><code class="language-shell">hermes --config $HOME/hermes_second_instance.toml &lt;COMMAND&gt;
</code></pre>
<h2 id="query-pending-packets"><a class="header" href="#query-pending-packets">Query pending packets</a></h2>
<p>Let's find the packet that was lost in the first step of the <a href="tutorials/more-chains/./start-relaying.html">previous section</a> with the <code>query packet</code> command:</p>
<pre><code class="language-shell">hermes query packet pending --chain ibc-1 --port transfer --channel channel-2

</code></pre>
<blockquote>
<p><strong>NOTE</strong>: You do not need to specify the configuration file as long as <code>ibc-1</code> and <code>ibc-3</code> are in the default config file.</p>
</blockquote>
<p>If the command runs successfully, it should output:</p>
<pre><code>SUCCESS Summary {
    src: PendingPackets {
        unreceived_packets: [
            Sequence(
                1,
            ),
        ],
        unreceived_acks: [],
    },
    dst: PendingPackets {
        unreceived_packets: [],
        unreceived_acks: [],
    },
}
</code></pre>
<h2 id="clear-the-packet"><a class="header" href="#clear-the-packet">Clear the packet</a></h2>
<p>Now that we have retrieved this packet, let's clear it manually with the command <code>hermes clear packets</code>:</p>
<pre><code class="language-shell">hermes  --config $HOME/hermes_second_instance.toml clear packets --chain ibc-1 --port transfer --channel channel-2

</code></pre>
<blockquote>
<p><strong>NOTE</strong>: We are using the second config to avoid using the same wallets as the running instance of Hermes. You could also simply use the <code>key-name</code> and <code>counterparty-key-name</code> flags to set another wallet. If you do not use it, you will observe a few <code>account_sequence_mismatch</code> errors on the terminal running <code>hermes start</code> but Hermes will automatically recover.</p>
</blockquote>
<p>If the command runs successfully, it should output:</p>
<pre><code>SUCCESS [
    UpdateClient(
        cs_h: 07-tendermint-1(1-364),
    ),
    WriteAcknowledgement(
        WriteAcknowledgement - seq:1, path:channel-2/transfer-&gt;channel-1/transfer, toh:no timeout, tos:Timestamp(2022-08-29T18:29:44.733494709Z)),
    ),
    UpdateClient(
        cs_h: 07-tendermint-2(3-365),
    ),
    AcknowledgePacket(
        AcknowledgePacket - seq:1, path:channel-2/transfer-&gt;channel-1/transfer, toh:no timeout, tos:Timestamp(2022-08-29T18:29:44.733494709Z)),
    ),
]
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: It can also output a TimeoutPacket if you execute it after the packet times out (10000 seconds in this case).</p>
</blockquote>
<p>You can verify that the packet was correctly relayed by querying balances or directly querying packets:</p>
<pre><code class="language-shell">hermes query packet pending --chain ibc-1 --port transfer --channel channel-2

</code></pre>
<p>If the command runs successfully, it should output:</p>
<pre><code>SUCCESS Summary {
    src: PendingPackets {
        unreceived_packets: [],
        unreceived_acks: [],
    },
    dst: PendingPackets {
        unreceived_packets: [],
        unreceived_acks: [],
    },
}
</code></pre>
<p>As you can see, there is currently no stuck packet between <code>ibc-1</code> and <code>ibc-3</code>.</p>
<h2 id="make-stuck-packets"><a class="header" href="#make-stuck-packets">Make stuck packets</a></h2>
<p>For the sake of learning, let's make new stuck packets on the <code>ibc-0&lt;&gt;ibc-2</code> channel and the <code>ibc-1&lt;&gt;ibc-3</code> channel.</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 10000 --dst-chain ibc-3 --src-chain ibc-1 --src-port transfer --src-channel channel-2 --amount 1000000

hermes tx ft-transfer --timeout-seconds 10000 --dst-chain ibc-2 --src-chain ibc-0 --src-port transfer --src-channel channel-1 --amount 1000000

</code></pre>
<p>If both commands run successfully, they should output a <code>SUCCESS</code> message.</p>
<p>Now, let's verify that these packets are indeed stuck with the <code>query packet</code> command:</p>
<ul>
<li>
<p>On <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query packet pending --chain ibc-0 --port transfer --channel channel-1

</code></pre>
<p>Which should output:</p>
<pre><code>SUCCESS Summary {
    src: PendingPackets {
        unreceived_packets: [
            Sequence(
                1,
            ),
        ],
        unreceived_acks: [],
    },
    dst: PendingPackets {
        unreceived_packets: [],
        unreceived_acks: [],
    },
}
</code></pre>
</li>
<li>
<p>On <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query packet pending --chain ibc-1 --port transfer --channel channel-2

</code></pre>
<p>Which should output:</p>
<pre><code>SUCCESS Summary {
    src: PendingPackets {
        unreceived_packets: [
            Sequence(
                2,
            ),
        ],
        unreceived_acks: [],
    },
    dst: PendingPackets {
        unreceived_packets: [],
        unreceived_acks: [],
    },
}   
</code></pre>
</li>
</ul>
<p>You have pending packets on the two paths filtered out by our running instance.</p>
<blockquote>
<p><strong>NOTE</strong>: You can also verify that Hermes is still relaying on the other paths by sending a packet from <code>ibc-1</code> to <code>ibc-2</code>:</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-seconds 10000 --dst-chain ibc-2 --src-chain ibc-1 --src-port transfer --src-channel channel-1 --amount 1000000
</code></pre>
</blockquote>
<blockquote>
<pre><code>
Wait a few seconds then verify that no packet is pending with:
```shell
hermes query packet pending --chain ibc-1 --port transfer --channel channel-1
</code></pre>
</blockquote>
<blockquote>
<pre><code></code></pre>
</blockquote>
<h2 id="start-your-second-instance-to-clear-packets"><a class="header" href="#start-your-second-instance-to-clear-packets">Start your second instance to clear packets</a></h2>
<p>Instead of clearing packets manually again, you can just start Hermes with the <a href="tutorials/more-chains/concurrent-instances.html#create-a-new-config-file">new config file you created</a> in a new terminal:</p>
<pre><code class="language-shell">hermes  --config $HOME/hermes_second_instance.toml start

</code></pre>
<p>At launch, Hermes will clear pending packets before moving into passive mode.</p>
<ul>
<li>
<p>Wait a few seconds. You should observe logs produced on the terminal running the second instance of Hermes.</p>
</li>
<li>
<p>Query for pending packets at <code>ibc-0</code> on <code>channel-1</code> and <code>ibc-1</code> on <code>channel-2</code> again with the <code>query packet pending</code> command. Both should output:</p>
<pre><code>SUCCESS Summary {
    src: PendingPackets {
        unreceived_packets: [],
        unreceived_acks: [],
    },
    dst: PendingPackets {
        unreceived_packets: [],
        unreceived_acks: [],
    },
}
</code></pre>
</li>
</ul>
<p>You can now send packets between any pair of chains. One of your two instances will relay it. Feel free to exchange more packets and observe the logs.</p>
<h2 id="stop-relaying-and-stop-the-chains-1"><a class="header" href="#stop-relaying-and-stop-the-chains-1">Stop relaying and stop the chains</a></h2>
<ul>
<li>
<p>Stop Hermes by pressing <code>Ctrl+C</code> on the terminals running <code>hermes start </code>.</p>
</li>
<li>
<p>Stop the chains with <code>gm stop</code>.</p>
</li>
</ul>
<hr />
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<p>In the <a href="tutorials/more-chains/../production/index.html">next tutorial</a>, you will learn how to set up Hermes in production.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="production"><a class="header" href="#production">Production</a></h1>
<p>In this tutorial, you will learn how to set up Hermes to relay between the Cosmos Hub chain and the Osmosis chain.</p>
<p>You will monitor Hermes' activity with a <a href="https://grafana.com/"><code>Grafana dashboard</code></a> from which it is possible to visualize both the logs and the metrics produced by Hermes.</p>
<p>The <a href="tutorials/production/./setup-grafana.html">next section</a> will contain the steps to install all the dependencies of the monitoring platform.</p>
<hr />
<h2 id="sections-5"><a class="header" href="#sections-5">Sections</a></h2>
<ul>
<li>
<p><strong><a href="tutorials/production/./setup-grafana.html">Set up Grafana</a></strong></p>
<ul>
<li>Learn how to set up <a href="https://grafana.com">Grafana</a>'s monitoring stack for Hermes.</li>
</ul>
</li>
<li>
<p><strong><a href="tutorials/production/./setup-hermes.html">Set up Hermes</a></strong></p>
<ul>
<li>Learn how to configure Hermes on production chains (Cosmos Hub &lt;&gt; Osmosis).</li>
</ul>
</li>
<li>
<p><strong><a href="tutorials/production/./start-relaying.html">Start relaying</a></strong></p>
<ul>
<li>Exchange and relay packets between production chains.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-grafana"><a class="header" href="#setup-grafana">Setup Grafana</a></h1>
<p>Hermes provides many metrics to monitor its activity. You can find a detailed description of all the metrics in the <a href="tutorials/production/../../documentation/telemetry/index.html">Telemetry</a> section. In this chapter, you will install <a href="https://grafana.com/">Grafana</a> components which will ingest the data produced by Hermes and provide both analytics and visualization.</p>
<hr />
<h2 id="install-docker"><a class="header" href="#install-docker">Install Docker</a></h2>
<p>You will need <a href="https://www.docker.com/">Docker</a> installed and configured on your machine. We provide a <a href="tutorials/production/../../assets/docker-compose.yaml">Compose file</a> to install Grafana and all its dependencies through Docker.</p>
<p>To install and configure Docker, please follow the <a href="https://docs.docker.com/get-docker/">Docker official documentation</a>.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<h3 id="grafana-dashboard"><a class="header" href="#grafana-dashboard">Grafana Dashboard</a></h3>
<p><a href="https://grafana.com/">Grafana</a> is a multi-platform open source analytics and interactive visualization web application. It provides charts, graphs, and alerts for the web when connected to supported data sources. It can be used to monitor the health of an application and the data it produces. In the following tutorial, we will use a Grafana Dashboard to visualize the <a href="https://prometheus.io/">Prometheus</a> metrics and the logs.</p>
<h3 id="prometheus"><a class="header" href="#prometheus">Prometheus</a></h3>
<p>Prometheus is a free software application used for event monitoring and alerting. It records real-time metrics in a time series database (allowing for high dimensionality) built using an HTTP pull model, with flexible queries and real-time alerting. Hermes can expose Prometheus metrics. The Prometheus server will pull them and Grafana will use this server as a data source for data visualization.</p>
<h3 id="grafana-loki"><a class="header" href="#grafana-loki">Grafana Loki</a></h3>
<p><a href="https://grafana.com/oss/loki/">Loki</a> is a horizontally scalable, highly available, multi-tenant log aggregation system inspired by Prometheus. It will be used to aggregate the logs produced by Hermes.</p>
<h3 id="promtail"><a class="header" href="#promtail">Promtail</a></h3>
<p><a href="https://grafana.com/docs/loki/latest/clients/promtail/">Promtail</a> is an agent which ships the contents of local logs to a private Grafana Loki instance or Grafana Cloud. It is usually deployed to every machine that has applications needed to be monitored. You will use it to ship Hermes' logs to Loki.</p>
<blockquote>
<p><strong>NOTE</strong>: You will redirect <code>hermes</code>' output to <code>/var/log/hermes.log</code>. The configuration we provide ships every log file in <code>/var/log</code> to Loki.</p>
</blockquote>
<h2 id="setup-grafana-1"><a class="header" href="#setup-grafana-1">Setup Grafana</a></h2>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<ul>
<li>
<p>Download <a href="tutorials/production/../../assets/docker-compose.yaml">docker-compose.yaml</a>, <a href="tutorials/production/../../assets/prometheus.yml">prometheus.yml</a> and <a href="tutorials/production/../../assets/grafana_template.json">grafana_template.json</a> and place them in the same repository.</p>
</li>
<li>
<p>Run the following command in your command line to start Grafana, Prometheus, Loki, and Promtail.</p>
<pre><code>docker-compose -f docker-compose.yaml up
</code></pre>
</li>
</ul>
<h3 id="sign-in-to-grafana"><a class="header" href="#sign-in-to-grafana">Sign in to Grafana</a></h3>
<ul>
<li>Open your web browser and go to <code>http://localhost:3000/</code>.</li>
<li>On the sign-in page, enter <code>admin</code> for the username and password.</li>
<li>Click Sign in.
If successful, you will see a prompt to change the password.</li>
<li>Click OK on the prompt and change your password.</li>
</ul>
<h3 id="add-prometheus"><a class="header" href="#add-prometheus">Add Prometheus</a></h3>
<ul>
<li>In the sidebar, hover your cursor over the Configuration (gear) icon, and then select <code>Data Sources</code>.</li>
<li>Click <code>Add data source</code>.</li>
<li>In the list of data sources, select <code>Prometheus</code>.</li>
<li>In the URL box, enter <code>http://prometheus:9090</code>.</li>
<li>Click <code>Save &amp; Test</code>.
Prometheus is now available as a data source in Grafana.</li>
</ul>
<h3 id="add-loki"><a class="header" href="#add-loki">Add Loki</a></h3>
<ul>
<li>Add another data source, however, this time, select <code>Loki</code>.</li>
<li>In the URL box, enter <code>http://loki:3100</code>.</li>
<li>Click <code>Save &amp; Test</code>.
Loki is now available as a data source in Grafana.</li>
</ul>
<h3 id="set-up-the-dashboard"><a class="header" href="#set-up-the-dashboard">Set up the dashboard</a></h3>
<ul>
<li>Download the <a href="tutorials/production/../../assets/grafana_template.json">Grafana template</a> we provide.</li>
<li>In the sidebar, hover your cursor over the <code>+</code> icon, and then click <code>Import</code>.</li>
<li>Click on <code>Upload JSON file</code> and select the Grafana template you just downloaded.</li>
<li>On the <code>Import</code> page, enter <code>Hermes dashboard template</code> as a name, enter your data sources and click <code>Import</code>.</li>
<li>In the top right corner, next to the <code>refresh dashboard</code> button, select <code>5s</code> to automatically query Prometheus and Loki every 5s.</li>
</ul>
<hr />
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next steps</a></h2>
<p>In the <a href="tutorials/production/./setup-hermes.html">next section</a>, you will learn how to set up Hermes on production chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-hermes"><a class="header" href="#setup-hermes">Setup Hermes</a></h1>
<p>In this section, you will learn how to set up Hermes to relay between the Hub and Osmosis. You will relay on channels that are already created. <strong>It is strongly advised not to create any channels between two chains if another one with the same port already exists.</strong></p>
<hr />
<h2 id="setup-accounts"><a class="header" href="#setup-accounts">Setup accounts</a></h2>
<p>First, you need a wallet with enough funds on both chains. This tutorial assumes that you already have wallets created on the chains you want to relay on, and that these wallets have funds allocated to each of them.</p>
<h3 id="adding-a-private-key"><a class="header" href="#adding-a-private-key">Adding a private key</a></h3>
<p>You can add a private key using one of two different ways:</p>
<ul>
<li>If you have a <a href="tutorials/production/../../documentation/commands/keys/index.html#key-seed-file-private-key">key-seed file</a>, use the commands :
<pre><code class="language-shell">hermes keys add --chain cosmoshub-4 --key-file key_file_hub.json

hermes keys add --chain osmosis-1 --key-file key_file_osmosis.json

</code></pre>
</li>
</ul>
<blockquote>
<p><strong>NOTE</strong>: Do not confuse the <code>chain-name</code> and the <code>chain-id</code> which follows the format <code>chain_name-version</code>.</p>
</blockquote>
<ul>
<li>If you have a <code>mnemonic</code>, you can restore a private key from a <a href="tutorials/production/../../documentation/commands/keys/index.html#restore-a-private-key-to-A_CHAIN_ID-from-a-mnemonic">mnemonic-file</a>. The following steps create a <code>mnemonic-file</code> and restore its key for each chain under names <code>keyhub</code> and <code>keyosmosis</code> :
<pre><code class="language-shell">echo word1 ... word12or24 &gt; mnemonic_file_hub
hermes keys add --key-name keyhub --chain cosmoshub-4 --mnemonic-file mnemonic_file_hub.json

rm mnemonic_file_hub
echo word1 ... word12or24 &gt; mnemonic_file_osmosis
hermes keys add --key-name keyosmosis --chain osmosis-1 --mnemonic-file mnemonic_file_osmosis.json

rm mnemonic_file_osmosis
</code></pre>
</li>
</ul>
<h2 id="configuration-file-1"><a class="header" href="#configuration-file-1">Configuration file</a></h2>
<p>Then, you need to create a configuration file for Hermes (more details in the <a href="tutorials/production/../../documentation/configuration/index.html">documentation</a>).</p>
<p>The command <code>hermes config auto</code> provides a way to automatically generate a configuration file for chains in the <a href="https://github.com/cosmos/chain-registry">chain-registry</a>:</p>
<pre><code class="language-shell">hermes config auto --output $HOME/.hermes/config.toml --chain cosmoshub:keyhub osmosis:keyosmosis --chain 

</code></pre>
<blockquote>
<p><strong>NOTE</strong>: This command also automatically finds IBC paths and generates packet filters from the <a href="https://github.com/cosmos/chain-registry/tree/master/_IBC">_IBC</a> folder in the chain-registry.</p>
</blockquote>
<p>If the command runs successfully, it should output:</p>
<pre><code>2022-08-26T11:40:35.164371Z  INFO ThreadId(01) using default configuration from '$HOME/.hermes/config.toml'
2022-08-26T11:40:35.165353Z  INFO ThreadId(01) Fetching configuration for chains: ["cosmoshub", "osmosis"]
2022-08-26T11:40:36.253328Z  WARN ThreadId(01) cosmoshub-4: uses key "keyhub"
2022-08-26T11:40:36.253704Z  WARN ThreadId(01) osmosis-1: uses key "keyosmosis"
2022-08-26T11:40:36.253860Z  WARN ThreadId(01) Gas parameters are set to default values.
SUCCESS "Config file written successfully : $HOME/.hermes/config.toml."
</code></pre>
<p>And generate the following configuration :</p>
<p><strong>config.toml</strong></p>
<pre><code class="language-toml">[global]
log_level = 'info'
[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = false

[mode.channels]
enabled = false

[mode.packets]
enabled = true
clear_interval = 100
clear_on_start = true
tx_confirmation = false

[rest]
enabled = false
host = '127.0.0.1'
port = 3000

[telemetry]
enabled = false
host = '127.0.0.1'
port = 3001

[[chains]]
id = 'cosmoshub-4'
type = 'CosmosSdk'
rpc_addr = 'https://rpc.cosmoshub.strange.love/'
event_source = { mode = 'push', url = 'wss://rpc.cosmoshub.strange.love/websocket', batch_delay = '500ms' }
grpc_addr = 'https://grpc-cosmoshub-ia.notional.ventures/'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'keyhub'
key_store_type = 'Test'
store_prefix = 'ibc'
default_gas = 100000
max_gas = 400000
gas_multiplier = 1.1
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
memo_prefix = ''
sequential_batch_tx = false

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[chains.gas_price]
price = 0.1
denom = 'uatom'

[chains.packet_filter]
policy = 'allow'
list = [[
    'transfer',
    'channel-141',
]]

[chains.address_type]
derivation = 'cosmos'

[[chains]]
id = 'osmosis-1'
type = 'CosmosSdk'
rpc_addr = 'https://rpc.osmosis.interbloc.org/'
event_source = { mode = 'push', url = 'wss://rpc.osmosis.interbloc.org/websocket', batch_delay = '500ms' }
grpc_addr = 'https://grpc-osmosis-ia.notional.ventures/'
rpc_timeout = '10s'
account_prefix = 'osmo'
key_name = 'keyosmosis'
key_store_type = 'Test'
store_prefix = 'ibc'
default_gas = 100000
max_gas = 400000
gas_multiplier = 1.1
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
memo_prefix = ''
sequential_batch_tx = false

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[chains.gas_price]
price = 0.1
denom = 'uosmo'

[chains.packet_filter]
policy = 'allow'
list = [[
    'transfer',
    'channel-0',
]]

[chains.address_type]
derivation = 'cosmos'
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: You might not have the same RPC and gRPC endpoints in your configuration file as they are randomly selected in the chain-registry.</p>
</blockquote>
<p>The command created packet filters so Hermes will only relay on <code>channel-0</code> for <code>osmosis-1</code> and <code>channel-141</code> for <code>cosmoshub-4</code>. It uses RPC and gRPC endpoints found in the chain registry. If you also run a full node, you can replace the endpoints with your own. It has many advantages as you can accept transactions with lower gas.</p>
<blockquote>
<p><strong>WARNING</strong>: It is difficult to estimate how much gas you will spend as it depends on many parameters like:</p>
<ul>
<li>The volume of transactions. More congestion means higher gas prices.</li>
<li>The transaction's size. Bigger transactions need more gas.</li>
<li>The volume of IBC messages to relay.</li>
</ul>
<p>We cannot provide a way to precisely set those parameters. However, you can refer to <a href="https://github.com/informalsystems/hermes/discussions/2472#discussioncomment-3331695">other operators' configuration</a>. You can also find IBC transfers on <a href="https://www.mintscan.io/cosmos/txs">mintscan.io</a> to observe how much other operators are spending. But remember that if the gas wanted is too low, the transactions will fail. If the gas price is too high gas will be wasted, but the transactions will have a higher priority.</p>
</blockquote>
<p>For the tutorial, we will follow the <a href="https://github.com/notional-labs/notional/blob/master/relaying/hermes/all-ibc.toml">example of Crypto Crew</a> and set the gas parameters as follows.</p>
<ul>
<li>For Cosmoshub:</li>
</ul>
<pre><code class="language-toml">default_gas = 2000000
max_gas = 10000000
gas_multiplier = 1.1
max_msg_num = 25
# ...
[chains.gas_price]
price = 0.005
denom = 'uatom'
</code></pre>
<ul>
<li>For Osmosis:</li>
</ul>
<pre><code class="language-toml">default_gas = 5000000
max_gas = 15000000
gas_multiplier = 1.1
max_msg_num = 20
# ...
[chains.gas_price]
price = 0.0026
denom = 'uosmo'
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: <code>max_msg_nums</code> defines the number of messages that can be sent in the same transaction.</p>
</blockquote>
<blockquote>
<p><strong>DISCLAIMER</strong>: These parameters need to be tuned. We can not guarantee that they will always work and kept up to date.</p>
</blockquote>
<h2 id="health-check"><a class="header" href="#health-check">Health-check</a></h2>
<p>Finally, perform a <code>health-check</code> to verify that your setup is correct with:</p>
<pre><code class="language-shell">hermes health-check

</code></pre>
<p>If the command runs successfully, it should output:</p>
<pre><code>2022-08-26T15:54:21.321683Z  INFO ThreadId(01) using default configuration from '$HOME/.hermes/config.toml'
2022-08-26T15:54:21.321882Z  INFO ThreadId(01) [cosmoshub-4] performing health check...
2022-08-26T15:54:22.909339Z  WARN ThreadId(01) chain is healthy chain=cosmoshub-4
2022-08-26T15:54:22.909374Z  INFO ThreadId(01) [osmosis-1] performing health check...
2022-08-26T15:54:23.954362Z  INFO ThreadId(01) chain is healthy chain=osmosis-1
SUCCESS performed health check for all chains in the config
</code></pre>
<blockquote>
<p><strong>WARNING</strong>: In the previous tutorials, after setting up Hermes, we started by creating a new relay path. In production, the relay path most likely already exists and does not need to be created. <strong>Do not create channels between the Hub and Osmosis.</strong></p>
</blockquote>
<hr />
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next steps</a></h2>
<p>You are now ready to relay. In the <a href="tutorials/production/./start-relaying.html">next chapter</a>, you will start relaying and monitoring Hermes with Grafana.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="start-relaying-3"><a class="header" href="#start-relaying-3">Start relaying</a></h1>
<p>In section <a href="tutorials/production/./setup-grafana.html">Setup Grafana</a>, you did set up a Grafana dashboard which is now waiting to receive data produced by <code>hermes</code> and running on port 3000. You also configured Hermes in section <a href="tutorials/production/./setup-hermes.html">Setup Hermes</a> and added the keys you will be using.</p>
<hr />
<h2 id="create-an-empty-log-file"><a class="header" href="#create-an-empty-log-file">Create an empty log file</a></h2>
<p>Promtail is shipping every log file from <code>/var/log</code> to Loki. Follow the steps below to create an empty log file for Hermes:</p>
<pre><code class="language-shell">sudo touch /var/log/hermes.log 
sudo chown $(whoami) /var/log/hermes.log 
</code></pre>
<p>You should now have an empty <code>hermes.log</code> file that you can access and see on the Grafana Dashboard, on the <code>explore</code> page, if you select Loki as a data source. You can query the label <code>filename=hermes.log</code>.</p>
<h2 id="start-relaying-4"><a class="header" href="#start-relaying-4">Start relaying</a></h2>
<p>Follow the steps to get started :</p>
<ul>
<li>
<p>Open your dashboard. Make sure it gets refreshed every 5s.</p>
</li>
<li>
<p>In a new terminal, run <code>hermes start  &amp;&gt; hermes.log</code>.</p>
</li>
</ul>
<p>If the command runs successfully, you should be able to see the metrics panels displaying data on the Grafana Dashboard and you should also be able to see the logs on the <code>Logs</code> panel at the top of the dashboard. You can also explore them on the <code>explore</code> page.</p>
<p>You can now inspect the logs to verify whether the gas parameters are set correctly and tune them as possible. However, remember to restart Hermes when you modify the configuration.</p>
<p>Finally, Hermes is designed to relay without any intervention, however, you might have to manually trigger <code>hermes clear packets</code> to clear outstanding packets that Hermes failed to relay.</p>
<blockquote>
<p><strong>NOTE</strong>: It is not possible to share a wallet between two instances of Hermes.</p>
</blockquote>
<hr />
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next steps</a></h2>
<p>Visit the <a href="tutorials/production/../../documentation/telemetry/index.html">Telemetry</a> section to learn how to use the metrics and the <a href="tutorials/production/../../advanced/index.html">Advanced</a> section to learn about Hermes' features and general guidelines for troubleshooting.</p>
<p>You can also learn more about <a href="https://grafana.com/tutorials/grafana-fundamentals/">Grafana's features</a> and learn how to create a <a href="https://grafana.com/docs/grafana/latest/alerting/alerting-rules/create-grafana-managed-rule/">Grafana Managed Alert</a>.</p>
<blockquote>
<p><strong>NOTE</strong>: In the future, Hermes might implement functionalities to trigger the commands through a REST API. It might become possible to manipulate the relayer through Grafana Alerts.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>This section includes everything you need to know to configure Hermes.</p>
<hr />
<h2 id="sections-6"><a class="header" href="#sections-6">Sections</a></h2>
<ul>
<li>
<p><strong><a href="documentation/configuration/./configure-hermes.html">Configure Hermes</a></strong></p>
<ul>
<li>Learn how to configure Hermes and some supported features.</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/configuration/./description.html">Description of the parameters</a></strong></p>
<ul>
<li>Detailed description of every parameter of Hermes</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/configuration/./filter-incentivized.html">Filter incentivized packets</a></strong></p>
<ul>
<li>Examples on how to configure Hermes in order to filter incentivized packets</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/configuration/./packet-clearing.html">Packet clearing</a></strong></p>
<ul>
<li>Description on packet clearing configurations</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><strong><a href="documentation/configuration/./performance.html">Performance Tuning</a></strong></p>
<ul>
<li>Learn about configurations allowing more refined performance tuning.</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/configuration/./comet-compat-mode.html">CometBFT Compatibility modes</a></strong></p>
<ul>
<li>Handle different CometBFT compatibility modes.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cometbft-compatibility-modes"><a class="header" href="#cometbft-compatibility-modes">CometBFT Compatibility modes</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>There are two different compatibility modes for CometBFT, one for version v0.34 and one for versions v0.37 and v0.38. In order to verify the compatibility used Hermes queries the node's <code>/status</code> endpoint, which contains the CometBFT version used. This can be an issue if a chain uses a custom version which does not output the version string Hermes expects. To still be able to relay for these chains a configuration can be set in Hermes.</p>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>The configuration is set per chain and can take two values <code>0.34</code> and <code>0.37</code>, other values will be invalid:</p>
<pre><code class="language-toml">[[chains]]
...
compat_mode = '0.34'
</code></pre>
<p>Hermes will act in the following way whether or not the configuration is set:</p>
<ul>
<li><code>compat_mode</code> is specified and the version queried from <code>/status</code> is the same as the one configured: Use that version without log output</li>
<li><code>compat_mode</code> is specified but the version queried from <code>/status</code> differs: The compatibility mode configured is used, but a warning log is outputted</li>
<li><code>compat_mode</code> is not specified but /status returns a correct version: The compatibility mode  retrieved from the endpoint is used</li>
<li><code>compat_mode</code> is not specified and /status does not return a valid version: Hermes stops and outputs an error informing the user that the <code>compat_mode</code> needs to be configured</li>
</ul>
<p>The configuration can also be found in the example <a href="https://github.com/informalsystems/hermes/blob/v1.13.2/config.toml#382">config.toml</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configure-hermes"><a class="header" href="#configure-hermes">Configure Hermes</a></h1>
<p>In order to run Hermes, you will need to have a configuration file.</p>
<p>The format supported for the configuration file is <a href="https://toml.io/en/">TOML</a>.</p>
<p>By default, Hermes expects the configuration file to be located at <code>$HOME/.hermes/config.toml</code>.</p>
<p>This can be overridden by supplying the <code>--config</code> flag when invoking <code>hermes</code>, before the
name of the command to run, e.g. <code>hermes --config my_config.toml query connection channels --chain ibc-1 --connection connection-1</code>.</p>
<blockquote>
<p>The current version of Hermes does not support managing the configuration file programmatically.
You will need to use a text editor to create the file and add content to it.</p>
</blockquote>
<pre><code class="language-bash">hermes [--config CONFIG_FILE] COMMAND
</code></pre>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="documentation/configuration/configure-hermes.html#configuration">Configuration</a>
<ul>
<li><a href="documentation/configuration/configure-hermes.html#automatically-generating-a-config-file">Automatically Generating A Config File</a></li>
<li><a href="documentation/configuration/configure-hermes.html#tips-for-manually-configuring-hermes">Tips for Manually Configuring Hermes</a></li>
</ul>
</li>
<li><a href="documentation/configuration/configure-hermes.html#adding-private-keys">Adding Private Keys</a></li>
<li><a href="documentation/configuration/configure-hermes.html#connecting-via-tls">Connecting via TLS</a></li>
<li><a href="documentation/configuration/configure-hermes.html#configuring-support-for-interchain-accounts">Configuring Support for Interchain Accounts</a></li>
<li><a href="documentation/configuration/configure-hermes.html#configuring-support-for-consumer-chains-that-utilize-cross-chain-validation">Configuring Support for Consumer Chains that Utilize Cross-Chain Validation</a></li>
<li><a href="documentation/configuration/configure-hermes.html#connecting-to-a-full-node-protected-by-http-basic-authentication">Connecting to a full node protected by HTTP Basic Authentication</a></li>
<li><a href="documentation/configuration/configure-hermes.html#configuring-support-for-wasm-relaying">Configuring Support for Wasm Relaying</a></li>
</ul>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<h3 id="automatically-generating-a-config-file"><a class="header" href="#automatically-generating-a-config-file">Automatically Generating A Config File</a></h3>
<p>The simplest way to configure Hermes for a given chain is by running the command</p>
<pre><code class="language-shell">hermes config auto --output ~/&lt;OUTPUT_PATH&gt;/config.toml --chain &lt;CHAIN_1&gt; &lt;CHAIN_2&gt; --chain 

</code></pre>
<p>This will generate a <code>config.toml</code> file for some specified chains. Note, however, that the configuration is generated by pulling the chain data from the Cosmos <a href="https://github.com/cosmos/chain-registry">chain registry</a>. The specified chain(s) must exist in the registry for the command to work. Check out <a href="documentation/configuration/../commands/config.html#automatically-generate-configuration-files-for-specified-chains">this</a> section of the Hermes commands reference to find more information on the <code>config auto</code> command.</p>
<h3 id="tips-for-manually-configuring-hermes"><a class="header" href="#tips-for-manually-configuring-hermes">Tips for Manually Configuring Hermes</a></h3>
<p>For relaying use-cases that require some more bespoke configuration, you'll have to manually edit the <code>config.toml</code> file. The following are some rules of thumb to follow when manually configuring Hermes.</p>
<p>The configuration file must have one <code>global</code> section, and one <code>chains</code> section for each chain.</p>
<!-- markdown-link-check-disable -->
<blockquote>
<p><strong>Note:</strong> As of 0.6.0, the Hermes configuration file is self-documented.
Please read the configuration file <a href="https://github.com/informalsystems/hermes/blob/v1.13.2/config.toml"><code>config.toml</code></a>
itself for the most up-to-date documentation of parameters.</p>
</blockquote>
<p>By default, Hermes will relay on all channels available between all the configured chains.
In this way, every configured chain will act as a source (in the sense that Hermes listens for events)
and as a destination (to relay packets that others chains have sent).</p>
<p>For example, if there are only two chains configured, then Hermes will only relay packets between those two,
i.e. the two chains will serve as a source for each other, and likewise as a destination for each other's relevant events.
Hermes will ignore all events that pertain to chains which are unknown (i.e. not present in config.toml).</p>
<p>To restrict relaying on specific channels, or uni-directionally, you can use <a href="https://github.com/informalsystems/hermes/blob/v1.13.2/config.toml#L209-L231">packet filtering policies</a>.</p>
<p>Check out the example <a href="https://github.com/informalsystems/hermes/blob/master/config.toml">config.toml</a> file in the Hermes repo to see how the different parameters can be configured.</p>
<!-- markdown-link-check-enabled -->
<h2 id="adding-private-keys"><a class="header" href="#adding-private-keys">Adding Private Keys</a></h2>
<p>For each chain configured you need to add a private key for that chain in order to submit <a href="documentation/configuration/../commands/tx/index.html">transactions</a>,
please refer to the <a href="documentation/configuration/../commands/keys/index.html">Keys</a> sections in order to learn how to add the private keys that are used by Hermes.</p>
<h2 id="connecting-via-tls"><a class="header" href="#connecting-via-tls">Connecting via TLS</a></h2>
<p>Hermes supports connection via TLS for use-cases such as connecting from behind
a proxy or a load balancer. In order to enable this, you'll want to set the
<code>rpc_addr</code>, <code>grpc_addr</code>, or <code>event_source</code> parameters to specify a TLS
connection via HTTPS using the following scheme (note that the port number 443
is just used for example):</p>
<pre><code>rpc_addr = 'https://domain.com:443'
grpc_addr = 'https://domain.com:443'
event_source = { mode = 'push', url = 'wss://domain.com:443/websocket', batch_delay = '500ms' }
</code></pre>
<h2 id="configuring-support-for-interchain-accounts"><a class="header" href="#configuring-support-for-interchain-accounts">Configuring Support for Interchain Accounts</a></h2>
<p>As of version 0.13.0, Hermes supports relaying on <a href="https://github.com/cosmos/ibc/blob/master/spec/app/ics-027-interchain-accounts/README.md">Interchain Accounts</a> channels.</p>
<p>If the <code>packet_filter</code> option in the chain configuration is disabled, then
Hermes will relay on all existing and future channels, including ICA channels.</p>
<p>There are two kinds of ICA channels:</p>
<ol>
<li>The host channels, whose port is <code>icahost</code></li>
<li>The controller channels, whose port starts with <code>icacontroller-</code> followed
by the owner account address. <a href="https://github.com/cosmos/ibc/blob/master/spec/app/ics-027-interchain-accounts/README.md">See the spec for more details</a>.</li>
</ol>
<p>If you wish to only relay on a few specific standard channels (here <code>channel-0</code> and <code>channel-1</code>),
but also relay on all ICA channels, you can specify the following packet filter:</p>
<blockquote>
<p>Note the use of wildcards in the port and channel identifiers (<code>['ica*', '*']</code>)
to match over all the possible ICA ports.</p>
</blockquote>
<pre><code class="language-toml">[chains.packet_filter]
policy = 'allow'
list = [
  ['ica*', '*'], # allow relaying on all channels whose port starts with `ica`
  ['transfer', 'channel-0'],
  ['transfer', 'channel-1'],
  # Add any other port/channel pairs you wish to relay on
]
</code></pre>
<p>If you wish to relay on all channels but not on ICA channels, you can use
the following packet filter configuration:</p>
<pre><code class="language-toml">[chains.packet_filter]
policy = 'deny'
list = [
  ['ica*', '*'], # deny relaying on all channels whose port starts with `ica`
]
</code></pre>
<h2 id="configuring-support-for-consumer-chains-that-utilize-cross-chain-validation"><a class="header" href="#configuring-support-for-consumer-chains-that-utilize-cross-chain-validation">Configuring Support for Consumer Chains that Utilize Cross-Chain Validation</a></h2>
<p>As of version 1.4.1, Hermes supports relaying for consumer chains that utilize <a href="https://github.com/cosmos/ibc/blob/main/spec/app/ics-028-cross-chain-validation/README.md">cross-chain validation</a> (CCV).</p>
<blockquote>
<p><strong>Note:</strong> A consumer chain is essentially a regular Cosmos-SDK based chain that uses the interchain security
module to achieve economic security by stake deposited on a provider chain instead of on the consumer chain
itself. Consumer chains are bound to their provider chains by the provider's validator set. By being bound
together in this way, consumer chains inherit the economic security guarantees of the provider chain.</p>
<p>You can read more about consumer chains, and Interchain Security more generally, at <a href="https://cosmos.github.io/interchain-security">https://cosmos.github.io/interchain-security</a>.</p>
</blockquote>
<p>If you are configuring Hermes in order to relay for a consumer chain, set <code>ccv_consumer_chain = true</code> under its <code>[[chains]]</code> section in the <code>config.toml</code> file.
By default, this option is set to <code>false</code>. It should <em>ONLY</em> be toggled on for CCV consumer chains, <em>NOT</em> for sovereign chains.</p>
<p>This parameter is required because consumer chains do not utilize the same staking module as sovereign chains.
Consumer chains must query a different gRPC endpoint in order to fetch the relevant <code>ccvconsumer</code> parameters that Hermes
needs in order to relay on behalf of consumer chains.</p>
<h2 id="connecting-to-a-full-node-protected-by-http-basic-authentication"><a class="header" href="#connecting-to-a-full-node-protected-by-http-basic-authentication">Connecting to a full node protected by HTTP Basic Authentication</a></h2>
<p>To connect to a full node protected by <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication">HTTP Basic Authentication</a>,
specify the username and password in the <code>rpc_addr</code> and <code>event_source</code> settings
under the chain configuration in <code>config.toml</code>.</p>
<p>Here is an example with username <code>hello</code> and password <code>world</code>, assuming the RPC, WebSocket and gRPC servers
listen on domain <code>mydomain.com</code> with TLS enabled (HTTPS/WSS).</p>
<pre><code class="language-toml">[[chains]]
id = 'my-chain-0'

# ...

rpc_addr = 'https://hello:world@mydomain.com:26657'
event_source = { mode = 'push', url = 'wss://hello:world@mydomain.com:26657/websocket', batch_delay = '500ms' }

# ...
</code></pre>
<blockquote>
<p><strong>Caution:</strong> The "Basic" authentication scheme sends the credentials encoded but not encrypted.
This would be completely insecure unless the exchange was over a secure connection (HTTPS/TLS).</p>
</blockquote>
<h2 id="configuring-support-for-wasm-relaying"><a class="header" href="#configuring-support-for-wasm-relaying">Configuring Support for Wasm Relaying</a></h2>
<p>Hermes supports the relaying of wasm messages natively. This is facilitated by configuring
Hermes to use pull-based relaying by polling for IBC events via the <code>/block_results</code> RPC endpoint. Set
the <code>event_source</code> parameter to pull mode in <code>config.toml</code> like so:</p>
<pre><code class="language-toml"># When specified like this, Hermes defaults to a poll interval of 1 second
event_source = { mode = 'pull' }
</code></pre>
<p>The default interval at which Hermes polls the RPC endpoint is 1 second. If you need to change the interval,
you can specify it like so:</p>
<pre><code class="language-toml">event_source = { mode = 'pull', interval = '2s' }
</code></pre>
<p>The pull model of relaying is in contrast with Hermes' default push model, where IBC events are received
over WebSocket.</p>
<blockquote>
<p><strong>Note:</strong> This mode should only be used in situations where Hermes misses events that it should
be receiving, such as when relaying for CosmWasm-enabled blockchains which emit IBC events without the
<code>message</code> attribute. Without this attribute, the WebSocket is not able to catch these events to stream
to Hermes, so the <code>/block_results</code> RPC endpoint must be used instead.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="description-of-the-parameters"><a class="header" href="#description-of-the-parameters">Description of the parameters</a></h1>
<p>This page provides a full example of a configuration file with two chains configured:</p>
<blockquote>
<p><strong>NOTE</strong>: Visit the <a href="documentation/configuration/../commands/relaying/index.html">Relaying</a> section to learn more about Hermes' modes.</p>
</blockquote>
<pre><code class="language-toml"># This is an example configuration for Hermes. It is meant to be
# used as a reference, _NOT_ for configuring a production relayer. 
# If you're looking to configure a production relayer for some chains, 
# try using the `hermes config auto` command to generate a config 
# file that serves as the starting point for configuring Hermes.

# The global section has parameters that apply globally to the relayer operation.
[global]

# Specify the verbosity for the relayer logging output. Default: 'info'
# Valid options are 'error', 'warn', 'info', 'debug', 'trace'.
log_level = 'debug'


# Specify the mode to be used by the relayer. [Required]
[mode]

# Specify the client mode.
[mode.clients]

# Whether or not to enable the client workers. [Required]
enabled = true

# Whether or not to enable periodic refresh of clients. [Default: true]
# This feature only applies to clients that underlie an open channel.
# For Tendermint clients, the frequency at which Hermes refreshes them is 2/3 of their
# trusting period (e.g., refresh every ~9 days if the trusting period is 14 days).
# Note: Even if this is disabled, clients will be refreshed automatically if
#      there is activity on a connection or channel they are involved with.
refresh = true

# Whether or not to enable misbehaviour detection for clients. [Default: true]
misbehaviour = true

# Specify the connections mode.
[mode.connections]

# Whether or not to enable the connection workers for handshake completion. [Required]
enabled = true

# Specify the channels mode.
[mode.channels]

# Whether or not to enable the channel workers for handshake completion. [Required]
enabled = true

# Specify the packets mode.
[mode.packets]

# Whether or not to enable the packet workers. [Required]
enabled = true

# Parametrize the periodic packet clearing feature.
# Interval (in number of blocks) at which pending packets
# should be periodically cleared. A value of '0' will disable
# periodic packet clearing. [Default: 100]
clear_interval = 100

# Whether or not to clear packets on start. [Default: true]
clear_on_start = true

# Set the maximum number of packets to clear each time packet clearing is triggered.
# [Default: 50]
#clear_limit = 50

# Toggle the transaction confirmation mechanism.
# The tx confirmation mechanism periodically queries the `/tx_search` RPC
# endpoint to check that previously-submitted transactions
# (to any chain in this config file) have been successfully delivered.
# If they have not been, and `clear_interval = 0`, then those packets are
# queued up for re-submission.
# If set to `false`, the following telemetry metrics will be disabled:
# `acknowledgment_packets_confirmed`, `receive_packets_confirmed` and `timeout_packets_confirmed`.
# [Default: false]
tx_confirmation = false

# Auto register the counterparty payee on a destination chain to
# the relayer's address on the source chain. This can be used
# for simple configuration of the relayer to receive fees for
# relaying RecvPacket on fee-enabled channels.
# For more complex configuration, turn this off and use the CLI
# to manually register the payee addresses.
# [Default: false]
auto_register_counterparty_payee = false

# Set the maximum size for the memo field in ICS20 packets.
# If the size of the memo field is bigger than the configured
# one, the packet will not be relayed.
# The filter can be disabled by setting `enabled = false`.
# [Default: "32KiB"]
#ics20_max_memo_size = { enabled = true, size = "32KiB" }

# Set the maximum size for the receiver field in ICS20 packets.
# If the size of the receiver field is bigger than the configured
# one, the packet will not be relayed.
# The filter can be disabled by setting `enabled = false`.
# [Default: "2KiB"]
#ics20_max_receiver_size = { enabled = true, size = "2KiB" }

# The REST section defines parameters for Hermes' built-in RESTful API.
# https://hermes.informal.systems/rest.html
[rest]

# Whether or not to enable the REST service. Default: false
enabled = false

# Specify the IPv4/6 host over which the built-in HTTP server will serve the RESTful
# API requests. Default: 127.0.0.1
host = '127.0.0.1'

# Specify the port over which the built-in HTTP server will serve the restful API
# requests. Default: 3000
port = 3000


# The telemetry section defines parameters for Hermes' built-in telemetry capabilities.
# https://hermes.informal.systems/telemetry.html
[telemetry]

# Whether or not to enable the telemetry service. Default: false
enabled = false

# Specify the IPv4/6 host over which the built-in HTTP server will serve the metrics
# gathered by the telemetry service. Default: 127.0.0.1
host = '127.0.0.1'

# Specify the port over which the built-in HTTP server will serve the metrics gathered
# by the telemetry service. Default: 3001
port = 3001

# Specify the prefix used for Prometheus metrics. This configuration is optional, if
# it is missing the result is equivalent to setting it to empty string: `prefix = ""`
# For example setting `prefix = "hermes"` will result in:
#   * `hermes_acknowledgement_events_total`
#   * `hermes_wallet_balance`
#   * etc...
# The default is no prefix, which results in:
#   * `acknowledgement_events_total`
#   * `wallet_balance`
#   * etc...
# prefix = ""

[telemetry.buckets]
# Specify the range of the 10 histogram buckets in ms for the `tx_latency_submitted` metric.
# Default: { start = 500, end = 10000, buckets = 10 }
# The default will give the following buckets:
# [500, 2450, 4400, 6350, 8300, 10250, 12200, 14150, 16100, 18050, 20000]
# latency_submitted = { start = 500, end = 20000, buckets = 10 }

# Specify the range of the 10 histogram buckets in ms for the `tx_latency_confirmed` metric.
# Default: { start = 1000, end = 20000, buckets = 10 }
# The default will give the following buckets:
# [1000, 3900, 6800, 9700, 12600, 15500, 18400, 21300, 24200, 27100, 30000]
# latency_confirmed = { start = 1000, end = 30000, buckets = 10 }

# The tracing server section defines parameters for Hermes' server allowing updates to the tracing directives.
#
# https://hermes.informal.systems/advanced/troubleshooting/log-level.html#overriding-the-tracing-filter-during-runtime
[tracing_server]
# Whether or not to enable the tracing server. Default: false
enabled = false

# Specify the port over which the built-in TCP server will serve the directives. Default: 5555
port = 5555

# A chains section includes parameters related to a chain and the full node to which
# the relayer can send transactions and queries.
[[chains]]

# Specify the chain ID. Required
id = 'ibc-0'

# Specify the chain type, currently `CosmosSdk` and `Namada` are supported.
# Default: CosmosSdk
type = "CosmosSdk"

# Whether or not this is a CCV consumer chain. Default: false
# Only specify true for CCV consumer chain, but NOT for sovereign chains.
ccv_consumer_chain = false

# Specify the RPC address and port where the chain RPC server listens on. Required
rpc_addr = 'http://127.0.0.1:26657'

# Specify the GRPC address and port where the chain GRPC server listens on. Required
grpc_addr = 'http://127.0.0.1:9090'

# The type of event source to use for getting events from the chain.
#
# This setting can take two types of values, as an inline table:
# 
# a) Push: for receiving IBC events over WebSocket.
#
#      `{ mode = 'push', url = 'ws://127.0.0.1:26657/websocket', batch_delay = '500ms' }`
#
#    where
#
#    - `url` is the WebSocket URL to connect to. Required
#    - `batch_delay` is the delay until event batch is
#      emitted in the absence of NewBlock event. Default: 500ms
#      Lower values will result in faster event processing, improving the latency of Hermes,
#      but may split the events into more batches than necessary, requiring more client updates
#      to be submitted, yielding higher costs. Higher values will result in slower event
#      processing, increasing the latency of Hermes, but are more likely to batch events together.
#      The default value provides good latency while minimizing the number of client updates needed.

# b) Pull: for polling for IBC events via the `/block_results` RPC endpoint.
#
#     `{ mode = 'pull', interval = '1s', max_retries = 4 }`
#
#    where
#
#    - `interval` is the interval at which to poll for blocks. Default: 1s
#    - `max_retries` is the maximum number of retries to collect events for each block. Default: 4
#
#    This mode should only be used in situations where Hermes misses events that it should be
#    receiving, such as when relaying for CosmWasm-enabled chains which emit IBC events without
#    the `message` attribute. Without this attribute, the WebSocket is not able to catch these
#    events, so the `/block_results` RPC must be used instead.
#
event_source = { mode = 'push', url = 'ws://127.0.0.1:26657/websocket', batch_delay = '500ms' }

# Specify the maximum amount of time (duration) that the RPC requests should
# take before timing out. Default: 10s (10 seconds)
# Note: Hermes uses this parameter _only_ in `start` mode; for all other CLIs,
# Hermes uses a large preconfigured timeout (on the order of minutes).
rpc_timeout = '10s'

# Experimental: Whether or not the full node is trusted.
#
# If not trusted, Hermes will verify headers included in the `ClientUpdate` message using the light client.
#
# Note: If the full node is configured as trusted then, in addition to headers not being verified,
#       the verification traces will not be provided.
#       This may cause failure in client updates after significant change in validator sets.
#
# Default: false
trusted_node = false

# Specify the prefix used by the chain. Required
account_prefix = 'cosmos'

# Specify the name of the private key to use for signing transactions. Required
# See the Adding Keys chapter for more information about managing signing keys:
#   https://hermes.informal.systems/documentation/commands/keys/index.html#adding-keys
key_name = 'testkey'

# Specify the folder used to store the keys. Optional
# If this is not specified then the hermes home folder is used.
# key_store_folder = '$HOME/.hermes/keys'

# Specify the address type which determines:
# 1) address derivation;
# 2) how to retrieve and decode accounts and pubkeys;
# 3) the message signing method.
# The current configuration options are for Cosmos SDK and Ethermint.
#
# Example configuration for chains based on Ethermint library:
#
# address_type = { derivation = 'ethermint', proto_type = { pk_type = '/ethermint.crypto.v1.ethsecp256k1.PubKey' } }
#
# Default: { derivation = 'cosmos' }, i.e. address derivation as in Cosmos SDK.
# Warning: This is an advanced feature! Modify with caution.
address_type = { derivation = 'cosmos' }

# Specify the store prefix used by the on-chain IBC modules. Required
# Recommended value for Cosmos SDK: 'ibc'
store_prefix = 'ibc'

# Gas Parameters
# 
# The term 'gas' is used to denote the amount of computation needed to execute
# and validate a transaction on-chain. It can be thought of as fuel that gets 
# spent in order to power the on-chain execution of a transaction.
#
# Hermes attempts to simulate how much gas a transaction will expend on its 
# target chain. From that, it calculates the cost of that gas by multiplying the
# amount of estimated gas by the `gas_multiplier` and the `gas_price`
# (estimated gas * `gas_multiplier` * `gas_price`) in order to compute the 
# total fee to be deducted from the relayer's wallet.
# 
# The `simulate_tx` operation does not always correctly estimate the appropriate
# amount of gas that a transaction requires. In those cases when the operation 
# fails, Hermes will attempt to submit the transaction using the specified 
# `default_gas` and `max_gas` parameters. In the case that a transaction would 
# require more than `max_gas`, it doesn't get submitted and a 
# `TxSimulateGasEstimateExceeded` error is returned.

# Specify the default amount of gas to be used in case the tx simulation fails,
# and Hermes cannot estimate the amount of gas needed.
# Default: 100 000
default_gas = 100000

# Specify the maximum amount of gas to be used as the gas limit for a transaction.
# If `default_gas` is unspecified, then `max_gas` will be used as `default_gas`.
# Default: 400 000
max_gas = 4000000

# Specify the price per gas used of the fee to submit a transaction and
# the denomination of the fee. 
# 
# The specified gas price should always be greater or equal to the `min-gas-price`
# configured on the chain. This is to ensure that at least some minimal price is 
# paid for each unit of gas per transaction.
# 
# Required
gas_price = { price = 0.025, denom = 'stake' }

# Multiply this amount with the gas estimate, used to compute the fee
# and account for potential estimation error.
#
# The purpose of multiplying by `gas_multiplier` is to provide a bit of a buffer
# to catch some of the cases when the gas estimation calculation is on the low
# end. 
# 
# Example: With this setting set to 1.1, then if the estimated gas
# is 80_000, then gas used to compute the fee will be adjusted to
# 80_000 * 1.1 = 88_000.
#
# Default: 1.1, ie. the gas is increased by 10%
# Minimum value: 1.0
gas_multiplier = 1.1

# Query the current gas price from the chain instead of using the static `gas_price` from the config.
# Useful for chains which have [EIP-1559][eip]-like dynamic gas price. 
#
# At the moment, only chains which support the `osmosis.txfees.v1beta1.Query/GetEipBaseFee`
# query or have enabled Skip's `x/feemarket` module https://github.com/skip-mev/feemarket
# can be used with dynamic gas price enabled.
#
# See this page in the Hermes guide for more information:
# https://hermes.informal.systems/documentation/configuration/dynamic-gas-fees.html
# 
# Default: { enabled = false, multiplier = 1.1, max = 0.6 }
dynamic_gas_price = { enabled = false, multiplier = 1.1, max = 0.6 }

# Specify how many IBC messages at most to include in a single transaction.
# Default: 30
max_msg_num = 30

# Specify the maximum size, in bytes, of each transaction that Hermes will submit.
# Default: 2097152 (2 MiB)
max_tx_size = 2097152

# How many packets to fetch at once from the chain when clearing packets.
# Default: 50
query_packets_chunk_size = 50

# Specify the maximum amount of time to tolerate a clock drift.
# The clock drift parameter defines how much new (untrusted) header's time
# can drift into the future. Default: 5s
clock_drift = '5s'

# Specify the fallback value for the maximum time per block for this chain.
# The block time together with the clock drift are added to the source drift to estimate
# the maximum clock drift when creating a client on this chain. Default: 30s
# When validating the configuration, Hermes will query the /genesis RPC endpoint in order
# to retrieve the `max_expected_time_per_block` and use it as the `max_block_time`.
# If the query fails, the configured `max_block_time` is used instead.
# For cosmos-SDK chains a good approximation is `timeout_propose` + `timeout_commit`
# Note: This MUST be the same as the `max_expected_time_per_block` genesis parameter for Tendermint chains.
max_block_time = '30s'

# Specify the amount of time to be used as the light client trusting period.
# It should be significantly less than the unbonding period
# (e.g. unbonding period = 3 weeks, trusting period = 2 weeks).
#
# Default: 2/3 of the `unbonding period` for Cosmos SDK chains
trusting_period = '14days'

# The rate at which to refresh the client referencing this chain,
# expressed as a fraction of the trusting period.
#
# Default: 1/3 (ie. three times per trusting period)
client_refresh_rate = '1/3'

# Specify the trust threshold for the light client, ie. the minimum fraction of validators
# which must overlap across two blocks during light client verification.
#
# Warning: This is an advanced feature! Modify with caution.
#
# Default: 2/3
trust_threshold = '2/3'

# Specify a string that Hermes will use as a memo for each transaction it submits
# to this chain. The string is limited to 50 characters. Default: '' (empty).
# Note: Hermes will append to the string defined here additional
# operational debugging information, e.g., relayer build version.
memo_prefix = ''

# If this is set to a string, it will overwrite the memo used by Hermes for each transaction
# it submits to this chain.
# Default: not set.
# This is used for chains which have a very small character limit for the memo,
# and the additional information appended by Hermes would overflow that limit.
# memo_overwrite = ''

# This section specifies the filters for policy based relaying.
#
# Default: no policy / filters, allow all packets on all channels.
#
# Only packet filtering based on channel identifier can be specified.
# A channel filter has two fields:
# 1. `policy` - one of two types are supported:
#       - 'allow': permit relaying _only on_ the port/channel id in the list below,
#       - 'deny': permit relaying on any channel _except for_ the list below.
# 2. `list` - the list of channels specified by the port and channel identifiers.
#             Optionally, each element may also contains wildcards, for eg. 'ica*'
#             to match all identifiers starting with 'ica' or '*' to match all identifiers.
#
# Example configuration of a channel filter, only allowing packet relaying on
# channel with port ID 'transfer' and channel ID 'channel-0', as well as on
# all ICA channels.
#
# [chains.packet_filter]
# policy = 'allow'
# list = [
#   ['ica*', '*'],
#   ['transfer', 'channel-0'],
# ]

# This section specifies the filters for incentivized packet relaying.
# Default: no filters, will relay all packets even if they
# are not incentivized.
#
# It is possible to specify the channel or use wildcards for the
# channels.
# The only fee which can be parametrized is the `recv_fee`.
#
# Example configuration of a filter which will only relay incentivized
# packets, with no regards for channel and amount.
#
# [chains.packet_filter.min_fees.'*']
# recv = [ { amount = 0 } ]
#
# Example configuration of a filter which will only relay packets if they are
# from the channel 'channel-0', and they have a `recv_fee` of at least 20 stake
# or 10 uatom.
#
# [chains.packet_filter.min_fees.'channel-0']
# recv = [ { amount = 20, denom = 'stake' }, { amount = 10, denom = 'uatom' } ]

# Specify that the transaction fees should be paid from this fee granter's account.
# Optional. If unspecified (the default behavior), then no fee granter is used, and
# the account specified in `key_name` will pay the tx fees for all transactions
# submitted to this chain.
# fee_granter = ''

# Specify the CometBFT compatibility mode to use.
# The following behaviours are applied whether the `compat_mode` is configured or not:
#   * compat_mode is specified and the version queried from /status is the same as the one configured: Use that version without log output
#   * compat_mode is specified but the version queried from /status differs: The CompatMode configured is used, but a warning log is outputted
#   * compat_mode is not specified but /status returns a correct version: The CompatMode retrieved from the endpoint is used
#   * compat_mode is not specified and /status does not return a valid version: Hermes stops and outputs an error informing the user a compat_mode needs to be configured
# Possible values: [`0.34`, `0.37`]
# compat_mode = '0.34'

# Specify the a clear interval for the chain.
# This will override the global clear interval for this chain only, allowing different intervals for each chain.
# clear_interval = 50

# Specify packet sequences which should not be cleared, per channel.
#
# For each channel, specify a list of sequences which should not be cleared. Acceptable value
# include range of sequences with separator "-", eg.
#
#   [chains.excluded_sequences]
#   channel-0 = [1, 2, "3-7", 9, 11],
#   channel-1 = [4, 5, 6],
#
# Default: No filter
# excluded_sequences = {}

# Enable or disable relaying of ICS31 Cross Chain Query packets.
# If this configuration is set to false, Hermes will skip ICS31
# Cross Chain Query packets.
#
# Default: true
# allow_ccq = true

[[chains]]
id = 'ibc-1'
rpc_addr = 'http://127.0.0.1:26557'
grpc_addr = 'http://127.0.0.1:9091'
event_source = { mode = 'push', url = 'ws://127.0.0.1:26557/websocket', batch_delay = '500ms' }
rpc_timeout = '10s'
trusted_node = false
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
default_gas = 100000
max_gas = 4000000
gas_price = { price = 0.025, denom = 'stake' }
gas_multiplier = 1.1
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = '2/3'
address_type = { derivation = 'cosmos' }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-gas-fees"><a class="header" href="#dynamic-gas-fees">Dynamic Gas Fees</a></h1>
<p>Some chains use a dynamic gas price system instead of static gas price. By configuring the <code>dynamic_gas_price</code> for those chains, Hermes will query the gas price and apply the configured multiplier instead of using the configured static gas price:</p>
<pre><code class="language-toml">...
[&lt;chain_id&gt;.dynamic_gas_price]
enabled = true
multiplier = 1.1
max = 0.6
...
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>If the query fails, Hermes will fallback to the configured static gas price.</li>
<li>If the queried gas price is higher than the maximum configured gas price, Hermes will use the maximum gas price but this might cause the relaying of the packet to fail due to insufficient fees.</li>
</ul>
<h2 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h2>
<p>As this feature can be delicate to handle, multiple metrics have been added in order to monitor the dynamic gas fees. Please consult the <a href="documentation/configuration/../telemetry/operators.html#dynamic-gas-fees">Dynamic Gas Metrics</a>  section for detailed information on these metrics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filter-incentivized-packets"><a class="header" href="#filter-incentivized-packets">Filter incentivized packets</a></h1>
<p>Hermes can be configured in order to only relay packets which are incentivized. This is done by using the <code>[[chain.packet_filter.min_fees]]</code> setting.</p>
<p>When this filter is configured, Hermes will only relay <code>send_packet</code> events when they  meet the configured requirements. This configuration can be set per channel or for a set of channels using a wildcard expression.</p>
<blockquote>
<p><strong>WARNING</strong>: This configuration is experimental. Packet clearing will be disabled for the channels which have a fee filter configured, and some <code>send_packet</code> events might not be relayed if the incentivized event is not in the same batch of events.</p>
</blockquote>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p><em><strong>Channel, amount and denom specific</strong></em></p>
<p>This example will configure Hermes so it will ignore <code>send_packet</code> events from <code>channel-0</code> which do not have at least <code>10 uatoms</code> as the <code>recv_fee</code>.</p>
<pre><code>[chains.packet_filter.min_fees.'channel-0']
  recv = [{ amount = 10, denom = 'uatom' }]
</code></pre>
<p><em><strong>Amount and denom specific</strong></em></p>
<p>This example will configure Hermes so it will ignore <code>send_packet</code> events from any channel which do not have at least <code>10 uatoms</code> as the <code>recv_fee</code>.</p>
<pre><code>[chains.packet_filter.min_fees.'*']
  recv = [{ amount = 10, denom = 'uatom' }]
</code></pre>
<p><em><strong>Amount only</strong></em></p>
<p>This example will configure Hermes so it will only relay <code>send_packet</code> events sent with incentivized events.</p>
<pre><code>[chains.packet_filter.min_fees.'*']
  recv    = [{ amount = 0 }]
</code></pre>
<p><em><strong>Multiple filters</strong></em></p>
<p>This example will configure Hermes so it will ignore <code>send_packet</code> events from any channel which starts with <code>ics</code>, does not have at least <code>10 uatom</code> or <code>20 stake</code> as the <code>recv_fee</code>.</p>
<pre><code>[chains.packet_filter.min_fees.'ics*']
  recv    = [{ amount = 10, denom = 'uatom' }, { amount = 20, denom = 'stake' }]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-clearing"><a class="header" href="#packet-clearing">Packet clearing</a></h1>
<p>Hermes can be configured in order to clear packets which haven't been relayed. This can happen if there wasn't a relayer instance running when the packet event was submitted or if there was an issue relaying the packet.</p>
<p>There are four different configurations to determine when Hermes will clear packets.</p>
<h2 id="global-configurations"><a class="header" href="#global-configurations">Global configurations</a></h2>
<p>Two of these configurations are global to all chains and are in the <code>[mode.packet]</code> section.</p>
<h3 id="1-clear_on_start"><a class="header" href="#1-clear_on_start">1. <code>clear_on_start</code></a></h3>
<pre><code class="language-toml">[mode.packet]
...
clear_on_start = true
</code></pre>
<p>This configuration is used to specify if Hermes should query and relay pending packets when starting the instance. If set this will only trigger once per running instance.</p>
<blockquote>
<p><strong>NOTE</strong>: If this configuration is enabled Hermes will need to scan for channels as the pending packets will require the channel worker, refer to the <a href="documentation/configuration/./performance.html#3-slow-start">Slow start section</a> for more information.</p>
</blockquote>
<h3 id="2-clear_interval"><a class="header" href="#2-clear_interval">2. <code>clear_interval</code></a></h3>
<pre><code class="language-toml">[mode.packet]
...
clear_interval = 100
</code></pre>
<p>This configuration defines how often Hermes will verify if there are pending packets and relay them. The value is the number of blocks observed, so the time between each clearing might very from chain to chain.</p>
<h2 id="chain-specific-configuration"><a class="header" href="#chain-specific-configuration">Chain specific configuration</a></h2>
<p>The third and fourth configurations are specific for each chain.</p>
<h3 id="3-clear_interval"><a class="header" href="#3-clear_interval">3. <code>clear_interval</code></a></h3>
<pre><code class="language-toml">[[chains]]
...
clear_interval = 50
</code></pre>
<p>An additional <code>clear_interval</code> can be specified for each chain, this value is also in number of blocks. This configuration will override the clear interval value for the specific chain and can be used if chains need to have different clear values. This configuration is optional, if it is not set the global value will be used.</p>
<h3 id="4-excluded_sequences"><a class="header" href="#4-excluded_sequences">4. <code>excluded_sequences</code></a></h3>
<pre><code class="language-toml">[[chains]]
...
excluded_sequences = [
    ['channel-0', [1, 2, 3]],
    ['channel-1', [4, 5, 6]]
]
</code></pre>
<p>It is possible to specify which packet sequences should be ignored when clearing packets for specific channels. This can be used when there are stuck packets which need to be handled in a specific way, but it is still required to clear the other stuck packets. This configuration will only filter packet when clearing, standard relaying will not filter the sequences configured in <code>excluded_sequences</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-tuning"><a class="header" href="#performance-tuning">Performance tuning</a></h1>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="documentation/configuration/performance.html#overview">Overview</a></li>
<li><a href="documentation/configuration/performance.html#configuration-options">Configuration Options</a>
<ul>
<li><a href="documentation/configuration/performance.html#1-trusted-node">1. Trusted Node</a></li>
<li><a href="documentation/configuration/performance.html#2-batch-delay">2. Batch Delay</a></li>
<li><a href="documentation/configuration/performance.html#3-slow-start">3. Slow start</a>
<ul>
<li><a href="documentation/configuration/performance.html#31-specify-an-allow-list-in-the-packet-filter">3.1 Specify an allow list in the packet filter</a></li>
<li><a href="documentation/configuration/performance.html#32-disable-clients-connections-channels-workers-and-packet-clearing-on-startup">3.2 Disable clients, connections, channels workers and packet clearing on startup</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="documentation/configuration/performance.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Hermes provides several configuration options that users can tweak to optimize its performance to suit specific requirements. This guide provides an overview of these options, and suggests ways to modify them for different scenarios.</p>
<p>The two per-chain configuration options you can use to tune the performance of Hermes as of version 1.5 are <code>trusted_node</code> and <code>batch_delay</code>.</p>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="1-trusted-node"><a class="header" href="#1-trusted-node">1. Trusted Node</a></h3>
<p>The <code>trusted_node</code> setting is an experimental option that determines whether or not the full node is trusted.</p>
<pre><code class="language-toml">trusted_node = false
</code></pre>
<p>When set to <code>true</code>, Hermes trusts the full node and does not verify headers included in the <code>ClientUpdate</code> message using the light client.
This could lead to faster processing as it bypasses the verification step.</p>
<p>However, it's important to note that when the full node is configured as trusted, the verification traces will not be provided.
This could potentially lead to failure in client updates after a significant change in validator sets.</p>
<p>If you prefer security over speed, or if the validator set changes frequently, consider leaving this setting as <code>false</code>, which is also the default.</p>
<h3 id="2-batch-delay"><a class="header" href="#2-batch-delay">2. Batch Delay</a></h3>
<p>The <code>batch_delay</code> setting dictates the delay until an event batch is emitted if no <code>NewBlock</code> events have been received yet.</p>
<pre><code class="language-toml">batch_delay = '500ms'
</code></pre>
<p>Lower <code>batch_delay</code> values will result in faster event processing, improving the latency of Hermes.
However, setting it too low could sometimes cause events to be split across more batches than necessary, which will then cause Hermes to send more client updates than otherwise required.
Conversely, higher values will increase the latency of Hermes, but will minimize the number of client updates.</p>
<p>If you prioritize processing speed and can tolerate the potentially slightly higher costs, consider setting a lower <code>batch_delay</code>. For backup relayer or settings where latency is not as important, consider a higher <code>batch_delay</code>.</p>
<p>The default <code>500ms</code> provides a good balance between speed and reliability, while still minimizing the number of client updates to send.</p>
<h3 id="3-slow-start"><a class="header" href="#3-slow-start">3. Slow start</a></h3>
<p>On blochains with many open channels, connections and/or clients, Hermes may take a long while to start.
That is because Hermes needs to perform a scan of all available clients, connections and channels on that blockchain in order to refresh these clients, complete the handshakes of partially open channels and connections.
If Hermes takes more than a couple minutes to start, that may be because there are too many clients, connections and/or channels.</p>
<p>To alleviate this issue, there are two potential solutions:</p>
<h4 id="31-specify-an-allow-list-in-the-packet-filter"><a class="header" href="#31-specify-an-allow-list-in-the-packet-filter">3.1 Specify an allow list in the packet filter</a></h4>
<p>Add the end of the <code>[[chains]]</code> section for affected blockchain, you can specify a packet filter with an allow list.
This will ensure Hermes will only scan for the listed channels, and gather the corresponding connections and clients for these channels only.</p>
<p>For example, to only relay on two channels named <code>channel-0</code> and <code>channel-1</code>, on port <code>transfer</code>, you can add the following packet filter:</p>
<pre><code class="language-toml"> [chains.packet_filter]
 policy = 'allow'
 list = [
   ['transfer', 'channel-0'],
   ['transfer', 'channel-1'],
 ]
</code></pre>
<p><strong>Caveat:</strong> the allow list cannot contain any wildcards, otherwise Hermes will have to perform a full scan to
gather all channels and subsequently filter them against the allow list.</p>
<p>For example, the following configuration would cause Hermes to perform such a full scan, and therefore potentially slow down its startup time:</p>
<pre><code class="language-toml"> [chains.packet_filter]
 policy = 'allow'
 list = [
   ['ica*', '*'],
   ['transfer', 'channel-0'],
 ]
</code></pre>
<h4 id="32-disable-clients-connections-channels-workers-and-packet-clearing-on-startup"><a class="header" href="#32-disable-clients-connections-channels-workers-and-packet-clearing-on-startup">3.2 Disable clients, connections, channels workers and packet clearing on startup</a></h4>
<p>If you wish to relay on all channels, or to use wildcards in the packet filter, then another option to speed up the startup is to disable
scanning altogether.</p>
<p>At the moment, there is no single setting to do this, but by disabling the clients, connections and channels workers and
setting <code>clear_on_start</code> to <code>false</code> under the <code>mode.packets</code> section, Hermes will not need to perform a scan and will only
relay packets on active channels, provided they match the packet filter, if present. Otherwise Hermes will relay on all
active channels.</p>
<p>Please note that because these settings are global, they will affect the behaviour of Hermes for all chains listed in its configuration.</p>
<p>Here is how the configuration file should look like in order to disable scanning altogether.</p>
<pre><code class="language-toml"># ...

[mode.clients]
enabled = false

# ...

[mode.connections]
enabled = false

# ...

[mode.channels]
enabled = false

# ...

[mode.packets]
enabled = true
clear_on_start = false
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>The tuning of Hermes performance relies on the balance between processing speed and reliability. Keep in mind that tuning these configurations according to your needs could significantly improve the performance of your Hermes instance. Please thoroughly test any changes in a controlled environment before implementing them in a production setting.</p>
<p>Remember, every blockchain and network has unique characteristics that can affect the performance of the relayer, so there's no one-size-fits-all configuration. Feel free to experiment and fine-tune these settings to achieve optimal performance for your specific use case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telemetry"><a class="header" href="#telemetry">Telemetry</a></h1>
<p>To gain a better understanding of the status and activity of the relayer,
Hermes features a built-in telemetry service based on the <a href="https://opentelemetry.io">OpenTelemetry</a> observability framework,
whose metrics can be exposed over HTTP for integration with the <a href="https://prometheus.io">Prometheus</a> monitoring system.</p>
<p>The official Hermes builds for Linux and macOS come with telemetry support since version <code>v0.4.0</code>.
See the <a href="documentation/telemetry/../../quick-start/installation.html#install-the-relayer">installation instructions</a> for how to obtain the latest version of Hermes.</p>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<p>The telemetry service is not active by default, and must be enabled in Hermes' configuration:</p>
<pre><code class="language-toml">[telemetry]
enabled = true                                                  # default = false
host    = '127.0.0.1'                                           # default value
port    = 3001                                                  # default value
prefix  = ""                                                    # default value
[telemetry.buckets]                                             # default value
latency_submitted = { start = 5000, end = 10000, buckets = 10 } # default value
latency_confirmed = { start = 5000, end = 10000, buckets = 10 } # default value
</code></pre>
<p>Please see the <a href="documentation/telemetry/../configuration/index.html">relevant section for <em>Configuration</em></a> for more general details about Hermes configuration options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hermes-operators-guide-to-using-metrics"><a class="header" href="#hermes-operators-guide-to-using-metrics">Hermes operators guide to using metrics</a></h1>
<p>This section is a basic guide on how Hermes metrics can be used to observe both
the current state of the Hermes relayer and the networks it is connected to.</p>
<h2 id="general-remarks-about-the-metrics"><a class="header" href="#general-remarks-about-the-metrics">General remarks about the metrics</a></h2>
<ul>
<li>All Hermes metrics are tracked and updated from the moment the Hermes service (i.e., <code>start</code>) starts up.
Metrics are automatically reset if the service is restarted.</li>
<li>For maximum reliability, it is advised to combine monitoring of your Hermes service with monitoring of your full nodes.</li>
<li>Some metrics require specific configurations to be enabled, this is described in the <code>Configuration Dependencies</code> column.</li>
</ul>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<p>Hermes' metrics are designed to be able to answer four basic questions:</p>
<ol>
<li>Is Hermes active (i.e., <em>submitting</em> any transactions to any network)?</li>
<li>Are Hermes transactions successful (i.e., <em>confirmed</em> and included in the network)?</li>
<li>What is the overall IBC status of each network?</li>
<li>How efficient, and how secure is the IBC status on each network?</li>
<li>Am I getting fee rewards from ICS29 incentivized packets?</li>
</ol>
<p>For each of this question, there is a dedicated subsection:</p>
<ul>
<li><a href="documentation/telemetry/operators.html#is-hermes-active">Is Hermes active?</a></li>
<li><a href="documentation/telemetry/operators.html#are-hermes-transactions-successful">Are Hermes transactions successful?</a></li>
<li><a href="documentation/telemetry/operators.html#what-is-the-overall-ibc-status-of-each-network">What is the overall IBC status of each network?</a></li>
<li><a href="documentation/telemetry/operators.html#how-efficient-and-how-secure-is-the-ibc-status-on-each-network">How efficient and how secure is the IBC status on each network?</a></li>
<li><a href="documentation/telemetry/operators.html#am-i-getting-fee-rewards">Am I getting fee rewards?</a></li>
<li><a href="documentation/telemetry/operators.html#dynamic-gas-fees">Dynamic gas fees</a></li>
</ul>
<h2 id="is-hermes-active"><a class="header" href="#is-hermes-active">Is Hermes active?</a></h2>
<p>By <em>active</em>, we mean specifically: is Hermes <em>submitting</em> any transactions to any network?
The metrics in the table below are design to answer this question on multiple dimensions.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>workers</code></td><td>Number of workers per type</td><td><code>i64</code> UpDownCounter</td><td>Corresponding workers enabled</td></tr>
<tr><td><code>client_updates_submitted_total</code></td><td>Number of client update messages submitted, per sending chain, receiving chain and client</td><td><code>u64</code> Counter</td><td>Client, Connection, Channel or Packet workers enabled</td></tr>
<tr><td><code>client_updates_skipped_total</code></td><td>Number of client update messages skipped because the consensus state already exists, per sending chain, receiving chain and client</td><td><code>u64</code> Counter</td><td>Client, Connection, Channel or Packet workers enabled</td></tr>
<tr><td><code>wallet_balance</code></td><td>The balance of each wallet Hermes uses per chain</td><td><code>f64</code> ValueRecorder</td><td>None</td></tr>
<tr><td><code>tx_latency_submitted</code></td><td>Latency for all transactions submitted to a chain</td><td><code>u64</code> ValueRecorder</td><td>None</td></tr>
<tr><td><code>messages_submitted_total</code></td><td>Number of messages submitted to a specific chain</td><td><code>u64</code> Counter</td><td>None</td></tr>
</tbody></table>
</div>
<p>Notes &amp; more details below:</p>
<p><strong>What is a worker?</strong></p>
<ul>
<li>A worker is a separate thread of execution and there are five types of workers:
<ul>
<li><code>Client</code>: The worker that refreshed a client periodically and detects misbehaviour.</li>
<li><code>Connection</code>: The worker that handles connection open handshake that may be incomplete.</li>
<li><code>Channel</code>: The worker that handles channel open handshake that may be incomplete.</li>
<li><code>Packet</code>: The worker that handles packet relaying.</li>
<li><code>Wallet</code>: The worker that periodically queries for the balance of each wallet that Hermes is using and updates <code>wallet_balance</code> metric.</li>
</ul>
</li>
<li>For example, if your metrics show that you have 0 packet workers (<code>workers{type="packet"} 0</code>), that is a clear indication that Hermes is <em>not relaying any packets at the moment</em>.</li>
</ul>
<p><strong>How do we define the latency of a submitted transaction?</strong>
The latency is defined as the difference between the moment when Hermes received an event (through the websocket) until the moment when the corresponding transaction(s) were submitted
into a full node's mempool.</p>
<ul>
<li>If a transaction is submitted it does not mean it was confirmed, see below for more details.</li>
<li>This metric is tracked per chain, counterparty chain, channel and port.</li>
</ul>
<p><strong>A note on wallet balances.</strong>
For the <code>wallet_balance</code>, we convert from a String into a f64, which can lead to a loss in precision in the displayed value.</p>
<p><strong>latency histogram</strong>
The <code>tx_latency_submitted</code> and <code>tx_latency_confirmed</code> are displayed with histogram buckets which each contain the number of values less or equal to their bucket label. This means that if there are 5 buckets with label <code>500</code>, <code>2000</code>, <code>3000</code>, <code>4000</code> and <code>5000</code> and 2 <code>tx_latency_submitted</code> were recorded of respectively <code>1800ms</code> and <code>3100ms</code> then the <code>tx_latency_submitted</code> will look like this:</p>
<pre><code class="language-text">tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="500"} 0
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="2000"} 1
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="3000"} 1
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="4000"} 2
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="5000"} 2
tx_latency_submitted_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="+Inf"} 2
</code></pre>
<p>The range of the buckets can be configured using the <code>latency_submitted</code> and <code>latency_confirmed</code> seen <a href="documentation/telemetry/./index.html">here</a></p>
<h2 id="are-hermes-transactions-successful"><a class="header" href="#are-hermes-transactions-successful">Are Hermes transactions successful?</a></h2>
<p>This table shows the metrics for Hermes performance.
Importantly, these metrics are only displayed if the configuration <code>tx_confirmation = true</code> is set in your config.toml.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>tx_latency_confirmed</code></td><td>Latency for all transactions confirmed by a chain</td><td><code>u64</code> ValueRecorder</td><td>Transaction confirmation enabled</td></tr>
<tr><td><code>receive_packets_confirmed_total</code></td><td>Number of confirmed receive packets, per chain, channel and port</td><td><code>u64</code> Counter</td><td>Packet workers enabled, and Transaction confirmation enabled</td></tr>
<tr><td><code>acknowledgment_packets_confirmed_total</code></td><td>Number of confirmed acknowledgment packets, per chain, channel and port</td><td><code>u64</code> Counter</td><td>Packet workers enabled, and Transaction confirmation enabled</td></tr>
<tr><td><code>timeout_packets_confirmed_total</code></td><td>Number of confirmed timeout packets, per chain, channel and port</td><td><code>u64</code> Counter</td><td>Packet workers enabled and Transaction confirmation enabled</td></tr>
</tbody></table>
</div>
<p><strong>How do we define the latency of a confirmed transaction?</strong>
This is the difference between the moment when Hermes received an event until the corresponding transaction(s) were confirmed.</p>
<ul>
<li>Similarly to <code>tx_latency_submitted</code>, this metrics is tracked per chain, counterparty chain, channel and port.</li>
<li>This metrics usually contains strictly larger values than <code>tx_latency_submitted</code>, because Hermes first submits transactions into the network's mempool,
and then it takes some more time elapses until the network includes those transactions in a block.</li>
</ul>
<h2 id="what-is-the-overall-ibc-status-of-each-network"><a class="header" href="#what-is-the-overall-ibc-status-of-each-network">What is the overall IBC status of each network?</a></h2>
<p>These metrics are not specific to your Hermes instance. These are metrics that capture the activity of <em>all IBC relayers</em>.</p>
<blockquote>
<p>‼️ Important:
Your Hermes instance produces these metrics based on the <em>events</em> it receives via a websocket to the full nodes of each network.
If these events are not being updated, that is a good indication that either:</p>
<ul>
<li>The network has no IBC activity, or</li>
<li>The websocket connection to that network is broken.</li>
</ul>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>send_packet_events_total</code></td><td>Number of SendPacket events received</td><td><code>u64</code> Counter</td><td>Packet workers enabled</td></tr>
<tr><td><code>acknowledgement_events_total</code></td><td>Number of WriteAcknowledgement events received</td><td><code>u64</code> Counter</td><td>Packet workers enabled</td></tr>
<tr><td><code>timeout_events_total</code></td><td>Number of TimeoutPacket events received</td><td><code>u64</code> Counter</td><td>Packet workers enabled</td></tr>
<tr><td><code>ws_events_total</code></td><td>Number of events Hermes (including <code>send_packet</code>, <code>acknowledgment</code>, and <code>timeout</code>) received via the websocket subscription, per chain</td><td><code>u64</code> Counter</td><td>None</td></tr>
<tr><td><code>ws_reconnect_total</code></td><td>Number of times Hermes reconnected to the websocket endpoint, per chain</td><td><code>u64</code> Counter</td><td>None</td></tr>
<tr><td><code>queries_total</code></td><td>Number of queries submitted by Hermes, per chain and query type</td><td><code>u64</code> Counter      </td><td>None</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>Except for <code>ws_reconnect_total</code>, all these metrics should typically increase regularly in the common-case. That is an indication that the network is regularly producing new blocks and there is ongoing IBC activity, eg <code>send_packet</code>, <code>acknowledgment</code>, and <code>timeout</code>.</li>
<li>The metric <code>ws_reconnect_total</code> signals that the websocket connection was broken and Hermes had to re-establish that. It is usually an indication that your full node may be falling behind or is experiencing instability.</li>
</ul>
<p>Since Hermes v1, we also introduced 3 metrics that sketch the backlog status of IBC relaying.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>backlog_oldest_sequence</code></td><td>Sequence number of the oldest SendPacket event in the backlog</td><td><code>u64</code> ValueRecorder</td><td>Packet workers enabled</td></tr>
<tr><td><code>backlog_latest_update_timestamp</code></td><td>Local timestamp for the last time the backlog metrics have been updated</td><td><code>u64</code> ValueRecorder </td><td>Packet workers enabled</td></tr>
<tr><td><code>backlog_size</code></td><td>Total number of SendPacket events in the backlog</td><td><code>u64</code> ValueRecorder </td><td>Packet workers enabled</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>The <code>backlog_size</code> defines how many IBC packets users sent and were not yet relayed (i.e., received on the destination network, or timed-out).
If this metric is increasing, it signals that the packet queue is increasing and there may be some errors in the Hermes logs that need your attention.</li>
<li>The <code>backlog_latest_update_timestamp</code> is used to get information on the reliability of the <code>backlog_*</code> metrics. If the timestamp doesn't change it means there might be an issue with the metrics.</li>
<li><strong>NOTE</strong>: The Hermes instance might miss the acknowledgment of an observed IBC packets relayed, this will cause the <code>backlog_*</code> metrics to contain an invalid value. In order to minimise this issue, whenever the Hermes instance clears packets the <code>backlog_*</code> metrics will be updated using the queried pending packets.</li>
</ul>
<h2 id="how-efficient-and-how-secure-is-the-ibc-status-on-each-network"><a class="header" href="#how-efficient-and-how-secure-is-the-ibc-status-on-each-network">How efficient and how secure is the IBC status on each network?</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>queries_total</code></td><td>Number of queries submitted by Hermes, per chain and query type                                                                                                             </td><td><code>u64</code> Counter       </td><td>None</td></tr>
<tr><td> <code>queries_cache_hits_total</code></td><td>Number of cache hits for queries submitted by Hermes, per chain and query type                                                                                           </td><td><code>u64</code> Counter       </td><td>None</td></tr>
<tr><td><code>tx_latency_submitted</code></td><td>Latency for all transactions submitted to a chain (i.e., difference between the moment when Hermes received an event until the corresponding transaction(s) were submitted), per chain, counterparty chain, channel and port</td><td><code>u64</code> ValueRecorder</td><td>None</td></tr>
<tr><td> <code>cleared_send_packet_count_total</code> </td><td>Number of SendPacket events received during the initial and periodic clearing, per chain, counterparty chain, channel and port</td><td><code>u64</code> Counter</td><td>Packet workers enabled, and periodic packet clearing or clear on start enabled</td></tr>
<tr><td> <code>cleared_acknowledgment_count_total</code></td><td>Number of WriteAcknowledgement events received during the initial and periodic clearing, per chain, counterparty chain, channel and port</td><td><code>u64</code> Counter</td><td>Packet workers enabled, and periodic packet clearing or clear on start enabled</td></tr>
<tr><td><code>broadcast_errors_total</code></td><td>Number of errors observed by Hermes when broadcasting a Tx, per error type and account</td><td><code>u64</code> Counter</td><td>Packet workers enabled</td></tr>
<tr><td><code>simulate_errors_total</code></td><td>Number of errors observed by Hermes when simulating a Tx, per error type, account and whether the error is recoverable or not</td><td><code>u64</code> Counter</td><td>Packet workers enabled</td></tr>
<tr><td><code>filtered_packets</code></td><td>Number of ICS-20 packets filtered because the memo and/or the receiver fields were exceeding the configured limits</td><td><code>u64</code> Counter</td><td>Packet workers enabled, and <code>ics20_max_memo_size</code> and/or <code>ics20_max_receiver_size</code> enabled</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>The two metrics <code>cleared_send_packet_count_total</code> and <code>cleared_acknowledgment_count_total</code> are only populated if <code>tx_confirmation = true</code>.
These two metrics usually correlate with <code>backlog_*</code> metrics. They are an indication that IBC packet relaying may be unsuccessful and that Hermes periodically
finds packets to clear (i.e., unblock).</li>
<li><code>queries_total</code> and <code>queries_cache_hits_total</code> values are complementary. For the total number of queries, the two metrics should be summed for a specific query type.</li>
</ul>
<p>For security, we only expose one metric, described in the table below.
Note that this metrics is disabled if <code>misbehaviour = false</code> in your Hermes config.toml.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>client_misbehaviours_submitted_total</code></td><td>Number of misbehaviours detected and submitted, per sending chain, receiving chain and client</td><td><code>u64</code> Counter</td><td>Client workers enabled and Clients misbehaviour detection enabled</td></tr>
</tbody></table>
</div>
<h2 id="am-i-getting-fee-rewards"><a class="header" href="#am-i-getting-fee-rewards">Am I getting fee rewards?</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>ics29_fee_amounts_total</code></td><td>Total amount received from ICS29 fees                                       </td><td><code>u64</code> Counter       </td><td>None</td></tr>
<tr><td> <code>ics29_period_fees</code></td><td>Amount of ICS29 fees rewarded over the past 7 days type</td><td><code>u64</code> ValueRecorder </td><td>None</td></tr>
</tbody></table>
</div>
<h2 id="dynamic-gas-fees-1"><a class="header" href="#dynamic-gas-fees-1">Dynamic gas fees</a></h2>
<p>The introduction of dynamic gas fees adds additional configuration which can be delicate to handle correctly. The following metrics can help correctly configure your relayer.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>dynamic_gas_queried_fees</code></td><td>The EIP-1559 base fee queried                                        </td><td><code>u64</code> ValueRecorder </td><td>None</td></tr>
<tr><td><code>dynamic_gas_queried_success_fees</code></td><td>The EIP-1559 base fee successfully queried                </td><td><code>u64</code> ValueRecorder </td><td>None</td></tr>
<tr><td><code>dynamic_gas_paid_fees</code></td><td>The EIP-1559 base fee paid                                           </td><td><code>u64</code> ValueRecorder </td><td>None</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>The <code>dynamic_gas_queried_fees</code> contains the gas price used after the query but before filtering by configured <code>max</code>. This means that this metric might contain the static gas price if the query failed.</li>
<li>The <code>dynamic_gas_queried_success_fees</code> will only contain the gas price when the query succeeds, if this metric doesn't contain values or less values that the <code>dynamic_gas_queried_fees</code> this could indicate an issue with the endpoint used to query the fees.</li>
<li><code>dynamic_gas_paid_fees</code> will contain the price used by the relayer, the maximum value for this metric is <code>max</code>. If there are multiple values in the same bucket as the <code>max</code> it could indicate that the gas price queried is often higher than the configured <code>max</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-with-prometheus"><a class="header" href="#integration-with-prometheus">Integration with Prometheus</a></h1>
<p>With the <code>enabled = true</code> setting for <code>telemetry</code> in your config.toml, the telemetry service will be enabled and will serve the metrics using
the Prometheus encoder over HTTP at <a href="http://localhost:3001/metrics"><code>http://localhost:3001/metrics</code></a>.</p>
<p>After starting Hermes with <code>hermes start </code>, and letting it run for a while to relay packets,
open <a href="http://localhost:3001/metrics"><code>http://localhost:3001/metrics</code></a> in a browser, you should
see Prometheus-encoded metrics.</p>
<p>For example, with two channels and after transferring some tokens between the chains:</p>
<pre><code class="language-text"># HELP acknowledgement_events_total Number of WriteAcknowledgement events received
# TYPE acknowledgement_events_total counter
acknowledgement_events_total{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 4
acknowledgement_events_total{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
# HELP acknowledgment_packets_confirmed_total Number of confirmed acknowledgment packets. Available if relayer runs with Tx confirmation enabled
# TYPE acknowledgment_packets_confirmed_total counter
acknowledgment_packets_confirmed_total{dst_chain="ibc-0",dst_channel="channel-0",dst_port="transfer",service_name="unknown_service",src_chain="ibc-1",src_channel="channel-0",src_port="transfer",otel_scope_name="hermes",otel_scope_version=""} 1
acknowledgment_packets_confirmed_total{dst_chain="ibc-1",dst_channel="channel-0",dst_port="transfer",service_name="unknown_service",src_chain="ibc-0",src_channel="channel-0",src_port="transfer",otel_scope_name="hermes",otel_scope_version=""} 0
# HELP backlog_oldest_sequence Sequence number of the oldest SendPacket event in the backlog
# TYPE backlog_oldest_sequence gauge
backlog_oldest_sequence{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
backlog_oldest_sequence{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
# HELP backlog_latest_update_timestamp Local timestamp for the last time the backlog metrics have been updated
# TYPE backlog_latest_update_timestamp gauge
backlog_latest_update_timestamp{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
backlog_latest_update_timestamp{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
# HELP backlog_size Total number of SendPacket events in the backlog
# TYPE backlog_size gauge
backlog_size{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
backlog_size{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
# HELP client_updates_submitted_total Number of client update messages submitted
# TYPE client_updates_submitted_total counter
client_updates_submitted_total{client="07-tendermint-0",dst_chain="ibc-0",service_name="unknown_service",src_chain="ibc-1",otel_scope_name="hermes",otel_scope_version=""} 2
client_updates_submitted_total{client="07-tendermint-0",dst_chain="ibc-1",service_name="unknown_service",src_chain="ibc-0",otel_scope_name="hermes",otel_scope_version=""} 2
# HELP client_updates_skipped_total Number of client update messages skipped
# TYPE client_updates_skipped_total counter
client_updates_skipped_total{client="07-tendermint-0",dst_chain="ibc-0",service_name="unknown_service",src_chain="ibc-1",otel_scope_name="hermes",otel_scope_version=""} 0
client_updates_skipped_total{client="07-tendermint-0",dst_chain="ibc-1",service_name="unknown_service",src_chain="ibc-0",otel_scope_name="hermes",otel_scope_version=""} 0
# HELP ics29_period_fees Amount of ICS29 fees rewarded over the past 7 days
# TYPE ics29_period_fees gauge
ics29_period_fees{chain="ibc-0",denom="stake",receiver="cosmos1j6z6q9d2gf2suav88z8g3zf726vz9ehg4hkr8x",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
ics29_period_fees{chain="ibc-1",denom="stake",receiver="cosmos1340jyu3hawjzusu4jfwh29prpglkju5rlkpesn",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
ics29_period_fees{chain="ibc-2",denom="stake",receiver="cosmos1yxzuet72f4qlks8tzrna6y2q4wchur02gqs5al",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
ics29_period_fees{chain="ibc-3",denom="stake",receiver="cosmos1fk5ykcvkgr4yzlzfyegnaaqyc0ulv8wv8u9hjl",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
# HELP messages_submitted_total Number of messages submitted to a specific chain
# TYPE messages_submitted_total counter
messages_submitted_total{chain="ibc-0",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 7
messages_submitted_total{chain="ibc-1",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 7
messages_submitted_total{chain="ibc-2",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
messages_submitted_total{chain="ibc-3",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
# HELP otel_scope_info Instrumentation Scope metadata
# TYPE otel_scope_info gauge
otel_scope_info{otel_scope_name="hermes",otel_scope_version=""} 1
# HELP queries_cache_hits_total Number of cache hits for queries submitted by Hermes
# TYPE queries_cache_hits_total counter
queries_cache_hits_total{chain="ibc-0",query_type="query_channel",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 9
queries_cache_hits_total{chain="ibc-0",query_type="query_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 4
queries_cache_hits_total{chain="ibc-0",query_type="query_connection",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 11
queries_cache_hits_total{chain="ibc-0",query_type="query_latest_height",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_cache_hits_total{chain="ibc-1",query_type="query_channel",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 12
queries_cache_hits_total{chain="ibc-1",query_type="query_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 4
queries_cache_hits_total{chain="ibc-1",query_type="query_connection",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 11
queries_cache_hits_total{chain="ibc-1",query_type="query_latest_height",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_cache_hits_total{chain="ibc-2",query_type="query_channel",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_cache_hits_total{chain="ibc-2",query_type="query_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_cache_hits_total{chain="ibc-2",query_type="query_connection",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_cache_hits_total{chain="ibc-2",query_type="query_latest_height",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_cache_hits_total{chain="ibc-3",query_type="query_channel",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_cache_hits_total{chain="ibc-3",query_type="query_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_cache_hits_total{chain="ibc-3",query_type="query_connection",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_cache_hits_total{chain="ibc-3",query_type="query_latest_height",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
# HELP queries_total Number of queries submitted by Hermes
# TYPE queries_total counter
queries_total{chain="ibc-0",query_type="query_application_status",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 10
queries_total{chain="ibc-0",query_type="query_block",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-0",query_type="query_blocks",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-0",query_type="query_channel",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 9
queries_total{chain="ibc-0",query_type="query_channel_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-0",query_type="query_channels",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-0",query_type="query_client_connections",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-0",query_type="query_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 6
queries_total{chain="ibc-0",query_type="query_clients",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-0",query_type="query_commitment_prefix",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-0",query_type="query_config_params",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-0",query_type="query_connection",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-0",query_type="query_connection_channels",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-0",query_type="query_connections",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-0",query_type="query_consensus_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-0",query_type="query_consensus_states",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-0",query_type="query_latest_height",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-0",query_type="query_next_sequence_receive",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-0",query_type="query_packet_acknowledgements",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-0",query_type="query_packet_commitments",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-0",query_type="query_packet_events",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-0",query_type="query_staking_params",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-0",query_type="query_txs",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 28
queries_total{chain="ibc-0",query_type="query_unreceived_acknowledgements",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-0",query_type="query_unreceived_packets",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 8
queries_total{chain="ibc-0",query_type="query_upgraded_consensus_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-0",query_type="status",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-1",query_type="query_application_status",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 10
queries_total{chain="ibc-1",query_type="query_block",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-1",query_type="query_blocks",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-1",query_type="query_channel",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 3
queries_total{chain="ibc-1",query_type="query_channel_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-1",query_type="query_channels",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-1",query_type="query_client_connections",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-1",query_type="query_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 6
queries_total{chain="ibc-1",query_type="query_clients",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-1",query_type="query_commitment_prefix",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-1",query_type="query_config_params",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-1",query_type="query_connection",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-1",query_type="query_connection_channels",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-1",query_type="query_connections",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-1",query_type="query_consensus_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-1",query_type="query_consensus_states",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-1",query_type="query_latest_height",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-1",query_type="query_next_sequence_receive",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-1",query_type="query_packet_acknowledgements",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-1",query_type="query_packet_commitments",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-1",query_type="query_packet_events",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-1",query_type="query_staking_params",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-1",query_type="query_txs",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 20
queries_total{chain="ibc-1",query_type="query_unreceived_acknowledgements",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 8
queries_total{chain="ibc-1",query_type="query_unreceived_packets",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-1",query_type="query_upgraded_consensus_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-1",query_type="status",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-2",query_type="query_application_status",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_block",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_blocks",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_channel",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_channel_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_channels",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_client_connections",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_clients",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-2",query_type="query_commitment_prefix",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_config_params",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-2",query_type="query_connection",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_connection_channels",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_connections",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_consensus_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_consensus_states",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_latest_height",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-2",query_type="query_next_sequence_receive",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_packet_acknowledgements",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_packet_commitments",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_packet_events",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_staking_params",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-2",query_type="query_txs",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_unreceived_acknowledgements",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_unreceived_packets",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="query_upgraded_consensus_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-2",query_type="status",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-3",query_type="query_application_status",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_block",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_blocks",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_channel",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_channel_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_channels",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_client_connections",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_client_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_clients",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-3",query_type="query_commitment_prefix",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_config_params",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-3",query_type="query_connection",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_connection_channels",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_connections",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_consensus_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_consensus_states",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_latest_height",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
queries_total{chain="ibc-3",query_type="query_next_sequence_receive",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_packet_acknowledgements",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_packet_commitments",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_packet_events",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_staking_params",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
queries_total{chain="ibc-3",query_type="query_txs",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_unreceived_acknowledgements",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_unreceived_packets",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="query_upgraded_consensus_state",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
queries_total{chain="ibc-3",query_type="status",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
# HELP receive_packets_confirmed_total Number of confirmed receive packets. Available if relayer runs with Tx confirmation enabled
# TYPE receive_packets_confirmed_total counter
receive_packets_confirmed_total{dst_chain="ibc-0",dst_channel="channel-0",dst_port="transfer",service_name="unknown_service",src_chain="ibc-1",src_channel="channel-0",src_port="transfer",otel_scope_name="hermes",otel_scope_version=""} 4
receive_packets_confirmed_total{dst_chain="ibc-1",dst_channel="channel-0",dst_port="transfer",service_name="unknown_service",src_chain="ibc-0",src_channel="channel-0",src_port="transfer",otel_scope_name="hermes",otel_scope_version=""} 1
# HELP send_packet_events_total Number of SendPacket events received
# TYPE send_packet_events_total counter
send_packet_events_total{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
send_packet_events_total{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 4
# HELP timeout_events_total Number of TimeoutPacket events received
# TYPE timeout_events_total counter
timeout_events_total{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
timeout_events_total{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
# HELP timeout_packets_confirmed_total Number of confirmed timeout packets. Available if relayer runs with Tx confirmation enabled
# TYPE timeout_packets_confirmed_total counter
timeout_packets_confirmed_total{dst_chain="ibc-0",dst_channel="channel-0",dst_port="transfer",service_name="unknown_service",src_chain="ibc-1",src_channel="channel-0",src_port="transfer",otel_scope_name="hermes",otel_scope_version=""} 0
timeout_packets_confirmed_total{dst_chain="ibc-1",dst_channel="channel-0",dst_port="transfer",service_name="unknown_service",src_chain="ibc-0",src_channel="channel-0",src_port="transfer",otel_scope_name="hermes",otel_scope_version=""} 0
# HELP tx_latency_confirmed The latency for all transactions submitted &amp; confirmed to a specific chain, i.e. the difference between the moment when Hermes received a batch of events until the corresponding transaction(s) were confirmed. Milliseconds.
# TYPE tx_latency_confirmed histogram
tx_latency_confirmed_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="1000"} 0
tx_latency_confirmed_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="5000"} 0
tx_latency_confirmed_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="9000"} 2
tx_latency_confirmed_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="13000"} 2
tx_latency_confirmed_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="17000"} 2
tx_latency_confirmed_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="20000"} 2
tx_latency_confirmed_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="+Inf"} 2
tx_latency_confirmed_sum{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 11980
tx_latency_confirmed_count{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
tx_latency_confirmed_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="1000"} 0
tx_latency_confirmed_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="5000"} 0
tx_latency_confirmed_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="9000"} 1
tx_latency_confirmed_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="13000"} 1
tx_latency_confirmed_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="17000"} 1
tx_latency_confirmed_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="20000"} 1
tx_latency_confirmed_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="+Inf"} 1
tx_latency_confirmed_sum{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 6021
tx_latency_confirmed_count{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 1
# HELP tx_latency_submitted The latency for all transactions submitted to a specific chain, i.e. the difference between the moment when Hermes received a batch of events and when it submitted the corresponding transaction(s). Milliseconds.
# TYPE tx_latency_submitted histogram
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="200"} 0
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="500"} 2
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="1000"} 2
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="2000"} 2
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="5000"} 2
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="10000"} 2
tx_latency_submitted_bucket{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="+Inf"} 2
tx_latency_submitted_sum{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 599
tx_latency_submitted_count{chain="ibc-0",channel="channel-0",counterparty="ibc-1",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
tx_latency_submitted_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="200"} 0
tx_latency_submitted_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="500"} 1
tx_latency_submitted_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="1000"} 2
tx_latency_submitted_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="2000"} 2
tx_latency_submitted_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="5000"} 2
tx_latency_submitted_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="10000"} 2
tx_latency_submitted_bucket{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version="",le="+Inf"} 2
tx_latency_submitted_sum{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 837
tx_latency_submitted_count{chain="ibc-1",channel="channel-0",counterparty="ibc-0",port="transfer",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 2
# HELP wallet_balance The balance of each wallet Hermes uses per chain. Please note that when converting the balance to f64 a loss in precision might be introduced in the displayed value
# TYPE wallet_balance gauge
wallet_balance{account="cosmos1340jyu3hawjzusu4jfwh29prpglkju5rlkpesn",chain="ibc-1",denom="stake",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 99994729
wallet_balance{account="cosmos1fk5ykcvkgr4yzlzfyegnaaqyc0ulv8wv8u9hjl",chain="ibc-3",denom="stake",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 100000000
wallet_balance{account="cosmos1j6z6q9d2gf2suav88z8g3zf726vz9ehg4hkr8x",chain="ibc-0",denom="stake",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 99993392
wallet_balance{account="cosmos1yxzuet72f4qlks8tzrna6y2q4wchur02gqs5al",chain="ibc-2",denom="stake",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 100000000
# HELP workers Number of workers
# TYPE workers gauge
workers{service_name="unknown_service",type="packet",otel_scope_name="hermes",otel_scope_version=""} 2
workers{service_name="unknown_service",type="wallet",otel_scope_name="hermes",otel_scope_version=""} 4
# HELP ws_events_total How many IBC events did Hermes receive via the websocket subscription
# TYPE ws_events_total counter
ws_events_total{chain="ibc-0",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 17
ws_events_total{chain="ibc-1",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 15
ws_events_total{chain="ibc-2",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 9
ws_events_total{chain="ibc-3",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 9
# HELP ws_reconnect_total Number of times Hermes reconnected to the websocket endpoint
# TYPE ws_reconnect_total counter
ws_reconnect_total{chain="ibc-0",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
ws_reconnect_total{chain="ibc-1",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
ws_reconnect_total{chain="ibc-2",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
ws_reconnect_total{chain="ibc-3",service_name="unknown_service",otel_scope_name="hermes",otel_scope_version=""} 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-api"><a class="header" href="#rest-api">REST API</a></h1>
<p><em>Since version 0.7.0.</em></p>
<p>Hermes features a built-in HTTP server which exposes information
about the configuration and state via a REST API.</p>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="documentation/rest-api.html#configuration">Configuration</a></li>
<li><a href="documentation/rest-api.html#endpoints">Endpoints</a>
<ul>
<li><a href="documentation/rest-api.html#get-version">GET <code>/version</code></a></li>
<li><a href="documentation/rest-api.html#get-chains">GET <code>/chains</code></a></li>
<li><a href="documentation/rest-api.html#get-chainid">GET <code>/chain/:id</code></a></li>
<li><a href="documentation/rest-api.html#get-state">GET <code>/state</code></a></li>
</ul>
</li>
</ul>
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<p>The REST API is not active by default, and must be enabled in the configuration:</p>
<pre><code class="language-toml">[rest]
enabled = true
host    = '127.0.0.1'
port    = 3000
</code></pre>
<h2 id="endpoints"><a class="header" href="#endpoints">Endpoints</a></h2>
<h3 id="get-version"><a class="header" href="#get-version">GET <code>/version</code></a></h3>
<p>This endpoint returns the version of the Hermes (under the <code>ibc-relayer</code> key) as well
as the version of the REST server itself (under the <code>ibc-relayer-rest</code> key).</p>
<p><strong>Example</strong></p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/version' | jq
</code></pre>
<pre><code class="language-json">[
  {
    "name": "ibc-relayer",
    "version": "v1.13.2"
  },
  {
    "name": "ibc-relayer-rest",
    "version": "0.1.0"
  }
]
</code></pre>
<h3 id="get-chains"><a class="header" href="#get-chains">GET <code>/chains</code></a></h3>
<p>This endpoint return the identifiers of the chains that Hermes is connected to.
Those identifiers can be used with the <code>/chain/:id</code> endpoint to gather more
information about each chain's configuration. See the next section for more details.</p>
<p><strong>Example</strong></p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/chains' | jq
</code></pre>
<pre><code class="language-json">{
  "status": "success",
  "result": [
    "ibc-0",
    "ibc-1"
  ]
}
</code></pre>
<h3 id="get-chainid"><a class="header" href="#get-chainid">GET <code>/chain/:id</code></a></h3>
<p>This endpoint returns the configuration of the chain with the given identifier,
where <code>:id</code> stands for the identifier.</p>
<p><strong>Example</strong></p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/chain/ibc-0' | jq
</code></pre>
<pre><code class="language-json">{
  "status": "success",
  "result": {
    "id": "ibc-0",
    "rpc_addr": "http://127.0.0.1:26657/",
    "websocket_addr": "ws://127.0.0.1:26657/websocket",
    "grpc_addr": "http://127.0.0.1:9090/",
    "rpc_timeout": "10s",
    "account_prefix": "cosmos",
    "key_name": "testkey",
    "store_prefix": "ibc",
    "max_gas": 900000000,
    "gas_multiplier": 1.0,
    "max_msg_num": 60,
    "max_tx_size": 2097152,
    "clock_drift": "5s",
    "trusting_period": "14days",
    "trust_threshold": {
      "numerator": "1",
      "denominator": "3"
    },
    "gas_price": {
      "price": 0.001,
      "denom": "stake"
    },
    "packet_filter": {
      "policy": "allowall"
    }
  }
}
</code></pre>
<h3 id="get-state"><a class="header" href="#get-state">GET <code>/state</code></a></h3>
<p>This endpoint returns the current state of Hermes,
namely which chains it is connected to, as well as a description
of all the workers which are currently active.</p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/state' | jq
</code></pre>
<pre><code class="language-json">{
  "status": "success",
  "result": {
    "chains": [
      "ibc-0",
      "ibc-1"
    ],
    "workers": {
      "Client": [
        {
          "id": 3,
          "object": {
            "type": "Client",
            "dst_chain_id": "ibc-1",
            "dst_client_id": "07-tendermint-0",
            "src_chain_id": "ibc-0"
          }
        },
        {
          "id": 4,
          "object": {
            "type": "Client",
            "dst_chain_id": "ibc-1",
            "dst_client_id": "07-tendermint-1",
            "src_chain_id": "ibc-0"
          }
        },
        {
          "id": 1,
          "object": {
            "type": "Client",
            "dst_chain_id": "ibc-0",
            "dst_client_id": "07-tendermint-0",
            "src_chain_id": "ibc-1"
          }
        },
        {
          "id": 2,
          "object": {
            "type": "Client",
            "dst_chain_id": "ibc-0",
            "dst_client_id": "07-tendermint-1",
            "src_chain_id": "ibc-1"
          }
        }
      ]
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<p>Acquire advanced knowledge about <code>hermes</code>. In this section, we present a summary of the Hermes' features compared to other relayer implementations, and we provide general guidelines for troubleshooting.</p>
<hr />
<h2 id="sections-7"><a class="header" href="#sections-7">Sections</a></h2>
<ul>
<li>
<p><strong><a href="advanced/./features.html">Features</a></strong></p>
<ul>
<li>Learn about Hermes' features and how it compares to another relayer implementation.</li>
</ul>
</li>
<li>
<p><strong><a href="advanced/./troubleshooting/index.html">Troubleshooting</a></strong></p>
<ul>
<li>Learn the general guidelines regarding troubleshooting.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>This section includes a summary of the supported and planned features. It also includes a feature matrix which compares <code>hermes</code> to the <a href="https://github.com/cosmos/relayer">cosmos-go-relayer</a>.</p>
<blockquote>
<p><strong>Cosmos SDK &amp; IBC compatibility:</strong>
Hermes supports Cosmos SDK chains implementing the <a href="https://github.com/cosmos/ibc">IBC protocol v1</a> protocol specification.
Cosmos SDK versions <code>0.46.0</code> through <code>0.53.x</code> are officially supported.
IBC-go versions <code>6.3.1</code> through <code>10.x</code> are officially supported.
In case Hermes finds an incompatible SDK or IBC-go version, it will output a log warning upon initialization as part of the <code>start</code> command or upon <code>health-check</code> command.</p>
</blockquote>
<hr />
<h2 id="supported-features"><a class="header" href="#supported-features">Supported Features</a></h2>
<ul>
<li>Basic features
<ul>
<li>Create and update clients.</li>
<li>Refresh clients to prevent expiration.</li>
<li>Establish connections with new or existing clients.</li>
<li>Establish channels with new or existing connection.</li>
<li>Channel closing handshake.</li>
<li>Relay packets, acknowledgments, timeout and timeout-on-close packets, with zero or non-zero delay.</li>
<li>Queries for all objects.</li>
</ul>
</li>
<li>Packet relaying over:
<ul>
<li>multiple paths, for the chains in <code>config.toml</code>.</li>
</ul>
</li>
<li>Restart support:
<ul>
<li>Clear packets.</li>
<li>Resume channel handshake if configured to relay <code>all</code>.</li>
<li>Resume connection handshake if configured to relay <code>all</code>.</li>
</ul>
</li>
<li>Client upgrade:
<ul>
<li>Upgrading clients after a counterparty chain has performed an upgrade for IBC breaking changes.</li>
</ul>
</li>
<li>Packet delay:
<ul>
<li>Establish path over non-zero delay connection.</li>
<li>Relay all packets with the specified delay.</li>
</ul>
</li>
<li>Interchain Accounts &amp; Interchain Security
<blockquote>
<p>Relaying between Interchain Security-enabled chains requires Hermes v1.2+.</p>
</blockquote>
</li>
<li>Monitor and submit misbehaviour for clients
<ul>
<li>Monitor client updates for misbehaviour (fork and BFT time violation).</li>
<li>Submit misbehaviour evidence to the reference chain via <code>/broadcast_evidence</code> tendermint RPC.</li>
<li>Submit misbehaviour evidence to the on-chain IBC client in a transaction that includes the <code>MsgMisbehaviour</code> message.</li>
</ul>
<blockquote>
<p>Misbehaviour submission to full node not yet supported.</p>
</blockquote>
</li>
<li>Individual commands that build and send transactions for:
<ul>
<li>Creating and updating IBC Tendermint light clients.</li>
<li>Sending connection open handshake messages.</li>
<li>Sending channel open handshake messages.</li>
<li>Sending channel closing handshake messages.</li>
<li>Initiating a cross chain transfer (mainly for testing).</li>
<li>Relaying sent packets, acknowledgments and timeouts.</li>
<li>Automatically generate a configuration file from the <a href="https://github.com/cosmos/chain-registry">chain-registry</a></li>
<li>Client upgrade.</li>
</ul>
</li>
<li>Channel handshake for existing channel that is not in <code>Open</code> state.</li>
<li>Connection handshake for existing connection that is not in <code>Open</code> state.</li>
<li>Telemetry support.</li>
</ul>
<h2 id="upcoming--unsupported-features"><a class="header" href="#upcoming--unsupported-features">Upcoming / Unsupported Features</a></h2>
<p>Planned features:</p>
<ul>
<li>Interchain Queries</li>
<li>Non-SDK support</li>
<li>Relay from all IBC events, including governance upgrade proposal</li>
<li>Dynamic &amp; automatic configuration management</li>
</ul>
<h2 id="features-matrix"><a class="header" href="#features-matrix">Features matrix</a></h2>
<hr />
<p><strong>Legend</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Term</th><th>Description</th></tr></thead><tbody>
<tr><td>❌</td><td>feature not supported</td></tr>
<tr><td>✅</td><td>feature is supported</td></tr>
<tr><td><code>Chain</code></td><td>chain related</td></tr>
<tr><td><code>Cl</code></td><td>client related</td></tr>
<tr><td><code>Conn</code></td><td>connection related</td></tr>
<tr><td><code>Chan</code></td><td>channel related</td></tr>
<tr><td><code>Cfg</code></td><td>config related</td></tr>
<tr><td><code>.._Handshake_..</code></td><td>can execute all transactions required to finish a handshake from a single command</td></tr>
<tr><td><code>.._&lt;msg&gt;_A</code></td><td>building and sending <code>msg</code> from a command that scans chain state</td></tr>
<tr><td><code>.._&lt;msg&gt;_P</code></td><td>building and sending <code>msg</code> from IBC event; doesn't apply to <code>.._Init</code> and <code>FT_Transfer</code> features</td></tr>
</tbody></table>
</div>
<hr />
<p><strong>Feature comparison between Hermes and the Go relayer</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Features \      Status</th><th style="text-align: center">Hermes</th><th style="text-align: center">Cosmos Go</th><th style="text-align: left">Feature Details</th></tr></thead><tbody>
<tr><td>Feegrant support</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">add <code>feeGranter</code> to tx sign for sending the transactions</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Restart</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">replays any IBC events that happened before restart</td></tr>
<tr><td>Multiple_Paths</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">relays on multiple paths concurrently</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Connection Delay</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td>Cl_Misbehavior</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">monitors and submits IBC client misbehavior</td></tr>
<tr><td>Cl_Refresh</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">periodically refresh an on-chain client to prevent expiration</td></tr>
<tr><td>Packet Delay</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Chan_Unordered</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Ordered</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Cl_Tendermint_Create</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">tendermint light client creation</td></tr>
<tr><td>Cl_Tendermint_Update</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">tendermint light client update</td></tr>
<tr><td>Cl_Tendermint_Upgrade</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">tendermint light client upgrade</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Conn_Open_Handshake_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Conn_Open_Handshake_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Chan_Open_Handshake_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Open_Handshake_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Open_Handshake_Optimistic</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">open a channel on a non-Open connection</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Chan_Close_Handshake_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Close_Handshake_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>FT_Transfer</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">can submit an ICS-20 fungible token transfer message</td></tr>
<tr><td>ICA_Relay</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">can relay ICS-27 Interchain account packets</td></tr>
<tr><td>Interchain Query (ICQ) support</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">interchain querying using ABCI</td></tr>
<tr><td>Cross-chain Queries</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">cross-chain querying between IBC-enabled chains</td></tr>
<tr><td>Packet_Recv_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Recv_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Timeout_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Timeout_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_TimeoutClose_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_TimeoutClose_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Optimistic</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">relay packets over non-Open channels</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Modular Architecture</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">defined interface can be implemented for different chain types</td></tr>
<tr><td>Cl_Non_Tendermint</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">supports non tendermint IBC light clients</td></tr>
<tr><td>Namada support</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left">supports Namada non-cosmos-SDK chain</td></tr>
<tr><td>Penumbra support</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">supports Penumbra non-cosmos-SDK chain</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Cfg_Static</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">provides means for configuration prior to being started</td></tr>
<tr><td>Cfg_Dynamic</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">provides means for configuration and monitoring during runtime</td></tr>
<tr><td>Cfg_Download_Config</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">provides means for downloading recommended configuration</td></tr>
<tr><td>Cfg_Edit_Config</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: left">provides means for editing the configuration from the CLI</td></tr>
<tr><td>Cfg_Validation</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">provides means to validate the current configuration</td></tr>
<tr><td>Telemetry</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">telemetry server to collect metrics</td></tr>
<tr><td>REST API</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left">REST API to interact with the relayer</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>This section provides guidelines regarding troubleshooting.</p>
<hr />
<h2 id="sections-8"><a class="header" href="#sections-8">Sections</a></h2>
<ul>
<li><strong><a href="advanced/troubleshooting/./help-command.html">Help Command</a></strong>
<ul>
<li>Learn about <code>hermes help</code> command, providing a CLI documentation for all <code>hermes</code> commands.</li>
</ul>
</li>
<li><strong><a href="advanced/troubleshooting/./profiling.html">Profiling</a></strong>
<ul>
<li>Learn how to <code>profile</code> your Hermes binary to identify slow methods and bottlenecks.</li>
</ul>
</li>
<li><strong><a href="advanced/troubleshooting/./log-level.html">Parametrize the log level</a></strong>
<ul>
<li>Learn how to configure the <code>log-level</code> to help with debugging.</li>
</ul>
</li>
<li><strong><a href="advanced/troubleshooting/./patch-gaia.html">Patch Gaia</a></strong>
<ul>
<li>Learn how to <code>patch</code> your local gaia chain(s) to enable some corner-case methods (e.g., channel close).</li>
</ul>
</li>
<li><strong><a href="advanced/troubleshooting/./inspect.html">Inspecting the relayer state</a></strong>
<ul>
<li>Learn how to <code>inspect</code> the state of Hermes.</li>
</ul>
</li>
<li><strong><a href="advanced/troubleshooting/./cross-comp-config.html">Cross-stack misconfiguration</a></strong>
<ul>
<li>Learn how to configure Hermes, Tendermint, and the SDK such that they play well with Hermes.</li>
</ul>
</li>
<li><strong><a href="advanced/troubleshooting/./genesis-restart.html">Genesis restart without IBC upgrade proposal</a></strong>
<ul>
<li>Learn how to update a client after a chain undergoes a genesis restart without an IBC upgrade proposal.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help-command"><a class="header" href="#help-command">Help command</a></h1>
<p>The CLI comprises a special <code>help</code> command, which accepts as parameter other commands, and provides guidance on what is the correct way to invoke those commands.</p>
<blockquote>
<p><strong>NOTE</strong>: This special <code>help</code> command is preferred as it will display the full help
message.</p>
</blockquote>
<p>For instance,</p>
<pre><code class="language-shell">hermes help create
</code></pre>
<p>will provide details about all the valid invocations of the <code>create</code> CLI command.</p>
<pre><code>DESCRIPTION:
Create objects (client, connection, or channel) on chains

USAGE:
    hermes create &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    channel       Create a new channel between two chains
    client        Create a new IBC client
    connection    Create a new connection between two chains
    help          Print this message or the help of the given subcommand(s)
</code></pre>
<p>This can provide further specific guidance if we add additional parameters, e.g.,</p>
<pre><code class="language-shell">hermes help create channel
</code></pre>
<pre><code class="language-shell">DESCRIPTION:
Create a new channel between two chains.

Can create a new channel using a pre-existing connection or alternatively, create a new client and a
new connection underlying the new channel if a pre-existing connection is not provided.

USAGE:
    hermes create channel [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --a-connection &lt;A_CONNECTION_ID&gt; --a-port &lt;A_PORT_ID&gt; --b-port &lt;B_PORT_ID&gt;

    hermes create channel [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --b-chain &lt;B_CHAIN_ID&gt; --a-port &lt;A_PORT_ID&gt; --b-port &lt;B_PORT_ID&gt; --new-client-connection

OPTIONS:
        --channel-version &lt;VERSION&gt;
            The version for the new channel
            
            [aliases: chan-version]

    -h, --help
            Print help information

        --new-client-connection
            Indicates that a new client and connection will be created underlying the new channel
            
            [aliases: new-client-conn]

        --order &lt;ORDER&gt;
            The channel ordering, valid options 'unordered' (default) and 'ordered'
            
            [default: ORDER_UNORDERED]

        --yes
            Skip new_client_connection confirmation

FLAGS:
        --a-chain &lt;A_CHAIN_ID&gt;
            Identifier of the side `a` chain for the new channel

        --a-connection &lt;A_CONNECTION_ID&gt;
            Identifier of the connection on chain `a` to use in creating the new channel
            
            [aliases: a-conn]

        --a-port &lt;A_PORT_ID&gt;
            Identifier of the side `a` port for the new channel

        --b-chain &lt;B_CHAIN_ID&gt;
            Identifier of the side `b` chain for the new channel

        --b-port &lt;B_PORT_ID&gt;
            Identifier of the side `b` port for the new channel
</code></pre>
<p>Additionally, the <code>-h</code>/<code>--help</code> flags typical for CLI applications work on
all commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiling"><a class="header" href="#profiling">Profiling</a></h1>
<p>The <code>relayer</code> crate provides a <code>time!</code> macro which can be used to measure how much time is spent between the invocation of the macro and the end of the enclosing scope.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>The <code>time!</code> macro has no effect unless the <code>--debug=profiling</code> global flag is specified on the command-line:</p>
<pre><code class="language-shell">$ hermes --debug=profiling start
</code></pre>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_function(x: u32) -&gt; u32 {
    time!("myfunction: x={}", x); // A

    std::thread::sleep(Duration::from_secs(1));

    {
        time!("inner operation"); // B

        std::thread::sleep(Duration::from_secs(2));

        // timer B ends here
    }

    x + 1

    // timer A ends here
}
<span class="boring">}</span></code></pre></pre>
<h4 id="console-output"><a class="header" href="#console-output">Console output</a></h4>
<pre><code>Jan 20 11:28:46.841  INFO relayer::macros::profiling: ⏳ myfunction: x=42 - start
Jan 20 11:28:47.842  INFO relayer::macros::profiling:    ⏳ inner operation - start
Jan 20 11:28:49.846  INFO relayer::macros::profiling:    ⏳ inner operation - elapsed: 2004ms
Jan 20 11:28:49.847  INFO relayer::macros::profiling: ⏳ myfunction: x=42 - elapsed: 3005ms
</code></pre>
<p>Profiling is useful for tracking down unusually slow methods.
Each transaction or query usually consists of multiple lower-level methods,
and it's often not clear which of these are the culprit for low performance.
With profiling enabled, <code>hermes</code> will output timing information for individual
methods involved in a command.</p>
<p><strong>NOTE</strong>: To be able to see the profiling output, the [log level][log-level] should be <code>info</code> level or lower.</p>
<h5 id="example-output-for-tx-conn-init-command"><a class="header" href="#example-output-for-tx-conn-init-command">Example output for <code>tx conn-init</code> command</a></h5>
<pre><code>hermes tx conn-init --dst-chain ibc-0 --src-chain ibc-1 --dst-client 07-tendermint-0 --src-client 07-tendermint-0

</code></pre>
<pre><code>Apr 13 20:58:21.225  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - start
Apr 13 20:58:21.230  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - elapsed: 4ms
Apr 13 20:58:21.230  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - start
Apr 13 20:58:21.235  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - elapsed: 5ms
Apr 13 20:58:21.235  INFO ibc_relayer::event::monitor: running listener chain.id=ibc-1
Apr 13 20:58:21.236  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - start
Apr 13 20:58:21.239  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - elapsed: 2ms
Apr 13 20:58:21.239  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - start
Apr 13 20:58:21.244  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - elapsed: 4ms
Apr 13 20:58:21.244  INFO ibc_relayer::event::monitor: running listener chain.id=ibc-0
Apr 13 20:58:21.244  INFO ibc_relayer::macros::profiling: ⏳ get_signer - start
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling: ⏳ get_signer - elapsed: 1ms
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling: ⏳ query_latest_height - start
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.248  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 1ms
Apr 13 20:58:21.249  INFO ibc_relayer::macros::profiling: ⏳ query_latest_height - elapsed: 3ms
Apr 13 20:58:21.250  INFO ibc_relayer::macros::profiling: ⏳ unbonding_period - start
Apr 13 20:58:21.250  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.251  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 0ms
Apr 13 20:58:21.270  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.273  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 2ms
Apr 13 20:58:21.273  INFO ibc_relayer::macros::profiling: ⏳ unbonding_period - elapsed: 23ms
Apr 13 20:58:21.279  INFO ibc_relayer::macros::profiling: ⏳ build_consensus_state - start
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling: ⏳ build_consensus_state - elapsed: 0ms
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling: ⏳ send_msgs - start
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling:    ⏳ send_tx - start
Apr 13 20:58:21.282  INFO ibc_relayer::macros::profiling:       ⏳ PK "03f17d2c094ee68cfcedb2c2f2b7dec6cd82ea158ac1c32d3de0ca8b288a3c8bfa" - start
Apr 13 20:58:21.282  INFO ibc_relayer::macros::profiling:          ⏳ block_on - start
Apr 13 20:58:21.285  INFO ibc_relayer::macros::profiling:          ⏳ block_on - elapsed: 3ms
Apr 13 20:58:21.296  INFO ibc_relayer::macros::profiling:             ⏳ block_on - start
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:             ⏳ block_on - elapsed: 1367ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:       ⏳ PK "03f17d2c094ee68cfcedb2c2f2b7dec6cd82ea158ac1c32d3de0ca8b288a3c8bfa" - elapsed: 1382ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:    ⏳ send_tx - elapsed: 1384ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling: ⏳ send_msgs - elapsed: 1384ms
Success: CreateClient(
    CreateClient(
        Attributes {
            height: Height {
                revision: 0,
                height: 10675,
            },
            client_id: ClientId(
                "07-tendermint-7",
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 1,
                height: 10663,
            },
        },
    ),
)
</code></pre>
<h4 id="json-output"><a class="header" href="#json-output">JSON output</a></h4>
<p>Additionally, if the <code>--debug=profiling-json</code> flag is specified, Hermes will output profiling information in
JSON format in a file named <code>hermes-YYYY-MM-DD-HHMMSS-prof.json</code>, in the directory specified in the <code>PROFILING_DIR</code>
env variable, or the current directory otherwise.</p>
<blockquote>
<p><strong>NOTE</strong>: Outputting profiling information in JSON format in a file is only available for the <code>hermes start</code> command.
This debug option won't do anything with the other CLIs.</p>
</blockquote>
<pre><code class="language-json">{"name":"fetch_node_info","src_chain":"ibc-0","elapsed":6}
{"name":"chain_status","src_chain":"ibc-0","elapsed":12}
{"name":"query_config_params","src_chain":"ibc-0","elapsed":3}
{"name":"min_gas_price","src_chain":"ibc-0","elapsed":3}
{"name":"query_staking_params","src_chain":"ibc-0","elapsed":159}
{"name":"historical_entries","src_chain":"ibc-0","elapsed":329}
{"name":"query_staking_params","src_chain":"ibc-0","elapsed":121}
{"name":"unbonding_period","src_chain":"ibc-0","elapsed":12}
{"name":"query_latest_height","src_chain":"ibc-0","elapsed":8}
{"name":"fetch_node_info","src_chain":"ibc-1","elapsed":9}
{"name":"chain_status","src_chain":"ibc-1","elapsed":43}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parametrize-the-log-level"><a class="header" href="#parametrize-the-log-level">Parametrize the log level</a></h1>
<p>This section explains how to parametrize the log output level of <code>hermes</code>.</p>
<p>The configuration file permits parametrization of output verbosity via the knob called <code>log_level</code>.
This file is loaded by default from <code>$HOME/.hermes/config.toml</code>, but can be overridden in all commands
with the <code>--config</code> flag, e.g. <code>hermes --config $CONFIGPATH subcommand</code>.</p>
<p>Relevant snippet:</p>
<pre><code class="language-toml">[global]
log_level = 'error'
</code></pre>
<p>Valid options for <code>log_level</code> are: 'error', 'warn', 'info', 'debug', 'trace'.
These levels correspond to the tracing subcomponent of the relayer-cli,
<a href="https://docs.rs/tracing-core/0.1.17/tracing_core/struct.Level.html">see here</a>.</p>
<p>Hermes will <em>always</em> print a last line summarizing the result of its
operation for queries or transactions. In addition to this last line,
arbitrary debug, info, or other outputs may be produced.</p>
<h2 id="overriding-the-tracing-filter-using-rust_log"><a class="header" href="#overriding-the-tracing-filter-using-rust_log">Overriding the tracing filter using <code>RUST_LOG</code></a></h2>
<p>For debugging purposes, we may want to inspect which RPC queries Hermes is making.
Hermes makes use of the <code>tendermint-rpc</code> library to issue RPC queries, but
the output of this library is by default turned off in order to keep the logs more
readable.</p>
<p>Using the <code>RUST_LOG</code> environment variable, we can turn logging on for the
<code>tendermint-rpc</code> library, as follows:</p>
<pre><code>RUST_LOG=tendermint-rpc=debug,info hermes start
</code></pre>
<p>Setting the <code>RUST_LOG</code> environment variable to <code>tendermint_rpc=debug,info</code> instructs
Hermes to set the log level of the <code>tendermint_rpc</code> crate to <code>debug</code> and otherwise
use the <code>info</code> log level.</p>
<blockquote>
<p><strong>Note:</strong> While the <code>tendermint-rpc</code> contains a dash in its name, the logging filter
expects a module name, which can only contain alphanumeric characters and underscores,
hence why the filter above is written <code>tendermint_rpc=debug</code>.</p>
</blockquote>
<p><strong>Example:</strong></p>
<pre><code>❯ RUST_LOG=tendermint_rpc=debug,info hermes start
2022-02-24T14:32:14.039555Z  INFO ThreadId(01) using default configuration from '/Users/coromac/.hermes/config.toml'
2022-02-24T14:32:14.043500Z  INFO ThreadId(01) telemetry service running, exposing metrics at http://127.0.0.1:3001/metrics
2022-02-24T14:32:14.043542Z  INFO ThreadId(01) [rest] address not configured, REST server disabled
2022-02-24T14:32:14.049759Z DEBUG ThreadId(01) Incoming response: {
  "jsonrpc": "2.0",
  "id": "143b4580-c49e-47c1-81b2-4e7090f6e762",
  "result": {
    "node_info": {
      "protocol_version": {
        "p2p": "8",
        "block": "11",
        "app": "0"
      },
      "id": "73f9134539f9845cd253dc302e36d48ee4c0f32d",
      "listen_addr": "tcp://0.0.0.0:27003",
      "network": "ibc0",
      "version": "v0.34.14",
      "channels": "40202122233038606100",
      "moniker": "ibc0",
      "other": {
        "tx_index": "on",
        "rpc_address": "tcp://0.0.0.0:27000"
      }
    },
    "sync_info": {
      "latest_block_hash": "8396B93E355AD80EED8167A04BB9858A315A8BEB482547DE16A6CD82BC11551B",
      "latest_app_hash": "22419E041D6997EE75FF66F7F537A3D36122B220EAB89A9C246FEF680FB1C97A",
      "latest_block_height": "86392",
      "latest_block_time": "2022-02-24T14:32:08.673989Z",
      "earliest_block_hash": "0A73CFE8566D4D4FBFE3178D9BCBAD483FD689854CA8012FF1457F8EC4598132",
      "earliest_app_hash": "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855",
      "earliest_block_height": "1",
      "earliest_block_time": "2022-01-20T09:04:21.549736Z",
      "catching_up": false
    },
    "validator_info": {
      "address": "6FD56E6AA1EEDAD227AFAB6B9DE631719D4A3691",
      "pub_key": {
        "type": "tendermint/PubKeyEd25519",
        "value": "mR5V/QWOv/mJYyNmlsl3mfxKy1PNaOzdztyas4NF2BA="
      },
      "voting_power": "10"
    }
  }
}
2022-02-24T14:32:14.052503Z DEBUG ThreadId(21) Incoming response: {
  "jsonrpc": "2.0",
  "id": "0ca35e64-ea98-4fbf-bd66-c3291128ace9",
  "result": {}
}

...
</code></pre>
<p>The two DEBUG log lines above were emitted by the <code>tendermint-rpc</code> crate.</p>
<h2 id="overriding-the-tracing-filter-during-runtime"><a class="header" href="#overriding-the-tracing-filter-during-runtime">Overriding the tracing filter during Runtime</a></h2>
<p>If you have the <code>tracing_server</code> enabled:</p>
<pre><code class="language-toml">[tracing_server]
enabled = true
port = 5555
</code></pre>
<p>You can update the tracing filter without restarting your instance. There are two commands allowing you to do so, the first is safer but more limited while the second is more complete it is harder to use.</p>
<h3 id="limited-command"><a class="header" href="#limited-command">Limited command</a></h3>
<p>If possible use the <a href="advanced/troubleshooting/../../../documentation/commands/logs/index.html#log-level">log-level</a> command as the results are guaranteed.</p>
<p><strong>Examples</strong></p>
<p>The following command is equivalent to running the Hermes instance with <code>RUST_LOG=ibc=debug hermes start</code>:</p>
<pre><code class="language-shell">hermes logs set-log-level --log-filter ibc --log-level debug

</code></pre>
<p>It is also possible to only change the <code>tendermint_rpc</code> log level:</p>
<pre><code class="language-shell">hermes logs set-log-level --log-filter tendermint_rpc --log-level debug

</code></pre>
<p>If the <code>--log-filter</code> is not specified, the log level will be set for all targets.</p>
<h3 id="raw-command"><a class="header" href="#raw-command">Raw command</a></h3>
<p>The raw command is much more powerful but harder to use. This will send the directive you want to tracing, allowing you to specify more precise filters.</p>
<blockquote>
<p><strong>NOTE</strong>: Use with caution as this might end up hiding important logs.</p>
</blockquote>
<p><strong>Example</strong></p>
<p>The following command will only display logs which have a field <code>channel=channel-1</code> by setting the <code>&lt;RAW_FILTER&gt;</code> to <code>"[{channel=channel-1}]"</code>:</p>
<pre><code class="language-shell">hermes logs set-raw-filter --raw-filter &lt;RAW_FILTER&gt;

</code></pre>
<h3 id="reset-command"><a class="header" href="#reset-command">Reset command</a></h3>
<p>This command allows you to easily restore the log level using the level configured in <code>config.toml</code>. This would be equivalent to starting the Hermes instance with <code>hermes start</code>.</p>
<pre><code class="language-shell">hermes logs reset

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patch-gaia"><a class="header" href="#patch-gaia">Patch Gaia</a></h1>
<p>The guide below refers specifically to patching your gaia chain so that the
relayer can initiate the closing of channels by submitting a <a href="advanced/troubleshooting/../../documentation/commands/tx/channel-close.html#channel-close-init"><code>ChanCloseInit</code></a> message.
Without this modification, the transaction will be rejected.
We also describe how to test the channel closing feature.</p>
<ul>
<li>
<p>Clone the Cosmos SDK</p>
<pre><code class="language-shell">git clone https://github.com/cosmos/cosmos-sdk.git ~/go/src/github.com/cosmos/cosmos-sdk
cd ~/go/src/github.com/cosmos/cosmos-sdk
</code></pre>
</li>
<li>
<p>Apply these diffs:</p>
<pre><code>   --- a/x/ibc/applications/transfer/module.go
   +++ b/x/ibc/applications/transfer/module.go
   @@ -305,7 +305,7 @@ func (am AppModule) OnChanCloseInit(
           channelID string,
    ) error {
           // Disallow user-initiated channel closing for transfer channels
   -       return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "user cannot close channel")
   +       return nil
    }
</code></pre>
</li>
<li>
<p>Append the line below (watch for the placeholder <code>&lt;your&gt;</code>) as the last line
in your <code>go.mod</code> in the <code>gaia</code> clone:</p>
</li>
</ul>
<p><code>replace github.com/cosmos/cosmos-sdk =&gt; /Users/&lt;your&gt;/go/src/github.com/cosmos/cosmos-sdk</code></p>
<ul>
<li>Now <code>make build</code> and <code>make install</code> your local copy of <code>gaia</code></li>
</ul>
<p>In order to test the correct operation during the channel close, perform the steps below.</p>
<ul>
<li>
<p>The channel should be in state open-open:</p>
</li>
<li>
<p>Transfer of 5555 <code>samoleans</code> from <code>ibc-1</code> to <code>ibc-0</code>. This results in a
Tx to <code>ibc-1</code> for a <code>MsgTransfer</code> packet.
Make sure you're not relaying this packet (Hermes should not be running on this path).</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-height-offset 1000 --denom samoleans --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-1 --amount 5555

</code></pre>
</li>
<li>
<p>Now do the first step of channel closing: the channel will transition
to close-open:</p>
<pre><code class="language-shell">hermes tx chan-close-init --dst-chain ibc-0 --src-chain ibc-1 --dst-connection connection-0 --dst-port transfer --src-port transfer --dst-channel channel-0 --src-channel channel-1

</code></pre>
</li>
<li>
<p>Trigger timeout on close to ibc-1</p>
<pre><code class="language-shell">hermes tx packet-recv --dst-chain ibc-0 --src-chain ibc-1 --src-port transfer --src-channel channel-1

</code></pre>
</li>
<li>
<p>Close the channel</p>
<pre><code class="language-shell">hermes tx chan-close-confirm --dst-chain ibc-1 --src-chain ibc-0 --dst-connection connection-1 --dst-port transfer --src-port transfer --dst-channel channel-1 --src-channel channel-0

</code></pre>
</li>
<li>
<p>Verify that the two ends are in Close state:</p>
<pre><code class="language-shell">hermes query channel end --chain ibc-0 --port transfer --channel channel-0

hermes query channel end --chain ibc-1 --port transfer --channel channel-1

</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspecting-the-relayer-state"><a class="header" href="#inspecting-the-relayer-state">Inspecting the relayer state</a></h1>
<p>To get some insight into the state of Hermes,
Hermes will react to a <code>SIGUSR1</code> signal by dumping its state to
the console, either in plain text form or as a JSON object if Hermes
was started with the <code>--json</code> option.</p>
<p>To send a <code>SIGUSR1</code> signal to Hermes, look up its process ID (below PID)
and use the following command:</p>
<pre><code class="language-shell">kill -SIGUSR1 PID
</code></pre>
<p>Hermes will print some information about the workers which are currently running.</p>
<p>For example, with three chains configured and one channel between each pair of chains:</p>
<pre><code class="language-text">INFO Dumping state (triggered by SIGUSR1)
INFO
INFO * Chains: ibc-0, ibc-1, ibc-2
INFO * Client workers:
INFO   - client::ibc-0-&gt;ibc-1:07-tendermint-0 (id: 5)
INFO   - client::ibc-0-&gt;ibc-2:07-tendermint-0 (id: 9)
INFO   - client::ibc-1-&gt;ibc-0:07-tendermint-0 (id: 1)
INFO   - client::ibc-1-&gt;ibc-2:07-tendermint-1 (id: 11)
INFO   - client::ibc-2-&gt;ibc-0:07-tendermint-1 (id: 3)
INFO   - client::ibc-2-&gt;ibc-1:07-tendermint-1 (id: 7)
INFO * Packet workers:
INFO   - packet::channel-0/transfer:ibc-0-&gt;ibc-1 (id: 2)
INFO   - packet::channel-0/transfer:ibc-1-&gt;ibc-0 (id: 6)
INFO   - packet::channel-0/transfer:ibc-2-&gt;ibc-0 (id: 10)
INFO   - packet::channel-1/transfer:ibc-0-&gt;ibc-2 (id: 4)
INFO   - packet::channel-1/transfer:ibc-1-&gt;ibc-2 (id: 8)
INFO   - packet::channel-1/transfer:ibc-2-&gt;ibc-1 (id: 12)
</code></pre>
<p>or in JSON form (prettified):</p>
<pre><code class="language-json">{
  "timestamp": "Jul 12 17:04:37.244",
  "level": "INFO",
  "fields": {
    "message": "Dumping state (triggered by SIGUSR1)"
  }
}
{
  "chains": [
    "ibc-0",
    "ibc-1",
    "ibc-2"
  ],
  "workers": {
    "Client": [
      {
        "id": 5,
        "object": {
          "type": "Client",
          "dst_chain_id": "ibc-1",
          "dst_client_id": "07-tendermint-0",
          "src_chain_id": "ibc-0"
        }
      },
      {
        "id": 9,
        "object": {
          "type": "Client",
          "dst_chain_id": "ibc-2",
          "dst_client_id": "07-tendermint-0",
          "src_chain_id": "ibc-0"
        }
      },
      {
        "id": 1,
        "object": {
          "type": "Client",
          "dst_chain_id": "ibc-0",
          "dst_client_id": "07-tendermint-0",
          "src_chain_id": "ibc-1"
        }
      },
      {
        "id": 11,
        "object": {
          "type": "Client",
          "dst_chain_id": "ibc-2",
          "dst_client_id": "07-tendermint-1",
          "src_chain_id": "ibc-1"
        }
      },
      {
        "id": 3,
        "object": {
          "type": "Client",
          "dst_chain_id": "ibc-0",
          "dst_client_id": "07-tendermint-1",
          "src_chain_id": "ibc-2"
        }
      },
      {
        "id": 7,
        "object": {
          "type": "Client",
          "dst_chain_id": "ibc-1",
          "dst_client_id": "07-tendermint-1",
          "src_chain_id": "ibc-2"
        }
      }
    ],
    "Packet": [
      {
        "id": 2,
        "object": {
          "type": "Packet",
          "dst_chain_id": "ibc-1",
          "src_chain_id": "ibc-0",
          "src_channel_id": "channel-0",
          "src_port_id": "transfer"
        }
      },
      {
        "id": 6,
        "object": {
          "type": "Packet",
          "dst_chain_id": "ibc-0",
          "src_chain_id": "ibc-1",
          "src_channel_id": "channel-0",
          "src_port_id": "transfer"
        }
      },
      {
        "id": 10,
        "object": {
          "type": "Packet",
          "dst_chain_id": "ibc-0",
          "src_chain_id": "ibc-2",
          "src_channel_id": "channel-0",
          "src_port_id": "transfer"
        }
      },
      {
        "id": 4,
        "object": {
          "type": "Packet",
          "dst_chain_id": "ibc-2",
          "src_chain_id": "ibc-0",
          "src_channel_id": "channel-1",
          "src_port_id": "transfer"
        }
      },
      {
        "id": 8,
        "object": {
          "type": "Packet",
          "dst_chain_id": "ibc-2",
          "src_chain_id": "ibc-1",
          "src_channel_id": "channel-1",
          "src_port_id": "transfer"
        }
      },
      {
        "id": 12,
        "object": {
          "type": "Packet",
          "dst_chain_id": "ibc-1",
          "src_chain_id": "ibc-2",
          "src_channel_id": "channel-1",
          "src_port_id": "transfer"
        }
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hermes-versus-appsdktendermint-configuration"><a class="header" href="#hermes-versus-appsdktendermint-configuration">Hermes versus App/SDK/Tendermint Configuration</a></h1>
<p>This table summarizes the different configuration parameter combinations that may cause Hermes to raise errors. It gives some information on the failure type and refers to the relevant section of the guide for more information.
Following notations are used:</p>
<ul>
<li><code>tendermint.&lt;parameter&gt;</code>:
<ul>
<li><code>tendermint</code> refers to the Tendermint configuration file <code>config.toml</code></li>
<li><code>&lt;parameter&gt;</code> refers to the parameter in this file.</li>
</ul>
</li>
<li><code>app.&lt;parameter&gt;</code>:
<ul>
<li><code>app</code> refers to the application configuration file <code>app.toml</code></li>
<li><code>&lt;parameter&gt;</code> refers to the parameter in this file.</li>
</ul>
</li>
<li><code>genesis.&lt;parameter&gt;</code>:</li>
<li><code>genesis</code> refers to the application configuration file <code>genesis.json</code></li>
<li><code>&lt;parameter&gt;</code> refers to the parameter in this file.</li>
</ul>
<p><strong>Hermes vs other configuration parameters that may cause Hermes failures</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Hermes</th><th>Other</th><th>Details</th></tr></thead><tbody>
<tr><td><code>sequential_batch_tx = false</code></td><td><code>tendermint.recheck = false</code></td><td><a href="advanced/troubleshooting/cross-comp-config.html#recheck"><code>Mismatch</code><br/><code>(expected &lt; got)</code></a></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td><code>gas_price = x</code></td><td><code>app.minimum-gas-prices = y, </code><br/><code>with x &lt; y</code></td><td><a href="advanced/troubleshooting/cross-comp-config.html#minimum-gas-price"><code>Insufficient fees</code></a></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td><code>gas_price = x</code> <br/> <code>gas_multipler = 1.0</code></td><td><code>app.minimum-gas-prices = x</code></td><td><a href="advanced/troubleshooting/cross-comp-config.html#out-of-gas"><code>Out of gas</code></a></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td><code>max_tx_size = x</code></td><td><code>tendermint.max_tx_bytes = y,</code><br/><code>with x &lt; y</code></td><td><a href="advanced/troubleshooting/cross-comp-config.html#maximum-tx-size"><code>Tx too large</code></a></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td></td><td><code>07-tendermint not in</code><br/><code>genesis.app_state</code><br/><code>.ibc.client_genesis.params</code><br/><code>.allowed_clients</code></td><td><a href="advanced/troubleshooting/cross-comp-config.html#allowed-clients"><code>Client not </code><br/><code>allowed</code><br/><code>(07-tendermint)</code></a></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td><code>during connection creation</code></td><td><code>genesis.app_state</code><br/><code>.staking.params</code><br/><code>.historical_entries  = 0</code></td><td><a href="advanced/troubleshooting/cross-comp-config.html#historical-entries"><code>No historical info</code></a></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td><code>ref_chain.clock_drift +</code><br/><code>tgt_chain.clock_drift +</code><br/><code>tgt_chain.max_block_time</code><br/><code>= x</code></td><td><code>tendermint.consensus.* =&gt; y block time,</code><br/><code>with x &lt; y</code></td><td><a href="advanced/troubleshooting/cross-comp-config.html#header-in-the-future"><code>Header in the future</code> </a></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td><code>max_block_delay = x</code></td><td><code>genesis.app_state</code><br/><code>.ibc.connection_genesis.params</code><br/><code>.max_expected_time_per_block = y</code><br/><code>with x &lt; y</code></td><td><a href="advanced/troubleshooting/cross-comp-config.html#block-delay-not-reached"><code>Block delay not reached</code></a></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td><code>key_name = &lt;wallet_name&gt;</code></td><td></td><td><a href="advanced/troubleshooting/cross-comp-config.html#insufficient-funds"><code>Insufficient funds</code></a></td></tr>
<tr><td></td><td><code>app.pruning = "custom",</code><br/><code>app.pruning-keep-recent= w,</code><br/><code>app.pruning-keep-every = x,</code><br/><code>app.pruning-interval = y,</code><br/><code>app.min-retain-blocks = z,</code><br/><code>genesis.consensus_params.evidence.max_age_num_blocks = e,</code><br/><code>genesis.consensus_params.evidence.max_age_duration = d</code></td><td><a href="advanced/troubleshooting/cross-comp-config.html#uncleared-pending-packets"><code>Uncleared packets</code></a></td></tr>
</tbody></table>
</div>
<h2 id="recheck"><a class="header" href="#recheck">Recheck</a></h2>
<p>When relaying packets, Hermes may send up multiple transactions to the full node's mempool. Hermes uses the  <code>broadcast_tx_sync</code> RPC which does some basic verification and then returns the Tx hash back.</p>
<p>Unless configured with <code>sequential_batch_tx = true</code>, Hermes does not wait for a transaction to be included in a block before sending the next transaction. For this to be possible, Hermes keeps track of the account sequence number locally, incrementing it after each successful <code>broadcast_tx_sync</code> RPC.</p>
<p>During peak periods, it is possible that not all Tx-es in the mempool are included in a block. In order for new transactions to be accepted along with the pending Tx-es, the full node must be configured with <code>recheck = true</code>. Otherwise, Hermes may get the following error:</p>
<pre><code>2022-10-25T13:52:51.369822Z  WARN ThreadId(18) send_messages_and_wait_commit
  {chain=ibc-0 tracking_id=ft-transfer}:send_tx_with_account_sequence_retry{chain=ibc-0 account.sequence=88}: 
    failed to broadcast tx because of a mismatched account sequence number, refreshing account sequence number and 
      retrying once response=Response { code: Err(32), data: Data([]), log: Log("account sequence mismatch, 
        expected 69, got 88: incorrect account sequence"), 
      hash: transaction::Hash(DFC53B04CE095CD045E4E89D7CEB095BF977B876FD8D3FB1A7F0AC288B58B9C4) }
</code></pre>
<h3 id="fix"><a class="header" href="#fix">Fix</a></h3>
<p>Ensure that the full node is configured with <code>recheck = true</code>.
This ensures that the mempool rechecks the Tx-es left in the mempool before accepting new incoming transactions, therefore maintaining the order of transactions.</p>
<h2 id="minimum-gas-price"><a class="header" href="#minimum-gas-price">Minimum Gas Price</a></h2>
<p>Hermes sends transactions using the <code>gas_price</code> parameter from the chain section in the Hermes <code>config.toml</code> configuration file. The full node will not accept any transactions with a gas price smaller than what is configured for the applications (<code>app.minimum-gas-prices</code>) and Hermes will log an <code>insufficient fees</code> error:</p>
<pre><code>2022-10-27T12:45:07.820543Z ERROR ThreadId(18) send_messages_and_wait_commit{chain=ibc-0 tracking_id=ft-transfer}:
  send_tx_with_account_sequence_retry{chain=ibc-0 account.sequence=48}: failed to broadcast tx with unrecoverable error
     response=Response { code: Err(13), data: Data([]), log: Log("insufficient fees; got: 99stake required: 198stake: insufficient fee"), 
       hash: transaction::Hash(AFB9FE23DE9108D349B8679561D7F00DF00863749D7827C3972DFB391CF8E526) } 
         diagnostic=the price configuration for this chain may be too low! please check the `gas_price.price` Hermes config.toml
ERROR transfer error: tx response event consists of an error: check_tx (broadcast_tx_sync) on chain ibc-0 for 
  Tx hash AFB9FE23DE9108D349B8679561D7F00DF00863749D7827C3972DFB391CF8E526 reports error: 
    vcode=Err(13), log=Log("insufficient fees; got: 99stake required: 198stake: insufficient fee")
</code></pre>
<h3 id="fix-1"><a class="header" href="#fix-1">Fix</a></h3>
<p>Ensure that the <code>gas_price.price</code> parameter in the chain section of the Hermes <code>config.toml</code> configuration file is greater than or equal to the <code>app.minimum-gas-prices</code>.</p>
<h2 id="out-of-gas"><a class="header" href="#out-of-gas">Out of Gas</a></h2>
<p>Before Hermes sends a transaction, it estimates how much gas the transaction will require by calling the <code>SimulateTx()</code> gRPC. This returns the amount of gas that the Tx requires given the application state at the time of the call. It is possible that by the time the transaction is sent and checked by the application, the amount of gas required has increased. To help alleviate this, the gas estimation is adjusted upward by multiplying it by the <code>gas_multiplier</code> parameter: <code>gas_multiplier * simulated_gas</code>.</p>
<p>If the adjusted amount of gas ends up still being not enough for the transaction to be successfully submitted, e.g., the <code>gas_multiplier</code> parameter is set to <code>1.0</code> such that no adjustment is actually performed, Hermes returns the following error:</p>
<pre><code>ERROR transfer error: tx response event consists of an error: deliver_tx for 496835FF5A2F73F38ADA416506F7F1143BBD570E77217DC309CAD979924F0E70 reports error: code=Err(11), log=Log("out of gas in location: WriteFlat; gasWanted: 990000, gasUsed: 990724: out of gas")
</code></pre>
<h3 id="fix-2"><a class="header" href="#fix-2">Fix</a></h3>
<p>Ensure that the <code>gas_multiplier</code> parameter in the chain section of the Hermes <code>config.toml</code> configuration file is configured such that it allows some increase over the simulated gas. A good value is for example <code>1.1</code>.</p>
<h2 id="maximum-tx-size"><a class="header" href="#maximum-tx-size">Maximum Tx Size</a></h2>
<p>When Hermes relays packets or handshake messages, it will build multi-message Tx-es with up to <code>max_num_msgs</code> number of messages or up to a Tx size of <code>max_tx_size</code> bytes. The full node accepts only Tx-es with size up to the <code>max_tx_bytes</code> parameter in its <code>config.toml</code>. If a Tx is too large, the full node rejects them with the following error:</p>
<pre><code>2022-10-27T13:59:43.650251Z ERROR ThreadId(18) send_messages_and_wait_commit{chain=ibc-0 tracking_id=ft-transfer}:send_tx_with_account_sequence_retry{chain=ibc-0 account.sequence=159}: gas estimation failed or encountered another unrecoverable error error=RPC error to endpoint http://127.0.0.1:26657/: response error: Internal error: Tx too large. Max size is 500, but got 615 (code: -32603)
ERROR transfer error: failed while submitting the Transfer message to chain ibc-0: RPC error to endpoint http://127.0.0.1:26657/: response error: Internal error: Tx too large. Max size is 500, but got 615 (code: -32603)
</code></pre>
<h3 id="fix-3"><a class="header" href="#fix-3">Fix</a></h3>
<p>Ensure that the <code>max_tx_size</code> parameter configured for Hermes is smaller than the <code>max_tx_bytes</code> parameter configured for the full node.</p>
<h2 id="allowed-clients"><a class="header" href="#allowed-clients">Allowed Clients</a></h2>
<p>The SDK chain genesis file contains a list of allowed clients that can be created on a chain. If the chain is configured with <code>genesis.app_state.ibc.client_genesis.allowed_clients</code> that doesn't include <code>07-tendermint</code>, then the chain will not allow tendermint IBC clients to be created and Hermes cannot open an IBC connection with this chain. When attempting to create a client in this scenario, Hermes will get the following error:</p>
<pre><code>2022-10-27T14:48:04.632320Z ERROR ThreadId(35) send_messages_and_wait_commit{chain=ibc-0 tracking_id=create client}:send_tx_with_account_sequence_retry{chain=ibc-0 account.sequence=0}:estimate_gas: failed to simulate tx. propagating error to caller: gRPC call failed with status: status: Unknown, message: "failed to execute message; message index: 0: client state type 07-tendermint is not registered in the allowlist: invalid client type [cosmos/ibc-go/v3@v3.0.0/modules/core/02-client/keeper/client.go:22] With gas wanted: '0' and gas used: '64671' ", details: [], metadata: MetadataMap { headers: {"content-type": "application/grpc", "x-cosmos-block-height": "9"} }
</code></pre>
<h3 id="fix-4"><a class="header" href="#fix-4">Fix</a></h3>
<p>Ensure that the <code>genesis.app_state.ibc.client_genesis.allowed_clients</code> parameter in the chain genesis file includes <code>07-tendermint</code>.</p>
<h2 id="historical-entries"><a class="header" href="#historical-entries">Historical Entries</a></h2>
<p>The presence of recent consensus states on a chain is required when processing some connection handshake messages, such as <code>MsgConnectionOpenTry</code> and <code>MsgConnectionOpenAck</code>. Such message types require proof verification that the counterparty chain has a valid client for this chain.
If the chain is configured with <code>genesis.app_state.staking.params.historical_entries = 0</code>, then the chain will not store historical consensus state information and Hermes cannot open IBC connections with this chain. It will report an error message which looks like this:</p>
<pre><code>2022-10-27T14:54:51.076598Z ERROR ThreadId(18) send_messages_and_wait_commit{chain=ibc-0 tracking_id=ConnectionOpenAck}:send_tx_with_account_sequence_retry{chain=ibc-0 account.sequence=6}:estimate_gas: failed to simulate tx. propagating error to caller: gRPC call failed with status: status: Unknown, message: "failed to execute message; message index: 1: connection handshake open ack failed: self consensus state not found for height 0-88: no historical info found at height 88: not found [cosmos/ibc-go/v3@v3.0.0/modules/core/02-client/keeper/keeper.go:256] With gas wanted: '0' and gas used: '130807' ", details: [], metadata: MetadataMap { headers: {"content-type": "application/grpc", "x-cosmos-block-height": "90"} }
</code></pre>
<p>The chain genesis misconfiguration is caught when the health check runs, e.g. <code>hermes health-check</code>, <code>hermes start</code>. A warning message such as the following is printed:</p>
<pre><code>2022-10-27T15:00:14.583244Z  WARN ThreadId(40) health_check{chain=ibc-0}: Health checkup for chain 'ibc-0' failed
2022-10-27T15:00:14.583308Z  WARN ThreadId(40) health_check{chain=ibc-0}:     Reason: staking module for chain 'ibc-0' does not maintain any historical entries (`historical_entries` staking params is set to 0)
2022-10-27T15:00:14.583343Z  WARN ThreadId(40) health_check{chain=ibc-0}:     Some Hermes features may not work in this mode!
</code></pre>
<h3 id="fix-5"><a class="header" href="#fix-5">Fix</a></h3>
<p>Ensure that the <code>genesis.app_state.staking.params.historical_entries</code> parameter in the chain genesis file is greater than 0. Ideal values are &gt; 100.</p>
<h2 id="maximum-block-time"><a class="header" href="#maximum-block-time">Maximum Block Time</a></h2>
<p>There are two cases where misconfiguration of the maximum block time may cause Hermes to fail. They are described in the following sections.</p>
<h3 id="header-in-the-future"><a class="header" href="#header-in-the-future">Header in the Future</a></h3>
<p>When a client for chain <code>ref_chain</code> is created by Hermes on chain <code>tgt_chain</code>, its <code>max_clock_drift</code> is computed as:
<code>ref_chain.clock_drift + tgt_chain.clock_drift + tgt_chain.max_block_time</code>
Hermes may delay a client update with <code>header</code> for one block if it determines that sending it immediately would cause the chain to reject the update as being in the future.</p>
<p>Hermes sends the update in the case when <code>header.timestamp &lt;= dst_timestamp + max_clock_drift</code>
where <code>dst_timestamp</code> is the last block time on the destination chain.
Otherwise, it waits for the next block and retries the update. If the check fails again, an error is returned:</p>
<pre><code>2022-10-28T08:42:37.423739Z  WARN ThreadId(01) foreign_client.build_update_client_and_send{client=ibc-1-&gt;ibc-0:07-tendermint-0 target_query_height=latest height}:foreign_client.wait_and_build_update_client_with_trusted{client=ibc-1-&gt;ibc-0:07-tendermint-0 target_height=1-2182}:foreign_client.build_update_client_with_trusted{client=ibc-1-&gt;ibc-0:07-tendermint-0 target_height=1-2182}:foreign_client.wait_for_header_validation_delay{client=ibc-1-&gt;ibc-0:07-tendermint-0}: src header Timestamp(2022-10-28T08:42:35.600792Z) is after dst latest header Timestamp(2022-10-28T08:42:17.864603Z) + client state drift 3s,wait for next height on ibc-0
ERROR foreign client error: update header from ibc-1 with height 1-2182 and time Timestamp(2022-10-28T08:42:35.600792Z) is in the future compared with latest header on ibc-0 with height 0-4 and time Timestamp(2022-10-28T08:42:31.09872Z), adjusted with drift 3s
</code></pre>
<h3 id="block-delay-not-reached"><a class="header" href="#block-delay-not-reached">Block Delay not Reached</a></h3>
<p>An IBC packet sent to the channel end on a destination chain with <code>max_block_delay</code>, channel using a connection with <code>delay</code>, must be received:</p>
<ul>
<li>after the time delay: <code>delay</code> has elapsed relative to the block time that included the client update with the packet commitment root, and</li>
<li>after the block delay: <code>delay / max_block_delay</code> blocks on the destination chain have been created since the client update with the packet commitment root.</li>
</ul>
<p>The on-chain packet handler uses <code>genesis.app_state.ibc.connection_genesis.params.max_expected_time_per_block</code> (in nanoseconds) when computing the block delay.
Hermes uses its config <code>max_block_delay</code> to compute the block delay.
If <code>max_block_delay &gt; genesis.app_state.ibc.connection_genesis.params.max_expected_time_per_block</code>, then Hermes may send a packet that is received too early on the destination chain, resulting in an error like the following:</p>
<pre><code>ERROR link error: link failed with underlying error: gRPC call failed with status: status: Unknown, message: "failed to execute message; message index: 0: receive packet verification failed: couldn't verify counterparty packet commitment: failed packet commitment verification for client (07-tendermint-1): cannot verify packet until height: 0-54, current height: 0-46: packet-specified delay period has not been reached [cosmos/ibc-go/v3@v3.0.0/modules/light-clients/07-tendermint/types/client_state.go:536] With gas wanted: '0' and gas used: '78238' ", details: [], metadata: MetadataMap { headers: {"content-type": "application/grpc", "x-cosmos-block-height": "46"} }
</code></pre>
<h3 id="fix-6"><a class="header" href="#fix-6">Fix</a></h3>
<p>To avoid errors for both cases described above:</p>
<ul>
<li>ensure that the <code>max_block_delay</code> parameter in the Hermes configuration file is equal to the <code>max_expected_time_per_block</code> parameter in the chain genesis file:</li>
</ul>
<pre><code>genesis.app_state.ibc.connection_genesis.params.max_expected_time_per_block
</code></pre>
<ul>
<li>ensure that the genesis <code>max_expected_time_per_block</code> parameter is 2 or 3 times the average block time which can be estimates from the <code>tendermint.consensus.timeout*</code> parameters. An example of a good estimation is:</li>
</ul>
<pre><code>       tendermint.consensus.timeout_propose +
       tendermint.consensus.timeout_prevote +
       tendermint.consensus.timeout_precommit +
       tendermint.consensus.timeout_commit
</code></pre>
<h2 id="insufficient-funds"><a class="header" href="#insufficient-funds">Insufficient Funds</a></h2>
<p>If the wallet configured in Hermes' <code>config.toml</code> is empty or doesn't have enough funds, any transfer will result in the following error:</p>
<pre><code>ERROR ThreadId(11) send_messages_and_wait_commit{chain=ibc-0 tracking_id=ft-transfer}:send_tx_with_account_sequence_retry{chain=ibc-0 account.sequence=25}:estimate_gas: failed to simulate tx. propagating error to caller: gRPC call failed with status: status: Unknown, message: "failed to execute message; message index: 0: 20stake is smaller than 108stake: insufficient funds [cosmos/cosmos-sdk@v0.46.3/x/bank/keeper/send.go:191] With gas wanted: '18446744073709551615' and gas used: '52497' ", details: [], metadata: MetadataMap { headers: {"content-type": "application/grpc", "x-cosmos-block-height": "377"} }
</code></pre>
<h3 id="fix-7"><a class="header" href="#fix-7">Fix</a></h3>
<p>In order to fix the error above, use one of the following two solutions:</p>
<ul>
<li>add enough funds to the wallet configured by <code>key_name</code> in Hermes' <code>config.toml</code>.</li>
<li>change the wallet configured by <code>key_name</code> in Hermes' <code>config.toml</code> to a wallet which has enough funds.</li>
</ul>
<h2 id="uncleared-pending-packets"><a class="header" href="#uncleared-pending-packets">Uncleared Pending Packets</a></h2>
<p>When Hermes starts, it retrieves the sequences for the unrelayed receive and acknowledgment packets from the application. Since only the packet commitments are stored in the application state, Hermes then queries tendermint for the IBC events with those sequence numbers and obtains the packet data from these events. The IBC events are retrieved from transaction and block indexes maintained by tendermint nodes.</p>
<p>In some cases these queries fail to obtain the packet data due to the fact that the state that contained those events has been pruned from the tendermint node. In this case Hermes will not be able to relay the packet. One example can be seen below. Hermes queries the application and finds <code>222</code> unreceived acknowledgment packets. Then it queries tendermint for the packet data but fails to find it (<code>pulled packet data for 0 events</code>). In this case the command returns zero relayed packets (<code>SUCCESS []</code>):</p>
<pre><code>INFO ThreadId(01) relay_ack_packet_messages{src_chain=ibc-1 src_port=transfer src_channel=channel-0 dst_chain=ibc-0}: 222 unreceived acknowledgements found: 222
INFO ThreadId(01) relay_ack_packet_messages{src_chain=ibc-1 src_port=transfer src_channel=channel-0 dst_chain=ibc-0}: pulled packet data for 0 events; events.total=222 events.left=172
INFO ThreadId(01) relay_ack_packet_messages{src_chain=ibc-1 src_port=transfer src_channel=channel-0 dst_chain=ibc-0}: pulled packet data for 0 events; events.total=222 events.left=122
INFO ThreadId(01) relay_ack_packet_messages{src_chain=ibc-1 src_port=transfer src_channel=channel-0 dst_chain=ibc-0}: pulled packet data for 0 events; events.total=222 events.left=72
INFO ThreadId(01) relay_ack_packet_messages{src_chain=ibc-1 src_port=transfer src_channel=channel-0 dst_chain=ibc-0}: pulled packet data for 0 events; events.total=222 events.left=22
INFO ThreadId(01) relay_ack_packet_messages{src_chain=ibc-1 src_port=transfer src_channel=channel-0 dst_chain=ibc-0}: pulled packet data for 0 events; events.total=222 events.left=0
SUCCESS []
</code></pre>
<h3 id="state-pruning-background"><a class="header" href="#state-pruning-background">State Pruning Background</a></h3>
<p>In order to keep the disk storage low, Tendermint nodes may be configured to prune "old" data.</p>
<h4 id="application-state-pruning"><a class="header" href="#application-state-pruning">Application State Pruning</a></h4>
<p>The <code>app.toml</code> file defines a few parameters that control the application state pruning window:</p>
<pre><code>pruning = &lt;strategy&gt;

# These are applied if and only if the pruning strategy is custom.
pruning-keep-recent = w
pruning-keep-every = x
pruning-interval = y
</code></pre>
<h4 id="tendermint-state-pruning"><a class="header" href="#tendermint-state-pruning">Tendermint State Pruning</a></h4>
<p>The <code>app.toml</code> file also defines parameters to control the tendermint block pruning window:</p>
<pre><code>min-retain-blocks = z
</code></pre>
<p>The evidence genesis parameters that also influence the actual size of the tendermint block pruning window are:</p>
<pre><code>{
...
  "consensus_params": {
    "block": {
     ...
    },
    "evidence": {
      "max_age_num_blocks": b,
      "max_age_duration": d,
      ...
    },
</code></pre>
<p>These parameters are used to determine if a block (and associated state) should be pruned:</p>
<ul>
<li>a block with height <code>h</code> and time <code>t</code> is pruned if <code>h &lt; max(z, b) &amp;&amp; t &lt; now - d</code></li>
</ul>
<p>Additional tendermint state may be maintained for state-sync purposes.</p>
<h3 id="debug"><a class="header" href="#debug">Debug</a></h3>
<p>The unrelayed packet sequences can be retrieved using the following command:</p>
<pre><code>hermes query packet pending --chain &lt;CHAIN_ID&gt; --channel &lt;CHANNEL_ID&gt; --port &lt;PORT_ID&gt;
</code></pre>
<p>There are two RPC endpoints, <code>tx_search</code> and <code>block_search</code>, that can be used to check if the full node still has the event information.</p>
<p>For example, if a <code>send_packet</code> with sequence <code>6</code> has not been relayed and the packet was sent in a transaction, the <code>tx_search</code> RPC endpoint can be used:</p>
<pre><code>http://localhost:26657/tx_search?query="send_packet.packet_sequence='6' AND send_packet.packet_src_channel='channel-0' AND send_packet.packet_src_port='transfer' AND send_packet.packet_dst_channel='channel-0' AND send_packet.packet_dst_port='transfer'"
</code></pre>
<p>If the packet was sent via begin or end blocker, the <code>block_search</code> RPC endpoint can be used:</p>
<pre><code>http://localhost:26657/block_search?query="send_packet.packet_sequence='6' AND send_packet.packet_src_channel='channel-0' AND send_packet.packet_src_port='transfer' AND send_packet.packet_dst_channel='channel-0' AND send_packet.packet_dst_port='transfer'"
</code></pre>
<p>If these two queries return an empty result, the event information has been pruned from the full node.</p>
<h3 id="fix-8"><a class="header" href="#fix-8">Fix</a></h3>
<p>Depending on how old the missing events are:</p>
<ul>
<li>use an archive node, or</li>
<li>adjust the pruning parameters of the full node to increase the pruning window and,
<ul>
<li>if state-sync is used, specify an initial state with a height that is smaller than the height at which the event occurred.
<ul>
<li>in order to find out the height of the missing events, use an archive node or a node with bigger pruning window and do the same queries as above</li>
</ul>
</li>
<li>restart the node</li>
</ul>
</li>
</ul>
<h2 id="unimplemented-grpc-for-cosmos-staking-service"><a class="header" href="#unimplemented-grpc-for-cosmos-staking-service">Unimplemented gRPC for Cosmos Staking Service</a></h2>
<p>When relaying for a consumer chain, the <code>ccv_consumer_chain</code> parameter <em>must</em> be set to <code>true</code> under its <code>[[chains]]</code> section in the <code>config.toml</code> file.
If it is not, then when Hermes attempts to relay for a consumer chain, it will typically report an error related
to a gRPC endpoint being unimplemented for the staking service:</p>
<pre><code>ERROR error raised while creating client for chain: failed when building client state: gRPC call failed with status: status: Unimplemented, message: "unknown service cosmos.staking.v1beta1.Query", details: [], metadata: MetadataMap { headers: {"content-type": "application/grpc", "content-length": "0", "date": "Thu, 16 Feb 2023 10:42:14 GMT", "server": "Caddy"} }
</code></pre>
<p>This error occurs because consumer chains do not utilize the same staking module as sovereign chains. The <code>ccv_consumer_chain</code>
parameter must be set to <code>true</code> so that Hermes knows to query a different gRPC endpoint for the relevant <code>ccvconsumer</code> parameters
that it needs in order to relay on behalf of a consumer chain.</p>
<h3 id="fix-9"><a class="header" href="#fix-9">Fix</a></h3>
<p>Set <code>ccv_consumer_chain = true</code> in <code>config.toml</code>.</p>
<h2 id="node-is-not-persisting-abci-responses"><a class="header" href="#node-is-not-persisting-abci-responses">Node is not Persisting ABCI Responses</a></h2>
<p>If Hermes is set to query CometBFT's <code>/block_results</code> RPC endpoint (which is the case when Hermes is set to use the <a href="advanced/troubleshooting/./../../documentation/configuration/configure-hermes.html#configuring-support-for-wasm-relaying">pull-based event source</a>), you may encounter an <code>Internal error: node is not persisting abci responses (code: -32603)</code> when clearing packets.</p>
<p>This is likely due to the underlying CometBFT node being configured to discard ABCI responses via the <code>discard_abci_responses</code> configuration parameter being set to <code>true</code> in the Comet config. When this option is set to <code>true</code>, Hermes will not be able to clear any packets that were sent in either a <code>begin_block</code> or an <code>end_block</code>; transactions sent using <code>/tx_search</code> should still be cleared though. In addition, Hermes will not be able to relay using the pull-based event source if ABCI responses are being discarded.</p>
<h3 id="fix-10"><a class="header" href="#fix-10">Fix</a></h3>
<p>Set the Comet node's <code>discard_abci_responses = false</code> in the Comet configuration file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-a-client-after-a-genesis-restart-without-ibc-upgrade-proposal"><a class="header" href="#updating-a-client-after-a-genesis-restart-without-ibc-upgrade-proposal">Updating a client after a Genesis restart without IBC upgrade proposal</a></h1>
<p>If a chain went through a genesis restart without an IBC upgrade proposal updating the client can result in an error due to blocks at lower heights not being available.</p>
<p>For example if we have two chains <code>ibc-0</code> and <code>ibc-1</code>, a client <code>07-tendermint-0</code> hosted on chain <code>ibc-1</code> referencing <code>ibc-0</code> and an Archive Node with its RPC address <code>http://127.0.0.1:28000</code>. After <code>ibc-0</code> goes through a genesis restart without an IBC upgrade proposal, trying to update client <code>07-tendermint-0</code> will result in an error:</p>
<pre><code>ERROR failed during a client operation: error raised while updating client: failed
building header with error: Light client error for RPC address network1-1:
Internal error: height 26 is not available, lowest height is 1101 (code: -32603):
</code></pre>
<p>In this case, to update the client at a height higher than <code>1101</code> for example <code>1102</code>, the following command can be used.</p>
<pre><code class="language-shell">hermes update client --height 1102 --archive-address http://127.0.0.1:28000 --restart-height 1101 --host-chain ibc-1 --client 07-tendermint-0

</code></pre>
<p>Once this command is successful, updating the client should then work as usual.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-clock-drift"><a class="header" href="#handling-clock-drift">Handling Clock Drift</a></h1>
<p>IBC light client security model requires that the timestamp of a header included in client updates for some <code>client</code> is within <code>[now - client.trusting_period, now + client.max_clock_drift)</code>.</p>
<p>The <code>trusting_period</code> is a parameter that is configurable under the <code>[[chains]]</code> section and its default value is two thirds of the chain <code>unbonding_period</code>.
The rest of this section describes the configuration parameters that determine the <code>max_clock_drift</code>.</p>
<p>IBC light client security model requires that the clocks of the reference and host chains are roughly synchronized. Hermes uses the <code>clock_drift</code> and <code>max_block_time</code> configuration parameters to determine how much clock drift is tolerable between the reference and host chains.</p>
<ul>
<li><code>clock_drift</code> is a correction parameter that specifies how far in the future or past a chain's clock may be from the current time..</li>
<li><code>max_block_time</code> is the maximum amount of time that can occur before a new block is created on the chain.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> For Cosmos SDK chains, a good approximation for <code>max_block_time</code> is <code>C * (timeout_propose + timeout_commit)</code>,
where <code>C</code> is a constant to allow for variation in block times, mainly due to tx execution time which is outside of
consensus params. To allow for some variance in block times while still detecting <a href="https://github.com/cometbft/cometbft/blob/main/docs/architecture/tendermint-core/adr-047-handling-evidence-from-light-client.md#appendix-b">forward lunatic attacks</a>,
it is recommended to set <code>C</code> to be in the <code>3..5</code> range. Hermes uses the default value of <code>30s</code> which is a good approximation
for most Cosmos SDK chains that have 6-10sec block times.</p>
</blockquote>
<p>The <code>clock_drift</code> parameter values on both the reference and host chains, and <code>max_block_time</code> of the host chain are summed to get the <code>max_clock_drift</code> when creating a client on the host chain.
This can be summarized more succinctly in the following equation:</p>
<pre><code>client.max_clock_drift = reference.clock_drift + host.max_block_time + host.clock_drift
</code></pre>
<p>Thus, when configuring these values in Hermes' <code>config.toml</code>, keep in mind that this is how these
parameters will be used. If the total clock drift is too small, then we run the risk of client
updates being rejected because a new block won't have been created yet. It's better to err on the
side of total clock drift being larger than smaller, however, if this value ends up being <em>too</em>
large, then this becomes a security vulnerability.</p>
<p>For a more concrete example of what could happen when clock drift is mis-configured, take a look
at the <a href="advanced/troubleshooting/./cross-comp-config.html#mishandling-clock-drift">Mishandling Clock Drift</a> troubleshooting section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas-errors"><a class="header" href="#gas-errors">Gas errors</a></h1>
<p>This section will expand on the out of gas error which can happen when simulating or sending Txs. The related configurations are:</p>
<pre><code class="language-toml">default_gas = 100000
max_gas = 4000000
gas_multiplier = 1.1
</code></pre>
<p>Before sending a transaction, Hermes will retrieve an estimation of the gas required with the simulation capability of the chain. After retrieving the gas amount from the simulation, the <code>gas_multiplier</code> will be applied since the simulation might be slightly lower than the required amount of gas.
Since the <code>max_gas</code> is applied after the gas_multiplier, it can happen that the value <code>simulated_gas * gas_multiplier &gt; max_gas</code>, in which case the <code>max_gas</code> value is used.</p>
<p>Note that if the simulation fails with a recoverable error, Hermes will use the configured <code>default_gas</code>.</p>
<h2 id="simulating-tx"><a class="header" href="#simulating-tx">Simulating Tx</a></h2>
<p>The first instance where an error can happen is when the tracasction simulation succeeds but the gas amount retrieved exceeds the configured <code>max_gas</code>, Hermes will throw an unrecoverable error:</p>
<pre><code>&lt;chain&gt; gas estimate &lt;simulated_gas&gt; from simulated Tx exceeds the maximum configured &lt;max_gas&gt;
</code></pre>
<p>This can be fixed by increasing the configured <code>max_gas</code>.</p>
<h2 id="broadcasting-tx"><a class="header" href="#broadcasting-tx">Broadcasting Tx</a></h2>
<blockquote>
<p><strong>NOTE</strong>: This issue will only arise with Cosmos chains as this is a Cosmos SDK error.</p>
</blockquote>
<p>The second instance when an error can happen is when sending the transaction. If the gas included for the transaction is not enough Hermes will throw an error:</p>
<pre><code>out of gas in location: &lt;location&gt;; gasWanted: &lt;max gas Hermes&gt;, gasUsed: &lt;gas wanted&gt;: out of gas
</code></pre>
<p>Two cases need to be verified in order to fix this issue.</p>
<h3 id="caused-by-max_gas"><a class="header" href="#caused-by-max_gas">Caused by max_gas</a></h3>
<p>If simulated gas is close to the <code>max_gas</code> configured, after multiplying the value with the <code>gas_multiplier</code>, it can be the case that the <code>max_gas</code> is used instead. And since the simulated gas might be slightly lower than the required gas, this can cause an out of gas error.
This can be fixed by increasing the configured <code>max_gas</code>.</p>
<h3 id="caused-by-default_gas"><a class="header" href="#caused-by-default_gas">Caused by default_gas</a></h3>
<p>When the transaction simulation fails with a recoverable error, the <code>default_gas</code> will be used. If the <code>default_gas</code> is too low an out of gas error will be thrown. This can be fixed by increasing the <code>default_gas</code>.
But there can also be a case similar to the one explained in the previous section <a href="advanced/troubleshooting/./gas-errors.html#caused-by-max_gas">Caused by max_gas</a>.</p>
<p>If the <code>default_gas</code> is too close to the <code>max_gas</code>, the <code>max_gas</code> will be used instead of <code>default_gas * gas_multiplier</code>, causing an out of gas error. In this situation both <code>max_gas</code> and <code>default_gas</code> need to be verified, and one or both need to be increased.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>The <code>Commands</code> section presents the commands current available in Hermes</p>
<h2 id="sections-9"><a class="header" href="#sections-9">Sections</a></h2>
<ul>
<li>
<p><strong><a href="documentation/commands/./keys/index.html">Keys</a></strong></p>
<ul>
<li>Commands to manage keys (private keys) for each chain.</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/commands/./config.html">Config</a></strong></p>
<ul>
<li>Commands to manage configuration file, in particular to validate it.</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/commands/./path-setup/index.html">Path Setup</a></strong></p>
<ul>
<li>Commands to manage clients, connections, channels.</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/commands/./relaying/index.html">Relaying</a></strong></p>
<ul>
<li>Commands to start the relayer and relay packets.</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/commands/./listen/index.html">Listen Mode</a></strong></p>
<ul>
<li>Commands to listen for IBC events</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/commands/./upgrade/index.html">Upgrade</a></strong></p>
<ul>
<li>Commands to perform client upgrade</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/commands/./misbehaviour/index.html">Monitor</a></strong></p>
<ul>
<li>Commands to monitor clients and submit evidence of misbehaviour</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/commands/./queries/index.html">Queries</a></strong></p>
<ul>
<li>Commands to execute queries on configured chains</li>
</ul>
</li>
<li>
<p><strong><a href="documentation/commands/./tx/index.html">Transactions</a></strong></p>
<ul>
<li>Commands to submit individual transactions to configured chains</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-options"><a class="header" href="#global-options">Global options</a></h1>
<p>Hermes accepts <em>global</em> options which affect all commands.</p>
<pre><code class="language-shell">hermes v1.13.2
Informal Systems &lt;hello@informal.systems&gt;
Implementation of `hermes`, an IBC Relayer developed in Rust.

FLAGS:
        --config &lt;CONFIG&gt;    Path to configuration file
        --json               Enable JSON output
</code></pre>
<h2 id="ordering-of-command-line-options"><a class="header" href="#ordering-of-command-line-options">Ordering of command-line options</a></h2>
<p>The global options must be specified right after the <code>hermes</code> command and <em>before</em> any sub-command.
The non-global options have to be specified <em>after</em> the sub-command.</p>
<pre><code class="language-shell">hermes [GLOBAL_OPTIONS] &lt;SUBCOMMAND&gt; [OPTIONS]
</code></pre>
<p><strong>Example</strong></p>
<p>To <code>start</code> Hermes using the configuration file at <code>/home/my_chain.toml</code> and enable JSON output:</p>
<pre><code class="language-shell">hermes  --config $HOME/my_chain.toml --json start

</code></pre>
<p>To <code>query</code> all clients on a chain while enabling JSON output:</p>
<pre><code class="language-shell">hermes  --json query clients --host-chain ibc-1

</code></pre>
<h2 id="json-output-1"><a class="header" href="#json-output-1">JSON output</a></h2>
<p>If the <code>--json</code> option is supplied, all commands will output single-line JSON values instead of plain text.</p>
<p>Log messages will be written to <code>stderr</code>, while the final result will be written to <code>stdout</code>, and everything
will be formatted as JSON.
This allows processing only the final output using <a href="https://stedolan.github.io/jq/"><code>jq</code></a>.
To process all the output using <code>jq</code>, one can redirect <code>stderr</code> to <code>stdout</code> with <code>hermes --json COMMAND 2&gt;&amp;1 | jq</code>.</p>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes  --json create client --host-chain ibc-0 --reference-chain ibc-1

</code></pre>
<pre><code class="language-json">{"timestamp":"Apr 13 20:46:31.921","level":"INFO","fields":{"message":"Using default configuration from: '.hermes/config.toml'"},"target":"ibc_relayer_cli::commands"}
{"timestamp":"Apr 13 20:46:31.961","level":"INFO","fields":{"message":"running listener","chain.id":"ibc-1"},"target":"ibc_relayer::event::monitor"}
{"timestamp":"Apr 13 20:46:31.989","level":"INFO","fields":{"message":"running listener","chain.id":"ibc-0"},"target":"ibc_relayer::event::monitor"}
{"result":{"CreateClient":{"client_id":"07-tendermint-1","client_type":"Tendermint","consensus_height":{"revision_height":10060,"revision_number":1},"height":{"revision_height":10072,"revision_number":0}}},"status":"success"}
</code></pre>
<p>The first three lines are printed to <code>stderr</code>, while the last line with a <code>"result"</code> key is printed to <code>stdout</code>.</p>
<p><strong>Example</strong></p>
<p>To improve the readability, pipe all the output to <code>jq</code>:</p>
<pre><code>hermes  --json create client --host-chain ibc-0 --reference-chain ibc-1
 2&gt;&amp;1 | jq
</code></pre>
<pre><code class="language-json">{
  "timestamp": "Apr 13 20:52:26.060",
  "level": "INFO",
  "fields": {
    "message": "Using default configuration from: '.hermes/config.toml'"
  },
  "target": "ibc_relayer_cli::commands"
}
{
  "timestamp": "Apr 13 20:52:26.082",
  "level": "INFO",
  "fields": {
    "message": "running listener",
    "chain.id": "ibc-1"
  },
  "target": "ibc_relayer::event::monitor"
}
{
  "timestamp": "Apr 13 20:52:26.088",
  "level": "INFO",
  "fields": {
    "message": "running listener",
    "chain.id": "ibc-0"
  },
  "target": "ibc_relayer::event::monitor"
}
{
  "result": {
    "CreateClient": {
      "client_id": "07-tendermint-5",
      "client_type": "Tendermint",
      "consensus_height": {
        "revision_height": 10364,
        "revision_number": 1
      },
      "height": {
        "revision_height": 10375,
        "revision_number": 0
      }
    }
  },
  "status": "success"
}
</code></pre>
<p><strong>Example</strong></p>
<p>To extract the identifier of the newly created client above:</p>
<pre><code>hermes  --json create client --host-chain ibc-0 --reference-chain ibc-1
 | jq '.result.CreateClient.client_id'
</code></pre>
<p>Which should output:</p>
<pre><code>"07-tendermint-2"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-keys-to-hermes"><a class="header" href="#adding-keys-to-hermes">Adding Keys to Hermes</a></h1>
<blockquote>
<p><strong>WARNING</strong>: Currently Hermes does NOT support a <code>keyring</code> store to securely
store the private key file. The key file will be stored on the local file system
in the folder set by the configuration <code>key_store_folder</code> which defaults
to <code>key_store_folder = '$HOME/.hermes/keys'</code>.</p>
</blockquote>
<blockquote>
<p><strong>BREAKING</strong>: As of Hermes v1.0.0, the sub-command <code>keys restore</code> has been removed.
Please use the sub-command <code>keys add</code> in order to restore a key.</p>
</blockquote>
<hr />
<p>Using the <code>keys</code> command you can add and list keys.</p>
<h4 id="show-usage"><a class="header" href="#show-usage">Show usage</a></h4>
<p>To see the available sub-commands for the <code>keys</code> command run:</p>
<pre><code class="language-shell">hermes help keys
</code></pre>
<p>The available sub-commands are the following:</p>
<pre><code class="language-shell">DESCRIPTION:
Manage keys in the relayer for each chain

USAGE:
    hermes keys &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    add        Add a key to a chain from its keyring file or restore a key using its mnemonic
    balance    Query balance for a key from a configured chain. If no key is given, the key is
                   retrieved from the configuration file
    delete     Delete key(s) from a configured chain
    help       Print this message or the help of the given subcommand(s)
    list       List keys configured for a chain
</code></pre>
<h3 id="key-seed-file-private-key"><a class="header" href="#key-seed-file-private-key">Key Seed file (Private Key)</a></h3>
<p>In order to execute the command below you need a private key file (JSON). Hermes uses the private key file to sign the transactions submitted to the chain.</p>
<p>The private key file can be obtained by using the <code>keys add</code> on a Cosmos chain. For example, the command for <code>gaiad</code> is:</p>
<pre><code class="language-shell"># The `key_name` parameter is the name of the key that will be found in the json output
# For example, in the "Two Local Chains" tutorial, we use "testkey".
gaiad keys add &lt;key_name&gt; --output json
</code></pre>
<p>The command outputs a JSON similar to the one below.</p>
<pre><code class="language-json">{
  "name": "testkey",
  "type": "local",
  "address": "cosmos1tc3vcuxyyac0dmayf887t95tdg7qpyql48w7gj",
  "pubkey": "cosmospub1addwnpepqgg7ng4ycm60pdxfzdfh4hjvkwcr3da59mr8k883vsstx60ruv7kur4525u",
  "mnemonic": "[24 words mnemonic]"
}
</code></pre>
<p>You can save this to a file (e.g. <code>key_seed.json</code>) and use it to add to Hermes with <code>hermes keys add --chain &lt;CHAIN_ID&gt; --key-file key_seed.json </code>. See the <code>Adding Keys</code> section for more details.</p>
<h3 id="adding-and-restoring-keys"><a class="header" href="#adding-and-restoring-keys">Adding and restoring Keys</a></h3>
<p>The command <code>keys add</code> has two exclusive flags, <code>--key-file</code> and <code>--mnemonic-file</code> which are respectively used to add and restore a key.<br />
If a key with the same <code>key_name</code> already exists, the flag <code>--overwrite</code> must be passed in order to overwrite the existing key or else the command will abort.</p>
<pre><code class="language-shell">DESCRIPTION:
Add a key to a chain from its keyring file or restore a key using its mnemonic

USAGE:
    Add a key from a Comet keyring file:
        hermes keys add [OPTIONS] --chain &lt;CHAIN_ID&gt; --key-file &lt;KEY_FILE&gt;
    
    Add a key from a file containing its mnemonic:
        hermes keys add [OPTIONS] --chain &lt;CHAIN_ID&gt; --mnemonic-file &lt;MNEMONIC_FILE&gt;
    
    On *nix platforms, both flags also accept `/dev/stdin` as a value, which will read the key or the mnemonic from stdin.

OPTIONS:
    -h, --help                   Print help information
        --hd-path &lt;HD_PATH&gt;      Derivation path for this key [default: m/44'/118'/0'/0/0]
        --key-name &lt;KEY_NAME&gt;    Name of the key (defaults to the `key_name` defined in the config)
        --overwrite              Overwrite the key if there is already one with the same key name

FLAGS:
        --chain &lt;CHAIN_ID&gt;
            Identifier of the chain

        --key-file &lt;KEY_FILE&gt;
            Path to the key file, or /dev/stdin to read the content from stdin

        --mnemonic-file &lt;MNEMONIC_FILE&gt;
            Path to file containing the mnemonic to restore the key from, or /dev/stdin to read the
            mnemonic from stdin
</code></pre>
<h4 id="add-a-private-key-to-a-chain-from-a-key-file"><a class="header" href="#add-a-private-key-to-a-chain-from-a-key-file">Add a private key to a chain from a key file</a></h4>
<pre><code class="language-shell">hermes keys add --chain &lt;CHAIN_ID&gt; --key-file &lt;PRIVATE_KEY_FILE&gt;

</code></pre>
<p>The content of the file key should have the same format as the output of the <code>gaiad keys add</code> command:</p>
<pre><code class="language-json">{
  "name": "testkey",
  "type": "local",
  "address": "cosmos1tc3vcuxyyac0dmayf887t95tdg7qpyql48w7gj",
  "pubkey": "cosmospub1addwnpepqgg7ng4ycm60pdxfzdfh4hjvkwcr3da59mr8k883vsstx60ruv7kur4525u",
  "mnemonic": "[24 words mnemonic]"
}
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">Success: Added key testkey (&lt;ADDRESS&gt;) on &lt;CHAIN_ID&gt; chain
</code></pre>
<blockquote>
<p><strong>Key name:</strong>
By default, the key will be named after the <code>key_name</code> property specified in the configuration file.
To use a different key name, specify the <code>--key-name</code> option when invoking <code>keys add</code>.</p>
<pre><code>hermes keys add --key-name [KEY_NAME] --chain &lt;CHAIN_ID&gt; --key-file &lt;PRIVATE_KEY_FILE&gt;
</code></pre>
</blockquote>
<blockquote>
<pre><code></code></pre>
</blockquote>
<h4 id="restore-a-private-key-to-a-chain-from-a-mnemonic"><a class="header" href="#restore-a-private-key-to-a-chain-from-a-mnemonic">Restore a private key to a chain from a mnemonic</a></h4>
<pre><code class="language-shell">hermes keys add --chain &lt;CHAIN_ID&gt; --mnemonic-file &lt;MNEMONIC_FILE&gt;

</code></pre>
<p>or using an explicit <a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">derivation path</a>, for example
an Ethereum coin type (used for Evmos, Injective, Umee, Cronos, and
possibly other networks):</p>
<pre><code class="language-shell">hermes keys add --hd-path "m/44'/60'/0'/0/0" --chain &lt;CHAIN_ID&gt; --mnemonic-file &lt;MNEMONIC_FILE&gt;

</code></pre>
<p>The mnemonic file needs to have the 24 mnemonic words on the same line, separated by a white space. So the content should have the following format:</p>
<pre><code>word1 word2 word3 ... word24
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">Success: Restore key testkey (&lt;ADDRESS&gt;) on &lt;CHAIN_ID&gt; chain
</code></pre>
<blockquote>
<p><strong>Key name:</strong>
By default, the key will be named after the <code>key_name</code> property specified in the configuration file.
To use a different key name, specify the <code>--key-name</code> option when invoking <code>keys add</code>.</p>
<pre><code>hermes keys add --key-name &lt;KEY_NAME&gt; --chain &lt;CHAIN_ID&gt; --mnemonic-file &lt;MNEMONIC_FILE&gt;
</code></pre>
</blockquote>
<blockquote>
<pre><code></code></pre>
</blockquote>
<h3 id="delete-keys"><a class="header" href="#delete-keys">Delete keys</a></h3>
<p>In order to delete the private keys added to chains use the <code>keys delete</code> command</p>
<pre><code class="language-shell">DESCRIPTION:
Delete key(s) from a configured chain

USAGE:
    hermes keys delete --chain &lt;CHAIN_ID&gt; --key-name &lt;KEY_NAME&gt;

    hermes keys delete --chain &lt;CHAIN_ID&gt; --all

OPTIONS:
    -h, --help    Print help information

FLAGS:
        --all                    Delete all keys
        --chain &lt;CHAIN_ID&gt;       Identifier of the chain
        --key-name &lt;KEY_NAME&gt;    Name of the key
</code></pre>
<h4 id="delete-private-keys-that-was-previously-added-to-a-chain"><a class="header" href="#delete-private-keys-that-was-previously-added-to-a-chain">Delete private keys that was previously added to a chain</a></h4>
<p>To delete a single private key by name:</p>
<pre><code class="language-shell">hermes keys delete --chain &lt;CHAIN_ID&gt; --key-name &lt;KEY_NAME&gt;

</code></pre>
<p>Alternatively, to delete all private keys added to a chain:</p>
<pre><code class="language-shell">hermes --config config.toml keys delete --chain &lt;CHAIN_ID&gt; --all
</code></pre>
<h3 id="list-keys"><a class="header" href="#list-keys">List keys</a></h3>
<p>In order to list the private keys added to chains use the <code>keys list</code> command</p>
<pre><code class="language-shell">DESCRIPTION:
List keys configured for a chain

USAGE:
    hermes keys list --chain &lt;CHAIN_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain
</code></pre>
<h4 id="listing-the-private-key-that-was-added-to-a-chain"><a class="header" href="#listing-the-private-key-that-was-added-to-a-chain">Listing the private key that was added to a chain</a></h4>
<p>To list the private key file that was added to a chain:</p>
<pre><code class="language-shell">hermes keys list --chain &lt;CHAIN_ID&gt;

</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code>Success:
- user2 (cosmos1attn9fxrcvjz483w3tu4cfz77ldmlyujly3q3k)
- testkey (cosmos1dw88vdekeeuta5u50p6n5lt5v5c6y2we0pu8nz)
</code></pre>
<p><strong>JSON:</strong></p>
<pre><code class="language-shell">hermes  --json keys list --chain &lt;CHAIN_ID&gt;
 | jq
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">{
  "result": {
    "testkey": {
      "account": "cosmos1dw88vdekeeuta5u50p6n5lt5v5c6y2we0pu8nz",
      "address": [ 107, 142, 118, 55, 54, 206, 120, 190, 211, 148, 120, 117, 58, 125, 116, 101, 49, 162, 41, 217 ],
      "coin_type": 118,
      "private_key": "(snip)",
      "public_key": "xpub6Gc7ZUt2q1BiQYjhUextPv5bZLwosHigZYqEquPD6FkAGmHDrLiBgE5Xnh8XGZp79rAXtZn1Dt3DNQHxxgCgVQqfRMfVsRiXn6mwULBnYq7"
    },
    "user2": {
      "account": "cosmos1attn9fxrcvjz483w3tu4cfz77ldmlyujly3q3k",
      "address": [ 234, 215, 50, 164, 195, 195, 36, 42, 158, 46, 138, 249, 92, 36, 94, 247, 219, 191, 147, 146 ],
      "coin_type": 118,
      "private_key": "(snip)",
      "public_key": "xpub6FmDbeGTWVjSvHrqHfrpnMTZxpPX1V7XFiq5nMuvgwX9jumt1yUuwNAUQo8Nn36unbFShg6iSjkfMBgeY49wik7rF91N2SHvarpX62ByWMf"
    }
  },
  "status": "success"
}
</code></pre>
<h3 id="query-balance"><a class="header" href="#query-balance">Query balance</a></h3>
<p>In order to retrieve the balance of an account associated with a key use the <code>keys balance</code> command</p>
<pre><code class="language-shell">DESCRIPTION:
Query balance for a key from a configured chain. If no key is given, the key is retrieved from the
configuration file

USAGE:
    hermes keys balance [OPTIONS] --chain &lt;CHAIN_ID&gt;

OPTIONS:
        --all                    (optional) query the balance for all denom. This flag overwrites
                                 the `--denom` flag (defaults to false)
        --denom &lt;DENOM&gt;          (optional) query the balance for the given denom (defaults to the
                                 `denom` defined in the config for the gas price)
    -h, --help                   Print help information
        --key-name &lt;KEY_NAME&gt;    (optional) name of the key (defaults to the `key_name` defined in
                                 the config)

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain
</code></pre>
<p>If the command is successful a message with the following format will be displayed:</p>
<pre><code>Success: balance for key `KEY_NAME`: 100000000000 stake
</code></pre>
<p><strong>JSON:</strong></p>
<pre><code class="language-shell">hermes  --json keys balance --chain &lt;CHAIN_ID&gt;

</code></pre>
<p>If the command is successful a message with the following format will be displayed:</p>
<pre><code class="language-json">{
  "result": {
    "amount": "99989207",
    "denom": "stake"
  },
  "status": "success"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-and-validating-config-files"><a class="header" href="#generating-and-validating-config-files">Generating and Validating Config Files</a></h1>
<h4 id="show-usage-1"><a class="header" href="#show-usage-1">Show usage</a></h4>
<p>To see the available sub-commands for the <code>config</code> command run:</p>
<pre><code class="language-shell">hermes help config
</code></pre>
<p>The available sub-commands are the following:</p>
<pre><code class="language-shell">DESCRIPTION:
Generate a new Hermes configuration file or validate an existing one

USAGE:
    hermes config &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    auto        Automatically generate a config.toml for the specified chain(s)
    help        Print this message or the help of the given subcommand(s)
    validate    Validate the relayer configuration
</code></pre>
<h3 id="automatically-generate-configuration-files-for-specified-chains"><a class="header" href="#automatically-generate-configuration-files-for-specified-chains">Automatically generate configuration files for specified chains</a></h3>
<p>Use <code>config auto</code> to automatically generate a configuration file from the <a href="https://github.com/cosmos/chain-registry">chain-registry</a>.</p>
<blockquote>
<p><strong>WARNING</strong>: Currently, <code>default_gas</code> and <code>max_gas</code> parameters are set to default values; these should be manually reset. The <code>gas_price</code> parameter is set as the average gas price listed for the chain in the chain registry.</p>
</blockquote>
<pre><code>DESCRIPTION:
Automatically generate a config.toml for the specified chain(s)

USAGE:
    hermes config auto [OPTIONS] --output &lt;PATH&gt; --chain &lt;CHAIN1_NAME:OPTIONAL_KEY_NAME&gt; --chain &lt;CHAIN2_NAME:OPTIONAL_KEY_NAME&gt;

OPTIONS:
        --commit &lt;COMMIT_HASH&gt;    Commit hash from which the chain configs will be generated. If
                                  it's not set, the latest commit will be used.
    -h, --help                    Print help information

REQUIRED:
        --chains &lt;CHAIN_NAME:OPTIONAL_KEY_NAME&gt;...
            Names of the chains to include in the configuration, together with an optional key name.
            Either repeat this argument for every chain or pass a space-separated list of chains.
            Every chain must be found in the chain registry.

        --output &lt;PATH&gt;
            Path to the configuration file
</code></pre>
<p><strong>Example</strong></p>
<p>Use <code>config auto</code> to generate a configuration file that is able to relay between <code>cosmoshub</code> and <code>osmosis</code>. This command assumes the existence of a key file for <code>cosmoshub-4</code> and <code>osmosis-1</code> in <code>$HOME/.hermes/keys</code>.</p>
<pre><code>hermes config auto --output ~/example_config.toml --chain cosmoshub osmosis --chain 


2022-08-16T17:27:26.966233Z  INFO ThreadId(01) using default configuration from '~/.hermes/config.toml'
2022-08-16T17:27:27.800213Z  INFO ThreadId(01) cosmoshub-4: uses key "key_cosmoshub"
2022-08-16T17:27:27.841167Z  INFO ThreadId(01) osmosis-1: uses key "key_osmosis"
2022-08-16T17:27:27.841890Z  WARN ThreadId(01) Gas parameters are set to default values.
SUCCESS Config file written successfully at '~/example_config.toml'
</code></pre>
<p>It is also possible to manually specify a key name for any chain.</p>
<pre><code>hermes config auto --output ~/example_config.toml --chain cosmoshub:random_key osmosis --chain 


2022-08-16T17:29:56.902499Z  INFO ThreadId(01) using default configuration from '~/.hermes/config.toml'
2022-08-16T17:29:57.288874Z  INFO ThreadId(01) cosmoshub-4: uses key "random_key"
2022-08-16T17:29:57.289728Z  INFO ThreadId(01) osmosis-1: uses key "key_osmosis"
2022-08-16T17:29:57.290314Z  WARN ThreadId(01) Gas parameters are set to default values.
SUCCESS "Config file written successfully : ~/example_config.toml."
</code></pre>
<p><strong>WARNING</strong> : Do not forget to modify the gas settings before relaying !</p>
<h3 id="validate-an-existing-configuration-file"><a class="header" href="#validate-an-existing-configuration-file">Validate an existing configuration file</a></h3>
<p>Use <code>config validate</code> to perform a quick syntactic validation of
your configuration file.</p>
<pre><code class="language-shell">DESCRIPTION:
Validate the relayer configuration

USAGE:
    hermes config validate

OPTIONS:
    -h, --help    Print help information
</code></pre>
<p><strong>Example</strong></p>
<p>Validate the default config file, the path inferred automatically to be
<code>$HOME/.hermes/config.toml</code>.</p>
<pre><code class="language-shell">hermes config validate

</code></pre>
<p>Which should output something similar to:</p>
<pre><code class="language-text">Jul 12 16:31:07.017  INFO using default configuration from '$HOME/.hermes/config.toml'
SUCCESS: "validation passed successfully"
</code></pre>
<p>Validate a config file at an arbitrary location:</p>
<pre><code class="language-shell">hermes  --config $CONFIGPATH config validate

</code></pre>
<p>This one should fail validation because we mistakenly added two separate sections for the same chain <code>ibc-1</code>:</p>
<pre><code class="language-text">error: hermes fatal error: config error: config file has duplicate entry for the chain 'ibc-1'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-setup"><a class="header" href="#path-setup">Path Setup</a></h1>
<p>This section describes a number of commands that can be used to manage clients, connections, channels.</p>
<div class="table-wrapper"><table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>create client</code></td><td><a href="documentation/commands/path-setup/./clients.html#create-client">Create a client for source chain on destination chain</a></td></tr>
<tr><td><code>update client</code></td><td><a href="documentation/commands/path-setup/./clients.html#md-client">Update the specified client on destination chain</a></td></tr>
<tr><td><code>create connection</code></td><td><a href="documentation/commands/path-setup/./connections.html#establish-connection">Establish a connection using existing or new clients</a></td></tr>
<tr><td><code>create channel</code></td><td><a href="documentation/commands/path-setup/./channels.html#establish-channel">Establish a channel using a pre-existing connection, or alternatively create a new client and a new connection underlying the new channel</a></td></tr>
</tbody></table>
</div>
<h2 id="create"><a class="header" href="#create">Create</a></h2>
<p>Use the <code>create</code> commands to create new clients, connections, and channels.</p>
<pre><code class="language-shell">DESCRIPTION:
Create objects (client, connection, or channel) on chains

USAGE:
    hermes create &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    channel       Create a new channel between two chains
    client        Create a new IBC client
    connection    Create a new connection between two chains
    help          Print this message or the help of the given subcommand(s)
</code></pre>
<h2 id="update"><a class="header" href="#update">Update</a></h2>
<p>Use the <code>update</code> commands to update a client.</p>
<pre><code class="language-shell">DESCRIPTION:
Update objects (clients) on chains

USAGE:
    hermes update &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    client    Update an IBC client
    help      Print this message or the help of the given subcommand(s)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client"><a class="header" href="#client">Client</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/path-setup/clients.html#create-client">Create Client</a></li>
<li><a href="documentation/commands/path-setup/clients.html#update-client">Update Client</a></li>
</ul>
<h2 id="create-client"><a class="header" href="#create-client">Create Client</a></h2>
<p>Use the <code>create client</code> command to create a new client on a destination chain,
tracking the state of the source chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Create a new IBC client

USAGE:
    hermes create client [OPTIONS] --host-chain &lt;HOST_CHAIN_ID&gt; --reference-chain &lt;REFERENCE_CHAIN_ID&gt;

OPTIONS:
        --clock-drift &lt;CLOCK_DRIFT&gt;
            The maximum allowed clock drift for this client.
            
            The clock drift is a correction parameter. It helps deal with clocks that are only
            approximately synchronized between the source and destination chains of this client. The
            destination chain for this client uses the clock drift parameter when deciding to accept
            or reject a new header (originating from the source chain) for this client. If this
            option is not specified, a suitable clock drift value is derived from the chain
            configurations.

    -h, --help
            Print help information

        --trust-threshold &lt;TRUST_THRESHOLD&gt;
            Override the trust threshold specified in the configuration.
            
            The trust threshold defines what fraction of the total voting power of a known and
            trusted validator set is sufficient for a commit to be accepted going forward.

        --trusting-period &lt;TRUSTING_PERIOD&gt;
            Override the trusting period specified in the config.
            
            The trusting period specifies how long a validator set is trusted for (must be shorter
            than the chain's unbonding period).

REQUIRED:
        --host-chain &lt;HOST_CHAIN_ID&gt;
            Identifier of the chain that hosts the client

        --reference-chain &lt;REFERENCE_CHAIN_ID&gt;
            Identifier of the chain targeted by the client
</code></pre>
<p><strong>Example</strong></p>
<p>Create a new client on <code>ibc-0</code> which tracks <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes create client --host-chain ibc-0 --reference-chain ibc-1

</code></pre>
<pre><code class="language-json">    CreateClient(
        Attributes {
            height: Height {
                revision: 0,
                height: 286,
            },
            client_id: ClientId(
                "07-tendermint-0",
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 1,
                height: 274,
            },
        },
    ),
)
</code></pre>
<p>A new client is created with identifier <code>07-tendermint-1</code></p>
<h2 id="update-client"><a class="header" href="#update-client">Update Client</a></h2>
<p>Use the <code>update client</code> command to update an existing client with a new consensus state.
Specific update and trusted heights can be specified.</p>
<pre><code class="language-shell">DESCRIPTION:
Update an IBC client

USAGE:
    hermes update client [OPTIONS] --host-chain &lt;HOST_CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

OPTIONS:
        --archive-address &lt;ARCHIVE_ADDRESS&gt;
            The RPC address of the archive node to use to fetch headers from before the restart.
            Requires --restart-height if used. [aliases: archive-addr]

    -h, --help
            Print help information

        --height &lt;REFERENCE_HEIGHT&gt;
            The target height of the client update. Leave unspecified for latest height.

        --restart-height &lt;RESTART_HEIGHT&gt;
            The height that the chain underwent a genesis restart at. Requires --archive-address if
            used.

        --trusted-height &lt;REFERENCE_TRUSTED_HEIGHT&gt;
            The trusted height of the client update. Leave unspecified for latest height.

REQUIRED:
        --client &lt;CLIENT_ID&gt;            Identifier of the client to update
        --host-chain &lt;HOST_CHAIN_ID&gt;    Identifier of the chain that hosts the client
</code></pre>
<p><strong>Update client with latest header</strong></p>
<p>the client on <code>ibc-0</code> with the latest header of <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes update client --host-chain ibc-0 --client 07-tendermint-9

</code></pre>
<pre><code class="language-json">Success: UpdateClient(
    UpdateClient {
        common: Attributes {
            height: Height { revision: 0, height: 303 },
            client_id: ClientId(
                "07-tendermint-1",
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 293 },
        },
        header: Some(
            Tendermint(
                 Header {...},
            ),
        ),
    },
)
</code></pre>
<p>The client with identifier <code>07-tendermint-1</code> has been updated with the consensus state at height <code>1-293</code>.</p>
<p><strong>Update a client to a specific target height</strong></p>
<pre><code class="language-shell">hermes update client --height 320 --trusted-height 293 --host-chain ibc-0 --client 07-tendermint-1

</code></pre>
<pre><code class="language-json">Success: UpdateClient(
    UpdateClient {
        common: Attributes {
            height: Height { revision: 0, height: 555 },
            client_id: ClientId(
                "07-tendermint-1",
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 320 },
        },
        header: Some(
            Tendermint(
                 Header {...},
            ),
        ),
    },
)
</code></pre>
<p>The client with identifier <code>07-tendermint-1</code> has been updated with the consensus state at height <code>1-320</code>, as specified.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection"><a class="header" href="#connection">Connection</a></h1>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/path-setup/connections.html#establish-connection">Establish Connection</a></li>
<li><a href="documentation/commands/path-setup/connections.html#examples">Examples</a>
<ul>
<li><a href="documentation/commands/path-setup/connections.html#new-connection-over-new-clients">New connection over new clients</a></li>
<li><a href="documentation/commands/path-setup/connections.html#new-connection-over-existing-clients">New connection over existing clients</a></li>
</ul>
</li>
<li><a href="documentation/commands/path-setup/connections.html#non-zero-delay-connection">Non-zero Delay Connection</a></li>
</ul>
<h2 id="establish-connection"><a class="header" href="#establish-connection">Establish Connection</a></h2>
<p>Use the <code>create connection</code> command to create a new connection.</p>
<pre><code class="language-shell">DESCRIPTION:
Create a new connection between two chains

USAGE:
    hermes create connection [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --b-chain &lt;B_CHAIN_ID&gt;

    hermes create connection [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --a-client &lt;A_CLIENT_ID&gt; --b-client &lt;B_CLIENT_ID&gt;

OPTIONS:
        --delay &lt;DELAY&gt;    Delay period parameter for the new connection (seconds) [default: 0]
    -h, --help             Print help information

FLAGS:
        --a-chain &lt;A_CHAIN_ID&gt;      Identifier of the side `a` chain for the new connection
        --a-client &lt;A_CLIENT_ID&gt;    Identifier of client hosted on chain `a`; default: None (creates
                                    a new client)
        --b-chain &lt;B_CHAIN_ID&gt;      Identifier of the side `b` chain for the new connection
        --b-client &lt;B_CLIENT_ID&gt;    Identifier of client hosted on chain `b`; default: None (creates
                                    a new client)
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="new-connection-over-new-clients"><a class="header" href="#new-connection-over-new-clients">New connection over new clients</a></h3>
<p>Create a new connection between <code>ibc-0</code> and <code>ibc-1</code> over new clients:</p>
<pre><code class="language-shell">hermes create connection --a-chain ibc-0 --b-chain ibc-1

</code></pre>
<pre><code class="language-json">🥂  ibc-0 =&gt; OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 4073 },
            connection_id: Some(
                ConnectionId(
                    "connection-8",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-8",
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                "07-tendermint-8",
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 4069 },
            connection_id: Some(
                ConnectionId(
                    "connection-8",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-8",
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    "connection-8",
                ),
            ),
            counterparty_client_id: ClientId(
                "07-tendermint-8",
            ),
        },
    ),
)

🥂  ibc-0 =&gt; OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 4081 },
            connection_id: Some(
                ConnectionId(
                    "connection-8",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-8",
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    "connection-8",
                ),
            ),
            counterparty_client_id: ClientId(
                "07-tendermint-8",
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 4073 },
            connection_id: Some(
                ConnectionId(
                    "connection-8",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-8",
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    "connection-8",
                ),
            ),
            counterparty_client_id: ClientId(
                "07-tendermint-8",
            ),
        },
    ),
)

🥂🥂🥂  Connection handshake finished for [Connection {
    delay_period: 0s,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-8",
        ),
        connection_id: ConnectionId(
            "connection-8",
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-8",
        ),
        connection_id: ConnectionId(
            "connection-8",
        ),
    },
}]

Success: Connection {
    delay_period: 0s,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-8",
        ),
        connection_id: ConnectionId(
            "connection-8",
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-8",
        ),
        connection_id: ConnectionId(
            "connection-8",
        ),
    },
}
</code></pre>
<h3 id="new-connection-over-existing-clients"><a class="header" href="#new-connection-over-existing-clients">New connection over existing clients</a></h3>
<p>Create a new connection between <code>ibc-0</code> and <code>ibc-1</code> over existing clients,
both with client id <code>07-tendermint-0</code>:</p>
<pre><code class="language-shell">hermes create connection --a-chain ibc-0 --a-client 07-tendermint-0 --b-client 07-tendermint-0

</code></pre>
<p>Notice that one can omit the destination chain parameter, as Hermes will automatically
figure it out by looking up the given client on <code>ibc-0</code>.</p>
<h2 id="non-zero-delay-connection"><a class="header" href="#non-zero-delay-connection">Non-zero Delay Connection</a></h2>
<p>A connection can be created with a delay period parameter. This parameter specifies a period of time that must elpase after a successful client state update and before a packet with proofs using its commitment root can pe processed on chain. For more information see <a href="documentation/commands/path-setup/../relaying/index.html#packet-delay">how packet delay works</a> and the <a href="https://github.com/cosmos/ibc/tree/master/spec/core/ics-003-connection-semantics">connection delay specification</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel"><a class="header" href="#channel">Channel</a></h1>
<h2 id="table-of-contents-6"><a class="header" href="#table-of-contents-6">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/path-setup/channels.html#establish-channel">Establish Channel</a></li>
<li><a href="documentation/commands/path-setup/channels.html#examples">Examples</a>
<ul>
<li><a href="documentation/commands/path-setup/channels.html#new-channel-over-an-existing-connection">New channel over an existing connection</a></li>
<li><a href="documentation/commands/path-setup/channels.html#new-channel-over-a-new-connection">New channel over a new connection</a></li>
</ul>
</li>
</ul>
<h2 id="establish-channel"><a class="header" href="#establish-channel">Establish Channel</a></h2>
<p>Use the <code>create channel</code> command to establish a new channel.</p>
<pre><code class="language-shell">DESCRIPTION:
Create a new channel between two chains.

Can create a new channel using a pre-existing connection or alternatively, create a new client and a
new connection underlying the new channel if a pre-existing connection is not provided.

USAGE:
    hermes create channel [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --a-connection &lt;A_CONNECTION_ID&gt; --a-port &lt;A_PORT_ID&gt; --b-port &lt;B_PORT_ID&gt;

    hermes create channel [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --b-chain &lt;B_CHAIN_ID&gt; --a-port &lt;A_PORT_ID&gt; --b-port &lt;B_PORT_ID&gt; --new-client-connection

OPTIONS:
        --channel-version &lt;VERSION&gt;
            The version for the new channel
            
            [aliases: chan-version]

    -h, --help
            Print help information

        --new-client-connection
            Indicates that a new client and connection will be created underlying the new channel
            
            [aliases: new-client-conn]

        --order &lt;ORDER&gt;
            The channel ordering, valid options 'unordered' (default) and 'ordered'
            
            [default: ORDER_UNORDERED]

        --yes
            Skip new_client_connection confirmation

FLAGS:
        --a-chain &lt;A_CHAIN_ID&gt;
            Identifier of the side `a` chain for the new channel

        --a-connection &lt;A_CONNECTION_ID&gt;
            Identifier of the connection on chain `a` to use in creating the new channel
            
            [aliases: a-conn]

        --a-port &lt;A_PORT_ID&gt;
            Identifier of the side `a` port for the new channel

        --b-chain &lt;B_CHAIN_ID&gt;
            Identifier of the side `b` chain for the new channel

        --b-port &lt;B_PORT_ID&gt;
            Identifier of the side `b` port for the new channel
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="new-channel-over-an-existing-connection"><a class="header" href="#new-channel-over-an-existing-connection">New channel over an existing connection</a></h3>
<p>This is the preferred way to create a new channel, by leveraging an existing
connection.</p>
<p>Create a new unordered channel between <code>ibc-0</code> and <code>ibc-1</code> over an existing connection,
specifically the one we just created in the example above, with port name
<code>transfer</code> on both sides:</p>
<pre><code class="language-shell">hermes create channel --order unordered --a-chain ibc-0 --a-connection connection-0 --a-port  transfer --b-port transfer

</code></pre>
<p>Notice that one can omit the destination chain parameter, as Hermes will automatically
figure it out by looking up the given connection on <code>ibc-0</code>.</p>
<pre><code class="language-json">🥳  ibc-0 =&gt; OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 129 },
            port_id: PortId("transfer"),
            channel_id: Some(ChannelId("channel-1")),
            connection_id: ConnectionId("connection-0"),
            counterparty_port_id: PortId("transfer"),
            counterparty_channel_id: None
        }
    )
)
🥳  ibc-1 =&gt; OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 126 },
            port_id: PortId("transfer"),
            channel_id: Some(ChannelId("channel-1")),
            connection_id: ConnectionId("connection-0"),
            counterparty_port_id: PortId("transfer"),
            counterparty_channel_id: Some(ChannelId("channel-1"))
        }
    )
)
🥳  ibc-0 =&gt; OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 137 },
            port_id: PortId("transfer"),
            channel_id: Some(ChannelId("channel-1")),
            connection_id: ConnectionId("connection-0"),
            counterparty_port_id: PortId("transfer"),
            counterparty_channel_id: Some(ChannelId("channel-1"))
        }
    )
)
🥳  ibc-1 =&gt; OpenConfirmChannel(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 129 },
            port_id: PortId("transfer"),
            channel_id: Some(ChannelId("channel-1")),
            connection_id: ConnectionId("connection-0"),
            counterparty_port_id: PortId("transfer"),
            counterparty_channel_id: Some(ChannelId("channel-1"))
        }
    )
)
🥳  🥳  🥳  Channel handshake finished for Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: ChannelId(
            "channel-1",
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: ChannelId(
            "channel-1",
        ),
    },
    connection_delay: 0s,
}
Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: ChannelId(
            "channel-1",
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: ChannelId(
            "channel-1",
        ),
    },
    connection_delay: 0s,
}
</code></pre>
<h3 id="new-channel-over-a-new-connection"><a class="header" href="#new-channel-over-a-new-connection">New channel over a new connection</a></h3>
<p>Should you specifically want to create a new client and a new connection as part
of the <code>create channel</code> flow, that option exists, though this is the
less-preferred option over the previous flow, as creating new clients and
connections should only be done in certain specific circumstances so as not to
create redundant resources.</p>
<p>Create a new unordered channel between <code>ibc-0</code> and <code>ibc-1</code> over a new
connection, using port name <code>transfer</code> on both sides and accepting the
interactive prompt that pops up notifying you that a new client and a new
connection will be initialized as part of the process:</p>
<pre><code class="language-shell">hermes create channel --order unordered --a-chain ibc-0 --b-chain ibc-1 --a-port  transfer --b-port transfer --new-client-connection

</code></pre>
<pre><code class="language-json">🥂  ibc-0 =&gt; OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 66 },
            connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-0",
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                "07-tendermint-0",
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 64 },
            connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-0",
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            counterparty_client_id: ClientId(
                "07-tendermint-0",
            ),
        },
    ),
)

🥂  ibc-0 =&gt; OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 76 },
            connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-0",
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            counterparty_client_id: ClientId(
                "07-tendermint-0",
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 68 },
            connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-0",
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            counterparty_client_id: ClientId(
                "07-tendermint-0",
            ),
        },
    ),
)

🥂🥂🥂  Connection handshake finished for [Connection {
    delay_period: 0s,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
    },
}]

🥳  ibc-0 =&gt; OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 78 },
            port_id: PortId("transfer"),
            channel_id: Some(ChannelId("channel-0")),
            connection_id: ConnectionId("connection-0"),
            counterparty_port_id: PortId("transfer"),
            counterparty_channel_id: None
        }
    )
)

🥳  ibc-1 =&gt; OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 70 },
            port_id: PortId("transfer"),
            channel_id: Some(ChannelId("channel-0")),
            connection_id: ConnectionId("connection-0"),
            counterparty_port_id: PortId("transfer"),
            counterparty_channel_id: Some(ChannelId("channel-0"))
        }
    )
)

🥳  ibc-0 =&gt; OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 81 },
            port_id: PortId("transfer"),
            channel_id: Some(ChannelId("channel-0")),
            connection_id: ConnectionId("connection-0"),
            counterparty_port_id: PortId("transfer"),
            counterparty_channel_id: Some(ChannelId("channel-0"))
        }
    )
)

🥳  ibc-1 =&gt; OpenConfirmChannel
    OpenConfirm
        Attributes {
            height: Height { revision: 1, height: 73 },
            port_id: PortId("transfer"),
            channel_id: Some(ChannelId("channel-0")),
            connection_id: ConnectionId("connection-0"),
            counterparty_port_id: PortId("transfer"),
            counterparty_channel_id: Some(ChannelId("channel-0"))
        }
    )
)

🥳  🥳  🥳  Channel handshake finished for Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: ChannelId(
            "channel-0",
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: ChannelId(
            "channel-0",
        ),
    },
    connection_delay: 0s,
}

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: ChannelId(
            "channel-0",
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: ChannelId(
            "channel-0",
        ),
    },
    connection_delay: 0s,
}
</code></pre>
<p>A new channel with identifier <code>channel-0</code> on both sides has been established on
a new connection with identifier <code>connection-0</code> on both sides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relaying"><a class="header" href="#relaying">Relaying</a></h1>
<p>This section describes the types of relaying that hermes can perform.</p>
<p>Hermes can send transactions triggered by IBC events. It currently handles channel handshake and packet events:</p>
<ul>
<li><a href="documentation/commands/relaying/./packets.html#packet-relaying">packets messages only</a></li>
<li><a href="documentation/commands/relaying/./handshakes.html">channel and packet messages</a></li>
</ul>
<h2 id="the-start-command"><a class="header" href="#the-start-command">The <code>start</code> Command</a></h2>
<p>The <code>start</code> command can be used to start Hermes in IBC event listen mode.</p>
<pre><code class="language-shell">DESCRIPTION:
Start the relayer in multi-chain mode.

Relays packets and open handshake messages between all chains in the config.

USAGE:
    hermes start [OPTIONS]

OPTIONS:
        --full-scan
            Force a full scan of the chains for clients, connections and channels

    -h, --help
            Print help information
</code></pre>
<p>As described in next subsections, the type of relaying can be configured in the <code>global</code> section of the configuration file, by specifying different values in <code>strategy</code> field.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-relaying"><a class="header" href="#packet-relaying">Packet Relaying</a></h1>
<p>This section describes the configuration and commands that can be used to start Hermes and relay packets over one or multiple paths.</p>
<h2 id="table-of-contents-7"><a class="header" href="#table-of-contents-7">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/relaying/packets.html#the-start-command">The <code>start</code> Command</a></li>
<li><a href="documentation/commands/relaying/packets.html#packet-streaming">Packet Streaming</a></li>
<li><a href="documentation/commands/relaying/packets.html#packet-delay">Packet Delay</a></li>
</ul>
<h2 id="the-start-command-1"><a class="header" href="#the-start-command-1">The <code>start</code> Command</a></h2>
<p>To relay packets only configure the <code>mode</code> section of the configuration file like so:</p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
# ...

[mode.connections]
enabled = false

[mode.channels]
enabled = false

[mode.packets]
enabled = true
# ...
</code></pre>
<p>Then start Hermes using the start command:</p>
<pre><code class="language-shell">hermes start

</code></pre>
<p>Hermes sends packet transactions triggered by IBC packet events for all open channels between the configured chains.
This is also referred to packet streaming.</p>
<h2 id="packet-streaming"><a class="header" href="#packet-streaming">Packet Streaming</a></h2>
<p>After Hermes is started using the <code>start</code> command, it listens to IBC packet events emitted by any of
the configured chains. Assuming the events are coming from a <code>source</code> chain, Hermes builds packets
based on these events, packets that are then sent either to the <code>source</code> chain or the counterparty (<code>destination</code>) chain.</p>
<p>Current events and actions are:</p>
<ul>
<li><code>send_packet</code>: Hermes builds a packet message with the <code>packet</code> obtained from the event and any required proofs obtained from the counterparty of the chain where the message is sent. The concrete packet is:
<ul>
<li><code>MsgRecvPacket</code>, sent to <code>destination</code> chain if the channel is in open state on the <code>destination</code> chain, and a timeout has not occurred,</li>
<li><code>MsgTimeout</code>, sent to the <code>source</code> chain if the channel is in open state on the <code>destination</code> chain, but a timeout has occurred.</li>
<li><code>MsgTimeoutOnClose</code>, sent to the <code>source</code> chain if the channel is in closed state on the <code>destination</code> chain.</li>
</ul>
</li>
<li><code>write_acknowledgement</code>: Hermes builds a <code>MsgAcknowledgement</code> packet that is sent to the <code>destination</code> chain.</li>
</ul>
<p>In addition to these events, Hermes will also handle channel closing events:</p>
<ul>
<li><code>chan_close_init</code>: Hermes builds a <code>MsgChannelCloseConfirm</code> and sends it to the <code>destination</code> chain</li>
</ul>
<h2 id="packet-delay"><a class="header" href="#packet-delay">Packet Delay</a></h2>
<p>If the relay path is using a non-zero delay connection, then <code>hermes</code> will delay all packet transactions. The delay is relative to the submission time for the client update at the height required by the packet proof.
The delay is used to prevent light client attacks and ensures that misbehavior detection finalizes before the transaction is submitted.
For more information on the misbehavior detector see <a href="documentation/commands/relaying/../misbehaviour/index.html#monitoring-misbehaviour-and-evidence-submission">the misbehaviour section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relaying-of-handshake-messages"><a class="header" href="#relaying-of-handshake-messages">Relaying of Handshake Messages</a></h1>
<p>This section describes the configuration and commands that can be used to start Hermes and relay both handshake and packets
for connections and channels.</p>
<h2 id="the-start-command-2"><a class="header" href="#the-start-command-2">The <code>start</code> Command</a></h2>
<p>To relay packets and handshake messages configure the <code>mode</code> section of the configuration file like so:</p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
# ...

[mode.connections]
enabled = true

[mode.channels]
enabled = true

[mode.packets]
enabled = true
# ...
</code></pre>
<p>Then start Hermes using the start command:</p>
<pre><code class="language-shell">hermes start

</code></pre>
<p>Hermes sends handshake and packet transactions triggered by IBC events.</p>
<h2 id="completing-channel-handshakes"><a class="header" href="#completing-channel-handshakes">Completing Channel Handshakes</a></h2>
<p>After Hermes is started using the <code>start</code> command, it scans the chain state and will resume the handshake for any
channels or connections that are not in open state. It then listens to IBC events emitted by any of
the configured chains.</p>
<p>Assuming the events are coming from a <code>source</code> chain, Hermes determines the <code>destination</code> chain and builds the handshake messages based on these events. These are then sent to the <code>destination</code> chain.</p>
<p>In addition to the events described in <a href="documentation/commands/relaying/packets.html#packet-relaying">Packet Relaying</a>, the following IBC events may be handled:</p>
<ul>
<li>
<p>Channels (if <code>mode.channels.enabled=true</code>):</p>
<ul>
<li><code>chan_open_init</code>: Hermes builds a <code>MsgChannelOpenTry</code> message</li>
<li><code>chan_open_try</code>: Hermes builds a <code>MsgChannelOpenAck</code> message</li>
<li><code>chan_open_ack</code>: Hermes builds a <code>MsgChannelOpenConfirm</code> message</li>
<li><code>chan_open_confirm</code>: no message is sent out, channel opening is finished</li>
</ul>
</li>
<li>
<p>Connections (if <code>mode.connections.enabled=true</code>):</p>
<ul>
<li><code>conn_open_init</code>: Hermes builds a <code>MsgConnOpenTry</code> message</li>
<li><code>conn_open_try</code>: Hermes builds a <code>MsgConnOpenAck</code> message</li>
<li><code>conn_open_ack</code>: Hermes builds a <code>MsgConnOpenConfirm</code> message</li>
<li><code>conn_open_confirm</code>: no message is sent out, connection opening is finished</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clearing-packets"><a class="header" href="#clearing-packets">Clearing Packets</a></h1>
<h2 id="clear-packets"><a class="header" href="#clear-packets"><code>clear packets</code></a></h2>
<p>This command clears outstanding packets on a given channel in both directions,
by issuing the appropriate <a href="documentation/commands/relaying/../tx/packet.html#relay-receive-and-timeout-packets">packet-recvs</a>
and <a href="documentation/commands/relaying/../tx/packet.html#relay-acknowledgment-packets">packet-acks</a>.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code>DESCRIPTION:
Clear outstanding packets (i.e., packet-recv and packet-ack) on a given channel in both directions.
The channel is identified by the chain, port, and channel IDs at one of its ends

USAGE:
    hermes clear packets [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

OPTIONS:
        --counterparty-key-name &lt;COUNTERPARTY_KEY_NAME&gt;
            Use the given signing key for the counterparty chain (default: `counterparty_key_name`
            config)

    -h, --help
            Print help information

        --key-name &lt;KEY_NAME&gt;
            Use the given signing key for the specified chain (default: `key_name` config)

        --packet-sequences &lt;PACKET_SEQUENCES&gt;
            Sequences of packets to be cleared on the specified chain. Either a single sequence or a
            range of sequences can be specified. If not provided, all pending packets will be
            cleared on both chains. Each element of the comma-separated list must be either a single
            sequence or a range of sequences. Example: `1,10..20` will clear packets with sequences
            1, 10, 11, ..., 20

        --query-packets-chunk-size &lt;QUERY_PACKETS_CHUNK_SIZE&gt;
            Number of packets to fetch at once from the chain (default: `query_packets_chunk_size`
            config)

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel
        --port &lt;PORT_ID&gt;          Identifier of the port
</code></pre>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<ol>
<li>Without Hermes running, send 3 packets over a channel, here <code>channel-13</code>:</li>
</ol>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-height-offset 1000 --number-msgs 3 --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-13 --amount 9999

</code></pre>
<p>Which should output something similar to:</p>
<pre><code>2022-02-24T14:16:28.295526Z  INFO ThreadId(01) using default configuration from '$HOME/.hermes/config.toml'
2022-02-24T14:16:28.330860Z  INFO ThreadId(15) send_tx{id=ibc0}: refresh: retrieved account sequence=61 number=1
2022-02-24T14:16:28.350022Z  INFO ThreadId(15) wait_for_block_commits: waiting for commit of tx hashes(s) AE4C3186778488E45670EB7303FA77E69B39F4E7C7494B05EC51E55136A373D6 id=ibc0
Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 86208,
            },
            packet: Packet {
                sequence: Sequence(
                    14,
                ),
                source_port: PortId(
                    "transfer",
                ),
                source_channel: ChannelId(
                    "channel-13",
                ),
                destination_port: PortId(
                    "transfer",
                ),
                destination_channel: ChannelId(
                    "channel-12",
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 86208,
            },
            packet: Packet {
                sequence: Sequence(
                    15,
                ),
                source_port: PortId(
                    "transfer",
                ),
                source_channel: ChannelId(
                    "channel-13",
                ),
                destination_port: PortId(
                    "transfer",
                ),
                destination_channel: ChannelId(
                    "channel-12",
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 86208,
            },
            packet: Packet {
                sequence: Sequence(
                    16,
                ),
                source_port: PortId(
                    "transfer",
                ),
                source_channel: ChannelId(
                    "channel-13",
                ),
                destination_port: PortId(
                    "transfer",
                ),
                destination_channel: ChannelId(
                    "channel-12",
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
]
</code></pre>
<ol start="2">
<li>Because Hermes is not running these packets won't be relayed,
as can be seen with the <code>query packet pending-sends</code> command:</li>
</ol>
<pre><code>hermes query packet pending-sends --chain ibc-1 --port transfer --channel channel-13

</code></pre>
<p>Which should output something similar to:</p>
<pre><code class="language-2022-02-24T14:21:28.874190Z  INFO ThreadId(01) using default configuration from &#39;$HOME/.hermes/config.toml&#39;">Success: [
    14,
    15,
    16,
]
</code></pre>
<ol start="3">
<li>We can clear them manually using the <code>clear packets</code> command:</li>
</ol>
<pre><code>hermes clear packets --chain ibc-0 --port transfer --channel channel-13

</code></pre>
<p>Which should output something similar to:</p>
<pre><code>2022-02-24T14:17:25.748422Z  INFO ThreadId(01) using default configuration from '$HOME/.hermes/config.toml'
2022-02-24T14:17:25.799704Z  INFO ThreadId(01) PacketRecvCmd{src_chain=ibc0 src_port=transfer src_channel=channel-13 dst_chain=ibc1}: found unprocessed SendPacket events for [Sequence(14), Sequence(15), Sequence(16)] (first 10 shown here; total=3)
2022-02-24T14:17:25.827177Z  INFO ThreadId(01) PacketRecvCmd{src_chain=ibc0 src_port=transfer src_channel=channel-13 dst_chain=ibc1}: ready to fetch a scheduled op. data with batch of size 3 targeting Destination
2022-02-24T14:17:26.504798Z  INFO ThreadId(01) PacketRecvCmd{src_chain=ibc0 src_port=transfer src_channel=channel-13 dst_chain=ibc1}:relay{odata=E96CV_cA5P -&gt;Destination @0-86218; len=3}: assembled batch of 4 message(s)
2022-02-24T14:17:26.508873Z  INFO ThreadId(29) send_tx{id=ibc1}: refresh: retrieved account sequence=54 number=1
2022-02-24T14:17:26.561715Z  INFO ThreadId(29) wait_for_block_commits: waiting for commit of tx hashes(s) 07AA83524257105CC476063932A560893BE8F4E94C679BFD00F970FC248647E0 id=ibc1
2022-02-24T14:17:31.948950Z  INFO ThreadId(01) PacketRecvCmd{src_chain=ibc0 src_port=transfer src_channel=channel-13 dst_chain=ibc1}:relay{odata=E96CV_cA5P -&gt;Destination @0-86218; len=3}: [Sync-&gt;ibc1] result events:
    UpdateClientEv(h: 0-86215, cs_h: 07-tendermint-3(0-86219))
    WriteAcknowledgementEv(WriteAcknowledgement - h:0-86215, seq:14, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))
    WriteAcknowledgementEv(WriteAcknowledgement - h:0-86215, seq:15, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))
    WriteAcknowledgementEv(WriteAcknowledgement - h:0-86215, seq:16, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))


2022-02-24T14:17:31.949192Z  INFO ThreadId(01) PacketRecvCmd{src_chain=ibc0 src_port=transfer src_channel=channel-13 dst_chain=ibc1}:relay{odata=E96CV_cA5P -&gt;Destination @0-86218; len=3}: success
2022-02-24T14:17:31.989215Z  INFO ThreadId(01) PacketAckCmd{src_chain=ibc1 src_port=transfer src_channel=channel-12 dst_chain=ibc0}: found unprocessed WriteAcknowledgement events for [Sequence(14), Sequence(15), Sequence(16)] (first 10 shown here; total=3)
2022-02-24T14:17:32.013500Z  INFO ThreadId(01) PacketAckCmd{src_chain=ibc1 src_port=transfer src_channel=channel-12 dst_chain=ibc0}: ready to fetch a scheduled op. data with batch of size 3 targeting Destination
2022-02-24T14:17:33.211930Z  INFO ThreadId(01) PacketAckCmd{src_chain=ibc1 src_port=transfer src_channel=channel-12 dst_chain=ibc0}:relay{odata=L4fnSXkxL_ -&gt;Destination @0-86215; len=3}: assembled batch of 4 message(s)
2022-02-24T14:17:33.215803Z  INFO ThreadId(15) send_tx{id=ibc0}: refresh: retrieved account sequence=62 number=1
2022-02-24T14:17:33.245229Z  INFO ThreadId(15) wait_for_block_commits: waiting for commit of tx hashes(s) 62C69B1C46AF45182D5D99C6CB5EB301F8A402726772BA4EE067B18C68F2A4D6 id=ibc0
2022-02-24T14:17:37.465489Z  INFO ThreadId(01) PacketAckCmd{src_chain=ibc1 src_port=transfer src_channel=channel-12 dst_chain=ibc0}:relay{odata=L4fnSXkxL_ -&gt;Destination @0-86215; len=3}: [Sync-&gt;ibc0] result events:
    UpdateClientEv(h: 0-86221, cs_h: 07-tendermint-3(0-86216))
    AcknowledgePacketEv(h:0-86221, seq:14, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))
    AcknowledgePacketEv(h:0-86221, seq:15, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))
    AcknowledgePacketEv(h:0-86221, seq:16, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))


2022-02-24T14:17:37.465802Z  INFO ThreadId(01) PacketAckCmd{src_chain=ibc1 src_port=transfer src_channel=channel-12 dst_chain=ibc0}:relay{odata=L4fnSXkxL_ -&gt;Destination @0-86215; len=3}: success
Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 86215,
                },
                client_id: ClientId(
                    "07-tendermint-3",
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 0,
                    height: 86219,
                },
            },
            header: Some(
                Tendermint(
                     Header {...},
                ),
            ),
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 0,
                height: 86215,
            },
            packet: Packet {
                sequence: Sequence(
                    14,
                ),
                source_port: PortId(
                    "transfer",
                ),
                source_channel: ChannelId(
                    "channel-13",
                ),
                destination_port: PortId(
                    "transfer",
                ),
                destination_channel: ChannelId(
                    "channel-12",
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
            ack: [ ... ],
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 0,
                height: 86215,
            },
            packet: Packet {
                sequence: Sequence(
                    15,
                ),
                source_port: PortId(
                    "transfer",
                ),
                source_channel: ChannelId(
                    "channel-13",
                ),
                destination_port: PortId(
                    "transfer",
                ),
                destination_channel: ChannelId(
                    "channel-12",
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
            ack: [ ... ],
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 0,
                height: 86215,
            },
            packet: Packet {
                sequence: Sequence(
                    16,
                ),
                source_port: PortId(
                    "transfer",
                ),
                source_channel: ChannelId(
                    "channel-13",
                ),
                destination_port: PortId(
                    "transfer",
                ),
                destination_channel: ChannelId(
                    "channel-12",
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
            ack: [ ... ],
        },
    ),
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 86221,
                },
                client_id: ClientId(
                    "07-tendermint-3",
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 0,
                    height: 86216,
                },
            },
            header: Some(
                Tendermint(
                     Header {...},
                ),
            ),
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 86221,
            },
            packet: Packet {
                sequence: Sequence(
                    14,
                ),
                source_port: PortId(
                    "transfer",
                ),
                source_channel: ChannelId(
                    "channel-13",
                ),
                destination_port: PortId(
                    "transfer",
                ),
                destination_channel: ChannelId(
                    "channel-12",
                ),
                data: [],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 86221,
            },
            packet: Packet {
                sequence: Sequence(
                    15,
                ),
                source_port: PortId(
                    "transfer",
                ),
                source_channel: ChannelId(
                    "channel-13",
                ),
                destination_port: PortId(
                    "transfer",
                ),
                destination_channel: ChannelId(
                    "channel-12",
                ),
                data: [],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 86221,
            },
            packet: Packet {
                sequence: Sequence(
                    16,
                ),
                source_port: PortId(
                    "transfer",
                ),
                source_channel: ChannelId(
                    "channel-13",
                ),
                destination_port: PortId(
                    "transfer",
                ),
                destination_channel: ChannelId(
                    "channel-12",
                ),
                data: [],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
]
</code></pre>
<ol start="4">
<li>The packets have now been successfully relayed:</li>
</ol>
<pre><code>hermes query packet pending-sends --chain ibc-1 --port transfer --channel channel-13

</code></pre>
<p>Which should output something similar to:</p>
<pre><code>2022-02-24T14:21:28.874190Z  INFO ThreadId(01) using default configuration from '$HOME/.hermes/config.toml'
Success: []
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listen-mode"><a class="header" href="#listen-mode">Listen Mode</a></h1>
<p>Hermes can be started in <code>listen</code> mode to display the events emitted by a given chain. <code>NewBlock</code> and <code>Tx</code> IBC events are shown.</p>
<pre><code class="language-shell">DESCRIPTION:
Listen to and display IBC events emitted by a chain

USAGE:
    hermes listen [OPTIONS] --chain &lt;CHAIN_ID&gt;

OPTIONS:
        --events &lt;EVENT&gt;...    Add an event type to listen for, can be repeated. Listen for all
                               events by default (available: Tx, NewBlock)
    -h, --help                 Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain to listen for events from
</code></pre>
<p><strong>Example</strong></p>
<p>Start Hermes in listen mode for all <code>ibc-0</code> events and observe the output:</p>
<pre><code class="language-shell">hermes listen --chain ibc-0

</code></pre>
<pre><code class="language-json">EventBatch {
    chain_id: ChainId {
        id: "ibc-0",
        version: 0,
    },
    height: block::Height(10914),
    events: [
        NewBlock(
            NewBlock {
                height: block::Height(10914),
            },
        ),
    ],
}
EventBatch {
    chain_id: ChainId {
        id: "ibc-0",
        version: 0,
    },
    height: block::Height(10915),
    events: [
        OpenInitConnection(
            OpenInit(
                Attributes {
                    height: block::Height(10915),
                    connection_id: Some(
                        ConnectionId(
                            "connection-3",
                        ),
                    ),
                    client_id: ClientId(
                        "07-tendermint-3",
                    ),
                    counterparty_connection_id: None,
                    counterparty_client_id: ClientId(
                        "07-tendermint-5",
                    ),
                },
            ),
        ),
    ],

...

EventBatch {
    chain_id: ChainId {
        id: "ibc-0",
        version: 0,
    },
    height: block::Height(10919),
    events: [
        UpdateClient(
            UpdateClient(
                Attributes {
                    height: block::Height(10919),
                    client_id: ClientId(
                        "07-tendermint-3",
                    ),
                    client_type: Tendermint,
                    consensus_height: Height {
                        revision: 1,
                        height: 10907,
                    },
                },
            ),
        ),
    ],
}

...

EventBatch {
    chain_id: ChainId {
        id: "ibc-0",
        version: 0,
    },
    height: block::Height(10924),
    events: [
        UpdateClient(
            UpdateClient(
                Attributes {
                    height: block::Height(10924),
                    client_id: ClientId(
                        "07-tendermint-3",
                    ),
                    client_type: Tendermint,
                    consensus_height: Height {
                        revision: 1,
                        height: 10912,
                    },
                },
            ),
        ),
        OpenAckConnection(
            OpenAck(
                Attributes {
                    height: block::Height(10924),
                    connection_id: Some(
                        ConnectionId(
                            "connection-3",
                        ),
                    ),
                    client_id: ClientId(
                        "07-tendermint-3",
                    ),
                    counterparty_connection_id: Some(
                        ConnectionId(
                            "connection-5",
                        ),
                    ),
                    counterparty_client_id: ClientId(
                        "07-tendermint-5",
                    ),
                },
            ),
        ),
    ],
}
</code></pre>
<h2 id="filter-events"><a class="header" href="#filter-events">Filter events</a></h2>
<p>The <code>listen</code> command accepts a <code>--events</code> flag to specify which event types to listen for.</p>
<p>At the moment, two event types are available:</p>
<ul>
<li><code>NewBlock</code></li>
<li><code>Tx</code></li>
</ul>
<p>The <code>--events</code> flag can be repeated to specify more than one event type.</p>
<ul>
<li>To listen for only <code>NewBlock</code> events on <code>ibc-0</code>, invoke <code>hermes listen --events NewBlock --chain ibc-0 </code></li>
<li>To listen for only <code>Tx</code> events on <code>ibc-0</code>, invoke <code>hermes listen --events Tx --chain ibc-0 </code></li>
<li>To listen for both <code>NewBlock</code> and <code>Tx</code> events on <code>ibc-0</code>, invoke <code>hermes listen --events NewBlock Tx --chain ibc-0 </code></li>
</ul>
<p>If the <code>--events</code> flag is omitted, Hermes will subscribe to all event types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrading-clients"><a class="header" href="#upgrading-clients">Upgrading Clients</a></h1>
<p>If IBC clients need to be upgraded after their reference chains went through an upgrade, the following CLIs may be used.</p>
<h2 id="upgrade-client-command"><a class="header" href="#upgrade-client-command">Upgrade Client Command</a></h2>
<p>Use the <code>upgrade client</code> command to upgrade a specific IBC client after a chain upgrade.</p>
<pre><code class="language-shell">DESCRIPTION:
Upgrade an IBC client

USAGE:
    hermes upgrade client --host-chain &lt;HOST_CHAIN_ID&gt; --client &lt;CLIENT_ID&gt; --upgrade-height &lt;REFERENCE_UPGRADE_HEIGHT&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --client &lt;CLIENT_ID&gt;
            Identifier of the client to be upgraded

        --host-chain &lt;HOST_CHAIN_ID&gt;
            Identifier of the chain that hosts the client

        --upgrade-height &lt;REFERENCE_UPGRADE_HEIGHT&gt;
            The height at which the reference chain halts for the client upgrade
</code></pre>
<h2 id="upgrade-clients-command"><a class="header" href="#upgrade-clients-command">Upgrade Clients Command</a></h2>
<p>Use the <code>upgrade clients</code> command to upgrade all IBC clients that target a specific (upgraded) chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Upgrade all IBC clients that target a specific chain

USAGE:
    hermes upgrade clients [OPTIONS] --reference-chain &lt;REFERENCE_CHAIN_ID&gt; --upgrade-height &lt;REFERENCE_UPGRADE_HEIGHT&gt;

OPTIONS:
    -h, --help                          Print help information
        --host-chain &lt;HOST_CHAIN_ID&gt;    Identifier of the chain hosting the clients to be upgraded

REQUIRED:
        --reference-chain &lt;REFERENCE_CHAIN_ID&gt;
            Identifier of the chain that underwent an upgrade; all clients targeting this chain will
            be upgraded

        --upgrade-height &lt;REFERENCE_UPGRADE_HEIGHT&gt;
            The height at which the reference chain halts for the client upgrade
</code></pre>
<p><strong>Example</strong></p>
<p>Here is <a href="documentation/commands/upgrade/./test.html">an example</a> of a chain upgrade proposal submission and client upgrade.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-client-upgrade"><a class="header" href="#testing-client-upgrade">Testing Client Upgrade</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Gaiad <code>(v7.0.*)</code>, for example:</li>
</ul>
<pre><code class="language-shell">gaiad version --log_level error --long | head -n4
</code></pre>
<h2 id="testing-procedure"><a class="header" href="#testing-procedure">Testing procedure</a></h2>
<h3 id="setup-using-gaia-manager"><a class="header" href="#setup-using-gaia-manager">Setup using Gaia manager</a></h3>
<blockquote>
<p>Note: The <code>gm.toml</code> file that we're using here looks like this:</p>
</blockquote>
<pre><code>[global]
  add_to_hermes = true
  auto_maintain_config = true
  extra_wallets = 2
  gaiad_binary = "$GOPATH/bin/gaiad"
  hdpath = ""
  home_dir = "$HOME/.gm"
  ports_start_at = 27040
  validator_mnemonic = ""
  wallet_mnemonic = ""

  [global.hermes]
    binary = "&lt;path/to/hermes&gt;"
    config = "$HOME/.hermes/config.toml"
    log_level = "info"
    telemetry_enabled = true
    telemetry_host = "127.0.0.1"
    telemetry_port = 3001

[ibc-0]
  ports_start_at = 27000

[ibc-1]
  ports_start_at = 27010
</code></pre>
<ul>
<li>Run the command <code>gm start</code></li>
<li>Go to the file <code>$HOME/.gm/ibc-0/config/genesis.json</code> and change <code>max_deposit_period</code> and <code>voting_period</code> to a lower value, such as 120s</li>
<li>Run the commands: <code>gm reset</code>, <code>gm hermes config</code> and <code>gm hermes keys</code></li>
</ul>
<h3 id="test-upgrading-chain-and-client"><a class="header" href="#test-upgrading-chain-and-client">Test upgrading chain and client</a></h3>
<ol>
<li>
<p>Create one client on <code>ibc-1</code> for <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes create client --host-chain ibc-1 --reference-chain ibc-0

</code></pre>
<pre><code class="language-json">Success: CreateClient(
   CreateClient(
       Attributes {
           height: Height { revision: 1, height: 9 },
           client_id: ClientId(
               "07-tendermint-0",
           ),
           client_type: Tendermint,
           consensus_height: Height { revision: 0, height: 18 },
       },
   ),
)
</code></pre>
</li>
<li>
<p>Create and submit an upgrade plan for chain <code>ibc-0</code>:</p>
<p>Use test command to make an upgrade proposal. In the example below a software upgrade proposal is made for <code>ibc-0</code>, for the height <code>300</code> blocks from the latest height. <code>10000000stake</code> is deposited.
The proposal includes the upgraded client state constructed from the state of <code>07-tendermint-0</code> client on <code>ibc-1</code> that was created in the previous step.</p>
<p>If the chain is using ibc-go version <code>v8.0.0</code> or higher, the authority account for the governance module needs to be used. To query the account use:</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:27000 --home $HOME/.gm/ibc-0/ query auth module-account gov
</code></pre>
<pre><code class="language-shell">hermes tx upgrade-chain --gov-account &lt;QUERIED_ACCOUNT&gt; --reference-chain ibc-0 --host-chain ibc-1 --host-client 07-tendermint-0 --amount 10000000 --height-offset 60

</code></pre>
<p>If the ibc-go version used is lower than <code>v8.0.0</code> you can ignore the <code>--gov-account</code> flag as it will not be used.</p>
<pre><code class="language-shell">hermes tx upgrade-chain --reference-chain ibc-0 --host-chain ibc-1 --host-client 07-tendermint-0 --amount 10000000 --height-offset 60

</code></pre>
<p>For this test, the <code>--gov-account</code> can be ignored.</p>
<pre><code class="language-text">Success: transaction::Hash(CE98D8D98091BA8016BD852D18056E54C4CB3C4525E7F40DD3C40B4FD0F2482B)
</code></pre>
</li>
<li>
<p>Verify that the proposal was accepted by querying the upgrade plan to check that it was submitted correctly.</p>
<blockquote>
<p>Note: You can find the RPC port used to query the local node by running
<code>gm ports</code> in order to see a list of the ports being used.</p>
</blockquote>
<pre><code class="language-shell">gaiad --node tcp://localhost:27000 query gov proposal 1 --home $HOME/.gm/ibc-0/
</code></pre>
<p>If successful, you should see output like this. Note that the status of the proposal near the bottom of the output should be
<code>PROPOSAL_STATUS_VOTING_PERIOD</code> indicating that the voting period is still ongoing.</p>
<pre><code class="language-text">content:
  '@type': /ibc.core.client.v1.UpgradeProposal
  description: upgrade the chain software and unbonding period
  plan:
    height: "65"
    info: ""
    name: plan
    time: "0001-01-01T00:00:00Z"
    upgraded_client_state: null
  title: proposal 0
  upgraded_client_state:
    '@type': /ibc.lightclients.tendermint.v1.ClientState
    allow_update_after_expiry: false
    allow_update_after_misbehaviour: false
    chain_id: ibc-0
    frozen_height:
      revision_height: "0"
      revision_number: "0"
    latest_height:
      revision_height: "66"
      revision_number: "0"
    max_clock_drift: 0s
    proof_specs:
    - inner_spec:
        child_order:
        - 0
        - 1
        child_size: 33
        empty_child: null
        hash: SHA256
        max_prefix_length: 12
        min_prefix_length: 4
      leaf_spec:
        hash: SHA256
        length: VAR_PROTO
        prefix: AA==
        prehash_key: NO_HASH
        prehash_value: SHA256
      max_depth: 0
      min_depth: 0
    - inner_spec:
        child_order:
        - 0
        - 1
        child_size: 32
        empty_child: null
        hash: SHA256
        max_prefix_length: 1
        min_prefix_length: 1
      leaf_spec:
        hash: SHA256
        length: VAR_PROTO
        prefix: AA==
        prehash_key: NO_HASH
        prehash_value: SHA256
      max_depth: 0
      min_depth: 0
    trust_level:
      denominator: "0"
      numerator: "0"
    trusting_period: 0s
    unbonding_period: 1814400s
    upgrade_path:
    - upgrade
    - upgradedIBCState
deposit_end_time: "2022-07-06T15:14:38.993051Z"
final_tally_result:
  abstain: "0"
  "no": "0"
  no_with_veto: "0"
  "yes": "0"
proposal_id: "1"
status: PROPOSAL_STATUS_VOTING_PERIOD
submit_time: "2022-07-06T15:12:38.993051Z"
total_deposit:
- amount: "10000000"
  denom: stake
voting_end_time: "2022-07-06T15:14:38.993051Z"
voting_start_time: "2022-07-06T15:12:38.993051Z"
</code></pre>
</li>
<li>
<p>Vote on the proposal</p>
<p>The parameter <code>1</code> should match the <code>proposal_id:</code> from the upgrade proposal submitted at step 3.
This command must be issued while the proposal status is <code>PROPOSAL_STATUS_VOTING_PERIOD</code>. Confirm transaction when prompted.</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:27000 tx gov vote 1 yes --home $HOME/.gm/ibc-0/data/ --keyring-backend test --keyring-dir $HOME/.gm/ibc-0/ --chain-id ibc-0 --from validator
</code></pre>
<pre><code class="language-text">confirm transaction before signing and broadcasting [y/N]: y

txhash: 50CC1C39FBB14F99580A916ADE7F02883FFCC35D7862153F16BE86138151E17C
</code></pre>
</li>
<li>
<p>Test the <code>upgrade client</code> CLI</p>
<p>The following command waits for the reference chain <code>ibc-0</code> to halt and then performs the upgrade for client <code>07-tendermint-0</code> on <code>ibc-1</code>. It outputs two events, one for the updated client state,
and another for the upgraded state.
The <code>--upgrade-height 65</code> value is taken from the <code>height</code> in the upgrade plan output.</p>
<pre><code class="language-shell">hermes upgrade client --host-chain ibc-1 --client 07-tendermint-0 --upgrade-height 65

</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        h: 1-68, cs_h: 07-tendermint-0(0-65),
    ),
    UpgradeClient(
        UpgradeClient(
            Attributes {
                height: Height {
                    revision: 1,
                    height: 68,
                },
                client_id: ClientId(
                    "07-tendermint-0",
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 0,
                    height: 66,
                },
            },
        ),
    ),
]
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ibc-packet-forwarding"><a class="header" href="#ibc-packet-forwarding">IBC Packet Forwarding</a></h1>
<p>This section covers IBC packet forwarding introduced in Gaia v6.0.x</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p><strong>v3.0.0+</strong></p>
<p>Packet forwarding middleware introduced</p>
<p>Packet forwarding allows a Chain to send a packet to another chain without having a direct channel. This means that if there are three Chains A, B and C, with the following channels:</p>
<pre class="mermaid">flowchart LR
    A((ibc-0))---B((ibc-1))---C((ibc-2))
</pre>
<p>Then if the IBC packet forward middleware is active, Chain A can send a packet to Chain C, by including the following memo:</p>
<pre><code class="language-json">{
  "forward": {
    "receiver": "chain-c-bech32-address",
    "port": "transfer",
    "channel": "channel-123"
  }
}
</code></pre>
<p>If there are four Chains A, B, C and D, with the following channels:</p>
<pre class="mermaid">flowchart LR
    A((ibc-0))---B((ibc-1))---C((ibc-2))---D((ibc-3))
</pre>
<p>Then if the IBC packet forward middleware is active, Chain A can send a packet to Chain D, by including the following memo:</p>
<pre><code class="language-json">{
  "forward": {
    "receiver": "chain-c-bech32-address",
    "port": "transfer",
    "channel": "channel-a-to-b",
    "timeout": "10m",
    "retries": 2,
    "next": {
      "forward": {
        "receiver": "chain-d-bech32-address",
        "port": "transfer",
        "channel":"channel-c-to-d",
        "timeout":"10m",
        "retries": 2
      }
    }
  }
}
</code></pre>
<h2 id="legacy-method"><a class="header" href="#legacy-method">Legacy method</a></h2>
<p>Before the packet forward middleware <code>v3.0.0</code> the receiver address was used to forward packets. In order for Chain A to send a packet to Chain C, the receiver of the packet had to be set as following:</p>
<pre><code>{intermediate_refund_address}|{forward_port}/{forward_channel}:{final_destination_address}
</code></pre>
<p>As specified in the packet-forward-middleware module implementation, <a href="https://github.com/strangelove-ventures/packet-forward-middleware/tree/v2.1.3#example">packet-forward-middleware</a>.</p>
<h2 id="important-notice"><a class="header" href="#important-notice">Important notice</a></h2>
<p>Depending on which major version of Gaia is used, the behaviour of packet forwarding will change.</p>
<p><strong>Gaia v7.0.x</strong></p>
<p>The IBC packet forward middleware is disabled on this version. This will cause the sender to be refunded when trying to transfer tokens using packet forwarding.</p>
<p><strong>Gaia v6.0.x</strong></p>
<p>Since this version uses the packet-forward-middleware v1.0.1 and the atomic forward feature was only introduced in v3, if the destination address is invalid, then the intermediary chain will be refunded instead of the sender. And it uses the overloaded receiver method to forward packets.</p>
<p><strong>Gaia v8.0.x</strong></p>
<p>Everything seems to be working as expected in this version, using the <code>memo</code> field to forward packets.</p>
<p><strong>Example</strong></p>
<p>Here is <a href="documentation/forwarding/./test.html">an example</a> of token transfer from Chain A to Chain C, going through Chain B using the <code>memo</code> field.</p>
<p><strong>Legacy Example</strong></p>
<p>Here is <a href="documentation/forwarding/./legacy_test.html">an example</a> of token transfer from Chain A to Chain C, going through Chain B using the overloaded receiver.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-packet-forwarding"><a class="header" href="#testing-packet-forwarding">Testing Packet Forwarding</a></h1>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<ul>
<li>Gaiad at least <code>(v8.0.0)</code>. The version can be checked with:</li>
</ul>
<pre><code class="language-shell">gaiad version --log_level error --long | head -n4
</code></pre>
<h2 id="testing-procedure-1"><a class="header" href="#testing-procedure-1">Testing procedure</a></h2>
<h3 id="setup-using-gaia-manager-1"><a class="header" href="#setup-using-gaia-manager-1">Setup using Gaia manager</a></h3>
<blockquote>
<p>Note: The <code>gm.toml</code> file that we're using here looks like this:</p>
</blockquote>
<pre><code>[global]
  add_to_hermes = true
  auto_maintain_config = true
  extra_wallets = 2
  gaiad_binary = "/Users/luca/go/bin/gaiad"
  hdpath = ""
  home_dir = "/Users/luca/.gm"
  ports_start_at = 27000
  validator_mnemonic = ""
  wallet_mnemonic = ""

  [global.hermes]
    binary = "$HOME/.hermes/bin/hermes"
    config = "$HOME/.hermes/config.toml"
    log_level = "trace"
    telemetry_enabled = true
    telemetry_host = "127.0.0.1"
    telemetry_port = 3001

[ibc-0]
  ports_start_at = 27000

[ibc-1]
  ports_start_at = 27010

[ibc-2]
  ports_start_at = 27020
</code></pre>
<ul>
<li>Run the command <code>gm start</code></li>
<li>Run the commands: <code>gm hermes config</code> and <code>gm hermes keys</code></li>
</ul>
<h3 id="test-packet-forwarding"><a class="header" href="#test-packet-forwarding">Test packet forwarding</a></h3>
<ol>
<li>
<p>Create a channel between <code>ibc-0</code> and <code>ibc-1</code>, and another between <code>ibc-1</code> and <code>ibc-2</code>:</p>
<pre><code class="language-shell">hermes create channel --a-chain ibc-0 --b-chain ibc-1 --a-port transfer --b-port transfer --new-client-connection

</code></pre>
<pre><code class="language-json">SUCCESS Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
        version: None,
    },
    b_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
        version: None,
    },
    connection_delay: 0ns,
}
</code></pre>
<pre><code class="language-shell">hermes create channel --a-chain ibc-1 --b-chain ibc-2 --a-port transfer --b-port transfer --new-client-connection

</code></pre>
<pre><code class="language-json">SUCCESS Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-1",
        ),
        connection_id: ConnectionId(
            "connection-1",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-1",
            ),
        ),
        version: None,
    },
    b_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-2",
                version: 2,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
        version: None,
    },
    connection_delay: 0ns,
}
</code></pre>
</li>
<li>
<p>Obtain the addresses of the wallets on each chain:</p>
<pre><code class="language-shell">hermes keys list --chain ibc-0

</code></pre>
<pre><code class="language-json">SUCCESS 
- wallet2 (cosmos179ld56nmany7nqmsdjz684rx5t4r5gxspn6hgr)
- wallet (cosmos1gz507egejvz3ukg3xwr3v04n3xcny7vcnkjw32)
- wallet1 (cosmos14cgtalvczzm6xuaa086g5tx6sss6e85j55vqrd)
</code></pre>
<pre><code class="language-shell">hermes keys list --chain ibc-1

</code></pre>
<pre><code class="language-json">SUCCESS 
- wallet2 (cosmos1pmzq62tewxla9z7gpntcnvszyrkygnk4mesauy)
- wallet (cosmos1jwr34yvnkqkc0ddndnh9y8t94hlhn7rapfyags)
- wallet1 (cosmos1at4nj238c3ltlj0wymwgfjmdjctlvstwj8xl2s)
</code></pre>
<pre><code class="language-shell">hermes keys list --chain ibc-2

</code></pre>
<pre><code class="language-json">SUCCESS 
- wallet2 (cosmos1xpezl2vvwg9fhdmksvne6lygd7dwz4vf65v6ye)
- wallet (cosmos1nsztzzhl553avufxhqa204908l4dndafqph4tw)
- wallet1 (cosmos1csdnmydggcyvjd7z8l64z9lpdgmgyr4v7hw5r8)
</code></pre>
</li>
<li>
<p>(Optional) Check the balance of the wallets before transferring tokens:</p>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-0

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        100000000 samoleans
        99992294 stake
</code></pre>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-1

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        100000000 samoleans
        99983377 stake
</code></pre>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-2

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        100000000 samoleans
        99990916 stake
</code></pre>
</li>
<li>
<p>(Optional) Confirm the name of the channels used for the transfer:</p>
<pre><code class="language-shell">hermes query channels --counterparty-chain ibc-1 --chain ibc-0

</code></pre>
<pre><code class="language-json">SUCCESS [
    PortChannelId {
        channel_id: ChannelId(
            "channel-0",
        ),
        port_id: PortId(
            "transfer",
        ),
    },
]
</code></pre>
<pre><code class="language-shell">hermes query channels --counterparty-chain ibc-2 --chain ibc-1

</code></pre>
<pre><code class="language-json">SUCCESS [
    PortChannelId {
        channel_id: ChannelId(
            "channel-1",
        ),
        port_id: PortId(
            "transfer",
        ),
    },
]
</code></pre>
</li>
<li>
<p>In a separate terminal, start an instance of Hermes:</p>
<pre><code class="language-shell">hermes start

</code></pre>
</li>
<li>
<p>Transfer token using the special receiver:</p>
<pre><code class="language-shell">hermes tx ft-transfer --denom samoleans --receiver cosmos1jwr34yvnkqkc0ddndnh9y8t94hlhn7rapfyags --memo '{"forward": {"receiver": "cosmos1al3csagycya3l7ze3dk4345czw9vwgtjtsezut", "port": "transfer", "channel": "channel-1"}}' --timeout-seconds 120  --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-0 --amount 2500
</code></pre>
<pre><code class="language-json">SUCCESS [
    IbcEventWithHeight {
        event: SendPacket(
            SendPacket {
                packet: Packet {
                    sequence: Sequence(
                        2,
                    ),
                    source_port: PortId(
                        "transfer",
                    ),
                    source_channel: ChannelId(
                        "channel-0",
                    ),
                    destination_port: PortId(
                        "transfer",
                    ),
                    destination_channel: ChannelId(
                        "channel-0",
                    ),
                    data: [123, 34, 97, 109, 111, 117, 110, 116, 34, 58, 34, 50, 53, 48, 48, 34, 44, 34, 100, 101, 110, 111, 109, 34, 58, 34, 115, 97, 109, 111, 108, 101, 97, 110, 115, 34, 44, 34, 114, 101, 99, 101, 105, 118, 101, 114, 34, 58, 34, 99, 111, 115, 109, 111, 115, 49, 106, 119, 114, 51, 52, 121, 118, 110, 107, 113, 107, 99, 48, 100, 100, 110, 100, 110, 104, 57, 121, 56, 116, 57, 52, 104, 108, 104, 110, 55, 114, 97, 112, 102, 121, 97, 103, 115, 124, 116, 114, 97, 110, 115, 102, 101, 114, 47, 99, 104, 97, 110, 110, 101, 108, 45, 49, 58, 99, 111, 115, 109, 111, 115, 49, 110, 115, 122, 116, 122, 122, 104, 108, 53, 53, 51, 97, 118, 117, 102, 120, 104, 113, 97, 50, 48, 52, 57, 48, 56, 108, 52, 100, 110, 100, 97, 102, 113, 112, 104, 52, 116, 120, 34, 44, 34, 115, 101, 110, 100, 101, 114, 34, 58, 34, 99, 111, 115, 109, 111, 115, 49, 103, 122, 53, 48, 55, 101, 103, 101, 106, 118, 122, 51, 117, 107, 103, 51, 120, 119, 114, 51, 118, 48, 52, 110, 51, 120, 99, 110, 121, 55, 118, 99, 110, 107, 106, 119, 51, 50, 34, 125],
                    timeout_height: Never,
                    timeout_timestamp: Timestamp {
                        time: Some(
                            Time(
                                2022-11-10 16:05:13.409228,
                            ),
                        ),
                    },
                },
            },
        ),
        height: Height {
            revision: 0,
            height: 59,
        },
    },
]
</code></pre>
</li>
<li>
<p>(Optional) Check the balances:</p>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-0

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        99997500 samoleans
        99985136 stake
</code></pre>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-1

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        100000000 samoleans
        99972551 stake
</code></pre>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-2

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        2500 ibc/F47F0D7C9B4F7D971DF647A75A80CB8D905D3230262FEF2996340664D3A12D48
        100000000 samoleans
        99987055 stake
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-packet-forwarding-1"><a class="header" href="#testing-packet-forwarding-1">Testing Packet Forwarding</a></h1>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<ul>
<li>Gaiad <code>(v6.*.*)</code>. The version can be checked with:</li>
</ul>
<pre><code class="language-shell">gaiad version --log_level error --long | head -n4
</code></pre>
<h2 id="testing-procedure-2"><a class="header" href="#testing-procedure-2">Testing procedure</a></h2>
<h3 id="setup-using-gaia-manager-2"><a class="header" href="#setup-using-gaia-manager-2">Setup using Gaia manager</a></h3>
<blockquote>
<p>Note: The <code>gm.toml</code> file that we're using here looks like this:</p>
</blockquote>
<pre><code>[global]
  add_to_hermes = true
  auto_maintain_config = true
  extra_wallets = 2
  gaiad_binary = "/Users/luca/go/bin/gaiad"
  hdpath = ""
  home_dir = "/Users/luca/.gm"
  ports_start_at = 27000
  validator_mnemonic = ""
  wallet_mnemonic = ""

  [global.hermes]
    binary = "$HOME/.hermes/bin/hermes"
    config = "$HOME/.hermes/config.toml"
    log_level = "trace"
    telemetry_enabled = true
    telemetry_host = "127.0.0.1"
    telemetry_port = 3001

[ibc-0]
  ports_start_at = 27000

[ibc-1]
  ports_start_at = 27010

[ibc-2]
  ports_start_at = 27020
</code></pre>
<ul>
<li>Run the command <code>gm start</code></li>
<li>Run the commands: <code>gm hermes config</code> and <code>gm hermes keys</code></li>
</ul>
<h3 id="test-packet-forwarding-1"><a class="header" href="#test-packet-forwarding-1">Test packet forwarding</a></h3>
<ol>
<li>
<p>Create a channel between <code>ibc-0</code> and <code>ibc-1</code>, and another between <code>ibc-1</code> and <code>ibc-2</code>:</p>
<pre><code class="language-shell">hermes create channel --a-chain ibc-0 --b-chain ibc-1 --a-port transfer --b-port transfer --new-client-connection

</code></pre>
<pre><code class="language-json">SUCCESS Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-0",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
        version: None,
    },
    b_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
        version: None,
    },
    connection_delay: 0ns,
}
</code></pre>
<pre><code class="language-shell">hermes create channel --a-chain ibc-1 --b-chain ibc-2 --a-port transfer --b-port transfer --new-client-connection

</code></pre>
<pre><code class="language-json">SUCCESS Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-1",
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-1",
        ),
        connection_id: ConnectionId(
            "connection-1",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-1",
            ),
        ),
        version: None,
    },
    b_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "ibc-2",
                version: 2,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-0",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
        version: None,
    },
    connection_delay: 0ns,
}
</code></pre>
</li>
<li>
<p>Obtain the addresses of the wallets on each chain:</p>
<pre><code class="language-shell">hermes keys list --chain ibc-0

</code></pre>
<pre><code class="language-json">SUCCESS 
- wallet2 (cosmos179ld56nmany7nqmsdjz684rx5t4r5gxspn6hgr)
- wallet (cosmos1gz507egejvz3ukg3xwr3v04n3xcny7vcnkjw32)
- wallet1 (cosmos14cgtalvczzm6xuaa086g5tx6sss6e85j55vqrd)
</code></pre>
<pre><code class="language-shell">hermes keys list --chain ibc-1

</code></pre>
<pre><code class="language-json">SUCCESS 
- wallet2 (cosmos1pmzq62tewxla9z7gpntcnvszyrkygnk4mesauy)
- wallet (cosmos1jwr34yvnkqkc0ddndnh9y8t94hlhn7rapfyags)
- wallet1 (cosmos1at4nj238c3ltlj0wymwgfjmdjctlvstwj8xl2s)
</code></pre>
<pre><code class="language-shell">hermes keys list --chain ibc-2

</code></pre>
<pre><code class="language-json">SUCCESS 
- wallet2 (cosmos1xpezl2vvwg9fhdmksvne6lygd7dwz4vf65v6ye)
- wallet (cosmos1nsztzzhl553avufxhqa204908l4dndafqph4tw)
- wallet1 (cosmos1csdnmydggcyvjd7z8l64z9lpdgmgyr4v7hw5r8)
</code></pre>
</li>
<li>
<p>(Optional) Check the balance of the wallets before transferring tokens:</p>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-0

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        100000000 samoleans
        99992294 stake
</code></pre>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-1

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        100000000 samoleans
        99983377 stake
</code></pre>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-2

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        100000000 samoleans
        99990916 stake
</code></pre>
</li>
<li>
<p>(Optional) Confirm the name of the channels used for the transfer:</p>
<pre><code class="language-shell">hermes query channels --counterparty-chain ibc-1 --chain ibc-0

</code></pre>
<pre><code class="language-json">SUCCESS [
    PortChannelId {
        channel_id: ChannelId(
            "channel-0",
        ),
        port_id: PortId(
            "transfer",
        ),
    },
]
</code></pre>
<pre><code class="language-shell">hermes query channels --counterparty-chain ibc-2 --chain ibc-1

</code></pre>
<pre><code class="language-json">SUCCESS [
    PortChannelId {
        channel_id: ChannelId(
            "channel-1",
        ),
        port_id: PortId(
            "transfer",
        ),
    },
]
</code></pre>
</li>
<li>
<p>In a separate terminal, start an instance of Hermes:</p>
<pre><code class="language-shell">hermes start

</code></pre>
</li>
<li>
<p>Transfer token using the special receiver:</p>
<pre><code class="language-shell">hermes tx ft-transfer --denom samoleans --receiver 'cosmos1jwr34yvnkqkc0ddndnh9y8t94hlhn7rapfyags|transfer/channel-1:cosmos1nsztzzhl553avufxhqa204908l4dndafqph4tw' --timeout-seconds 120 --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-0 --amount 2500

</code></pre>
<pre><code class="language-json">SUCCESS [
    IbcEventWithHeight {
        event: SendPacket(
            SendPacket {
                packet: Packet {
                    sequence: Sequence(
                        2,
                    ),
                    source_port: PortId(
                        "transfer",
                    ),
                    source_channel: ChannelId(
                        "channel-0",
                    ),
                    destination_port: PortId(
                        "transfer",
                    ),
                    destination_channel: ChannelId(
                        "channel-0",
                    ),
                    data: [123, 34, 97, 109, 111, 117, 110, 116, 34, 58, 34, 50, 53, 48, 48, 34, 44, 34, 100, 101, 110, 111, 109, 34, 58, 34, 115, 97, 109, 111, 108, 101, 97, 110, 115, 34, 44, 34, 114, 101, 99, 101, 105, 118, 101, 114, 34, 58, 34, 99, 111, 115, 109, 111, 115, 49, 106, 119, 114, 51, 52, 121, 118, 110, 107, 113, 107, 99, 48, 100, 100, 110, 100, 110, 104, 57, 121, 56, 116, 57, 52, 104, 108, 104, 110, 55, 114, 97, 112, 102, 121, 97, 103, 115, 124, 116, 114, 97, 110, 115, 102, 101, 114, 47, 99, 104, 97, 110, 110, 101, 108, 45, 49, 58, 99, 111, 115, 109, 111, 115, 49, 110, 115, 122, 116, 122, 122, 104, 108, 53, 53, 51, 97, 118, 117, 102, 120, 104, 113, 97, 50, 48, 52, 57, 48, 56, 108, 52, 100, 110, 100, 97, 102, 113, 112, 104, 52, 116, 120, 34, 44, 34, 115, 101, 110, 100, 101, 114, 34, 58, 34, 99, 111, 115, 109, 111, 115, 49, 103, 122, 53, 48, 55, 101, 103, 101, 106, 118, 122, 51, 117, 107, 103, 51, 120, 119, 114, 51, 118, 48, 52, 110, 51, 120, 99, 110, 121, 55, 118, 99, 110, 107, 106, 119, 51, 50, 34, 125],
                    timeout_height: Never,
                    timeout_timestamp: Timestamp {
                        time: Some(
                            Time(
                                2022-11-10 16:05:13.409228,
                            ),
                        ),
                    },
                },
            },
        ),
        height: Height {
            revision: 0,
            height: 59,
        },
    },
]
</code></pre>
</li>
<li>
<p>(Optional) Check the balances:</p>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-0

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        99997500 samoleans
        99985136 stake
</code></pre>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-1

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        100000000 samoleans
        99972551 stake
</code></pre>
<pre><code class="language-shell">hermes keys balance --all --chain ibc-2

</code></pre>
<pre><code class="language-json">SUCCESS Balances for key `wallet`:
        2500 ibc/F47F0D7C9B4F7D971DF647A75A80CB8D905D3230262FEF2996340664D3A12D48
        100000000 samoleans
        99987055 stake
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="misbehaviour"><a class="header" href="#misbehaviour">Misbehaviour</a></h1>
<h2 id="table-of-contents-8"><a class="header" href="#table-of-contents-8">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/misbehaviour/index.html#monitoring-misbehaviour-and-evidence-submission">Monitoring Misbehaviour and Evidence Submission</a></li>
</ul>
<h2 id="monitoring-misbehaviour-and-evidence-submission"><a class="header" href="#monitoring-misbehaviour-and-evidence-submission">Monitoring Misbehaviour and Evidence Submission</a></h2>
<p>Use the <code>misbehaviour</code> command to monitor the updates for a given client, detect certain types of misbehaviour and
submit evidence to the chain. If the evidence passes the on-chain validation, the client is frozen. Further packets
cannot be relayed using the frozen client.</p>
<pre><code class="language-shell">DESCRIPTION:
Listen to client update IBC events and handle misbehaviour

USAGE:
    hermes misbehaviour --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;      Identifier of the chain where client updates are monitored for
                                misbehaviour
        --client &lt;CLIENT_ID&gt;    Identifier of the client to be monitored for misbehaviour
</code></pre>
<p>The misbehaviour monitor starts by analyzing all headers used in prior client updates.
Once finished it registers for update client events and checks any new headers for misbehaviour.
If evidence of misbehaviour is found, it submits:</p>
<ul>
<li>the tendermint evidence to the reference chain</li>
<li>the IBC Misbehaviour message with the evidence to the host chain
If the chain validates the transaction then the monitor exits.</li>
</ul>
<p>The following types of misbehaviour are handled:</p>
<ol>
<li>
<p><strong>Fork</strong></p>
<p>Assumes at least one consensus state before the fork point exists.
Let existing consensus states on chain B be: <code>[Sn,.., Sf, Sf-1, S0]</code> with <code>Sf-1</code> being
the most recent state before the fork.
Chain A is queried for a header <code>Hf'</code> at <code>Sf.height</code> and if it is different from the <code>Hf</code>
in the event for the client update (the one that has generated <code>Sf</code> on chain), then the two
headers are included in the evidence and submitted.
Note that in this case the headers are different but have the same height.</p>
</li>
<li>
<p><strong>BFT time violation for an unavailable header</strong></p>
<p>Some header with a height that is higher than the latest
height on chain <code>A</code> has been accepted and, a consensus state was created on <code>B</code>. Note that this implies
that the timestamp of this header must be within the <code>clock_drift</code> of the client.
Assume the client on <code>B</code> has been updated with <code>h2</code>(not present on/ produced by chain <code>A</code>)
and it has a timestamp of <code>t2</code> that is at most <code>clock_drift</code> in the future.
Then the latest header from <code>A</code> is fetched, let it be <code>h1</code>, with a timestamp of <code>t1</code>.
If <code>t1 &gt;= t2</code> then evidence of misbehavior is submitted to A.</p>
</li>
</ol>
<p><strong>Example</strong></p>
<p>The <code>misbehaviour</code> command outputs an error message displaying <code>MISBEHAVIOUR DETECTED</code>:</p>
<pre><code class="language-shell">hermes misbehaviour --chain ibc-0 --client 07-tendermint-0

</code></pre>
<pre><code class="language-json">Apr 13 20:04:03.347  INFO ibc_relayer::foreign_client: checking misbehaviour for consensus state heights [Height { revision: 1, height: 195 }, Height { revision: 1, height: 85 }, Height { revision: 1, height: 28 }]
Apr 13 20:04:04.425 ERROR ibc_relayer::foreign_client: MISBEHAVIOUR DETECTED ClientId("07-tendermint-0") h1: Height { revision: 1, height: 195 }-Height { revision: 1, height: 85 } h2: Height { revision: 1, height: 195 }-Height { revision: 1, height: 85 }, sending evidence
Apr 13 20:04:05.070  INFO ibc_relayer_cli::commands::misbehaviour: evidence submission result [ClientMisbehaviour(ClientMisbehaviour(Attributes { height: Height { revision: 0, height: 1521 }, client_id: ClientId("07-tendermint-0"), client_type: Tendermint, consensus_height: Height { revision: 1, height: 195 } }))]

Success: Some(
    ClientMisbehaviour(
        ClientMisbehaviour(
            Attributes {
                height: Height {
                    revision: 0,
                    height: 1521,
                },
                client_id: ClientId(
                    "07-tendermint-0",
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 195,
                },
            },
        ),
    ),
)
</code></pre>
<p>Querying client state from this point will show the client is in frozen state, with <code>frozen_height</code> indicating the height at which the client was frozen:</p>
<pre><code class="language-shell">hermes query client state --chain ibc-0 --client 07-tendermint-0
 | jq
</code></pre>
<p>Which should output:</p>
<pre><code class="language-json">{
  "result": {
    "allow_update_after_expiry": true,
    "allow_update_after_misbehaviour": true,
    "chain_id": "ibc-1",
    "frozen_height": {
      "revision_height": 16,
      "revision_number": 1
    },
    "latest_height": {
      "revision_height": 16,
      "revision_number": 1
    },
    "max_clock_drift": {
      "nanos": 0,
      "secs": 3
    },
    "trust_threshold": {
      "denominator": "3",
      "numerator": "1"
    },
    "trusting_period": {
      "nanos": 0,
      "secs": 1209600
    },
    "unbonding_period": {
      "nanos": 0,
      "secs": 1814400
    },
    "upgrade_path": [
      "upgrade",
      "upgradedIBCState"
    ]
  },
  "status": "success"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Hermes supports querying for different objects that exist on a configured chain.</p>
<p>The <code>query</code> command provides the following sub-commands:</p>
<div class="table-wrapper"><table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>client</code></td><td><a href="documentation/commands/queries/./client.html">Query information about clients</a></td></tr>
<tr><td><code>clients</code></td><td><a href="documentation/commands/queries/./client.html">Query all clients</a></td></tr>
<tr><td><code>connection</code></td><td><a href="documentation/commands/queries/./connection.html">Query information about connections</a></td></tr>
<tr><td><code>connections</code></td><td><a href="documentation/commands/queries/./connection.html">Query the identifiers of all connections on a chain</a></td></tr>
<tr><td><code>channel</code></td><td><a href="documentation/commands/queries/./channel.html">Query information about channels</a></td></tr>
<tr><td><code>channels</code></td><td><a href="documentation/commands/queries/./channel.html">Query the identifiers of all channels on a given chain</a></td></tr>
<tr><td><code>packet</code></td><td><a href="documentation/commands/queries/./packet.html">Query information about packets</a></td></tr>
<tr><td><code>transfer</code></td><td><a href="documentation/commands/queries/./transfer.html">Query information about token transfers</a></td></tr>
<tr><td><code>tx</code></td><td><a href="documentation/commands/queries/./tx.html">Query information about transactions</a></td></tr>
</tbody></table>
</div>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code>DESCRIPTION:
Query objects from the chain

USAGE:
    hermes query &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    channel        Query information about channels
    channels       Query the identifiers of all channels on a given chain
    client         Query information about clients
    clients        Query the identifiers of all clients on a chain
    connection     Query information about connections
    connections    Query the identifiers of all connections on a chain
    help           Print this message or the help of the given subcommand(s)
    packet         Query information about packets
    transfer       Query information about token transfers
    tx             Query information about transactions
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents-9"><a class="header" href="#table-of-contents-9">Table of Contents</a></h1>
<ul>
<li><a href="documentation/commands/queries/client.html#query-clients">Query Clients</a></li>
<li><a href="documentation/commands/queries/client.html#query-client-data">Query Client Data</a>
<ul>
<li><a href="documentation/commands/queries/client.html#query-the-client-state">Query the client state</a></li>
<li><a href="documentation/commands/queries/client.html#query-the-client-consensus-state">Query the client consensus state</a></li>
<li><a href="documentation/commands/queries/client.html#query-the-identifiers-of-all-connections-associated-with-a-given-client">Query the identifiers of all connections associated with a given client</a></li>
<li><a href="documentation/commands/queries/client.html#query-for-the-header-used-in-a-client-update-at-a-certain-height">Query for the header used in a client update at a certain height</a></li>
<li><a href="documentation/commands/queries/client.html#query-for-the-status-of-client-active-frozen-or-expired">Query for the status of client (active, frozen, or expired)</a></li>
</ul>
</li>
</ul>
<h1 id="query-clients"><a class="header" href="#query-clients">Query Clients</a></h1>
<p>Use the <code>query clients</code> command to query the identifiers of all clients on a given chain, called
the <em>host</em> chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Query the identifiers of all clients on a chain

USAGE:
    hermes query clients [OPTIONS] --host-chain &lt;HOST_CHAIN_ID&gt;

OPTIONS:
    -h, --help
            Print help information

        --omit-chain-ids
            Omit printing the reference (or target) chain for each client

        --reference-chain &lt;REFERENCE_CHAIN_ID&gt;
            Filter for clients which target a specific chain id (implies '--omit-chain-ids')

REQUIRED:
        --host-chain &lt;HOST_CHAIN_ID&gt;    Identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all clients on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query clients --host-chain ibc-1

</code></pre>
<pre><code class="language-json">Success: [
    ClientChain {
        client_id: ClientId(
            "07-tendermint-0",
        ),
        chain_id: ChainId {
            id: "ibc-0",
            version: 0,
        },
    },
    ClientChain {
        client_id: ClientId(
            "07-tendermint-1",
        ),
        chain_id: ChainId {
            id: "ibc-2",
            version: 2,
        },
    },
]
</code></pre>
<p>Query all clients on <code>ibc-1</code> having <code>ibc-2</code> as their reference chain:</p>
<pre><code class="language-shell">hermes query clients --reference-chain ibc-2 --host-chain ibc-1

</code></pre>
<pre><code class="language-json">Success: [
    ClientId(
        "07-tendermint-1",
    ),
]
</code></pre>
<h1 id="query-client-data"><a class="header" href="#query-client-data">Query Client Data</a></h1>
<p>Use the <code>query client</code> command to query the information about a specific client.</p>
<pre><code class="language-shell">DESCRIPTION:
Query information about clients

USAGE:
    hermes query client &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    connections    Query the client connections
    consensus      Query the client consensus state
    header         Query for the header used in a client update at a certain height
    help           Print this message or the help of the given subcommand(s)
    state          Query the client state
    status         Query the client status (frozen, expired or active)
</code></pre>
<h2 id="query-the-client-state"><a class="header" href="#query-the-client-state">Query the client state</a></h2>
<p>Use the <code>query client state</code> command to query the client state of a client:</p>
<pre><code class="language-shell">DESCRIPTION:
Query the client state

USAGE:
    hermes query client state [OPTIONS] --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

OPTIONS:
    -h, --help               Print help information
        --height &lt;HEIGHT&gt;    The chain height context for the query

REQUIRED:
        --chain &lt;CHAIN_ID&gt;      Identifier of the chain to query
        --client &lt;CLIENT_ID&gt;    Identifier of the client to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the state of client <code>07-tendermint-2</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query client state --chain ibc-1 --client 07-tendermint-1

</code></pre>
<pre><code class="language-json">Success: ClientState {
    chain_id: ChainId {
        id: "ibc-2",
        version: 2,
    },
    trust_threshold: TrustThresholdFraction {
        numerator: 1,
        denominator: 3,
    },
    trusting_period: 1209600s,
    unbonding_period: 1814400s,
    max_clock_drift: 3s,
    frozen_height: Height {
        revision: 0,
        height: 0,
    },
    latest_height: Height {
        revision: 2,
        height: 3069,
    },
    upgrade_path: [
        "upgrade",
        "upgradedIBCState",
    ],
    allow_update_after_expiry: true,
    allow_update_after_misbehaviour: true,
}
</code></pre>
<h2 id="query-the-client-consensus-state"><a class="header" href="#query-the-client-consensus-state">Query the client consensus state</a></h2>
<p>Use the <code>query client consensus</code> command to query the consensus states of a given client, or the state at a specified height:</p>
<pre><code class="language-shell">DESCRIPTION:
Query the client consensus state

USAGE:
    hermes query client consensus [OPTIONS] --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

OPTIONS:
        --consensus-height &lt;CONSENSUS_HEIGHT&gt;
            Height of the client's consensus state to query

    -h, --help
            Print help information

        --height &lt;HEIGHT&gt;
            The chain height context to be used, applicable only to a specific height

REQUIRED:
        --chain &lt;CHAIN_ID&gt;      Identifier of the chain to query
        --client &lt;CLIENT_ID&gt;    Identifier of the client to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the states of client <code>07-tendermint-0</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client consensus --chain ibc-0 --client 07-tendermint-0

</code></pre>
<pre><code class="language-json">Success: [
    Height {
        revision: 1,
        height: 3049,
    },
    Height {
        revision: 1,
        height: 2888,
    },
    Height {
        revision: 1,
        height: 2736,
    },
    Height {
        revision: 1,
        height: 2729,
    },
    Height {
        revision: 1,
        height: 2724,
    },
    Height {
        revision: 1,
        height: 2717,
    },
]
</code></pre>
<p>Query <code>ibc-0</code> at height <code>2800</code> for the consensus state for height <code>2724</code>:</p>
<pre><code class="language-shell">hermes query client consensus --consensus-height 2724 --height 2800 --chain ibc-0 --client 07-tendermint-0

</code></pre>
<pre><code class="language-json">Success: ConsensusState {
    timestamp: Time(
        2021-04-13T14:11:20.969154Z
    ),
    root: CommitmentRoot(
        "371DD19003221B60162D42C78FD86ABF95A572F3D9497084584B75F97B05B70C"
    ),
    next_validators_hash: Hash::Sha256(
        740950668B6705A136D041914FC219045B1D0AD1C6A284C626BF5116005A98A7
    ),
}
</code></pre>
<h2 id="query-the-identifiers-of-all-connections-associated-with-a-given-client"><a class="header" href="#query-the-identifiers-of-all-connections-associated-with-a-given-client">Query the identifiers of all connections associated with a given client</a></h2>
<p>Use the <code>query client connections</code> command to query the connections associated with a given client:</p>
<pre><code class="language-shell">DESCRIPTION:
Query the client connections

USAGE:
    hermes query client connections [OPTIONS] --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

OPTIONS:
    -h, --help               Print help information
        --height &lt;HEIGHT&gt;    The chain height which this query should reflect

REQUIRED:
        --chain &lt;CHAIN_ID&gt;      Identifier of the chain to query
        --client &lt;CLIENT_ID&gt;    Identifier of the client to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the connections of client <code>07-tendermint-0</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client connections --chain ibc-0 --client 07-tendermint-0

</code></pre>
<pre><code class="language-json">Success: [
    ConnectionId("connection-0"),
    ConnectionId("connection-1"),
]
</code></pre>
<h2 id="query-for-the-header-used-in-a-client-update-at-a-certain-height"><a class="header" href="#query-for-the-header-used-in-a-client-update-at-a-certain-height">Query for the header used in a client update at a certain height</a></h2>
<pre><code>DESCRIPTION:
Query for the header used in a client update at a certain height

USAGE:
    hermes query client header [OPTIONS] --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt; --consensus-height &lt;CONSENSUS_HEIGHT&gt;

OPTIONS:
    -h, --help               Print help information
        --height &lt;HEIGHT&gt;    The chain height context for the query. Leave unspecified for latest
                             height.

REQUIRED:
        --chain &lt;CHAIN_ID&gt;                       Identifier of the chain to query
        --client &lt;CLIENT_ID&gt;                     Identifier of the client to query
        --consensus-height &lt;CONSENSUS_HEIGHT&gt;    Height of header to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query for the header used in the <code>07-tendermint-0</code> client update at height 2724 on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client header --chain ibc-0 --client 07-tendermint-0 --consensus-height 2724

</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 0,
                },
                client_id: ClientId(
                    "07-tendermint-0",
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 2724,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
]
</code></pre>
<h2 id="query-for-the-status-of-client-active-frozen-or-expired"><a class="header" href="#query-for-the-status-of-client-active-frozen-or-expired">Query for the status of client (active, frozen, or expired)</a></h2>
<p>This command queries the status of a client, ie. whether it is active, frozen or expired.</p>
<pre><code>DESCRIPTION:
Query the client status (frozen, expired or active)

USAGE:
    hermes query client status --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;      Identifier of the chain to query
        --client &lt;CLIENT_ID&gt;    Identifier of the client to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query for the status of the client <code>07-tendermint-0</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client status --chain ibc-0 --client 07-tendermint-0

</code></pre>
<pre><code>SUCCESS Active
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents-10"><a class="header" href="#table-of-contents-10">Table of Contents</a></h1>
<ul>
<li><a href="documentation/commands/queries/connection.html#query-connections">Query Connections</a></li>
<li><a href="documentation/commands/queries/connection.html#query-connection-data">Query Connection Data</a>
<ul>
<li><a href="documentation/commands/queries/connection.html#query-the-connection-end-data">Query the connection end data</a></li>
<li><a href="documentation/commands/queries/connection.html#query-the-identifiers-of-all-channels-associated-with-a-given-connection">Query the identifiers of all channels associated with a given connection</a></li>
</ul>
</li>
</ul>
<h1 id="query-connections"><a class="header" href="#query-connections">Query Connections</a></h1>
<p>Use the <code>query connections</code> command to query the identifiers of all connections on a given chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Query the identifiers of all connections on a chain

USAGE:
    hermes query connections [OPTIONS] --chain &lt;CHAIN_ID&gt;

OPTIONS:
        --counterparty-chain &lt;COUNTERPARTY_CHAIN_ID&gt;
            Filter the query response by the counterparty chain

    -h, --help
            Print help information

        --verbose
            Enable verbose output, displaying the client for each connection in the response

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all connections on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connections --chain ibc-1

</code></pre>
<pre><code class="language-json">Success: [
    ConnectionId(
        "connection-0",
    ),
    ConnectionId(
        "connection-1",
    ),
]
</code></pre>
<h1 id="query-connection-data"><a class="header" href="#query-connection-data">Query Connection Data</a></h1>
<p>Use the <code>query connection</code> commands to query a specific connection.</p>
<pre><code class="language-shell">DESCRIPTION:
Query information about connections

USAGE:
    hermes query connection &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    channels    Query connection channels
    end         Query connection end
    help        Print this message or the help of the given subcommand(s)
</code></pre>
<h2 id="query-the-connection-end-data"><a class="header" href="#query-the-connection-end-data">Query the connection end data</a></h2>
<p>Use the <code>query connection end</code> command to query the connection end:</p>
<pre><code class="language-shell">DESCRIPTION:
Query connection end

USAGE:
    hermes query connection end [OPTIONS] --chain &lt;CHAIN_ID&gt; --connection &lt;CONNECTION_ID&gt;

OPTIONS:
    -h, --help               Print help information
        --height &lt;HEIGHT&gt;    Height of the state to query. Leave unspecified for latest height.

REQUIRED:
        --chain &lt;CHAIN_ID&gt;              Identifier of the chain to query
        --connection &lt;CONNECTION_ID&gt;    Identifier of the connection to query [aliases: conn]
</code></pre>
<p><strong>Example</strong></p>
<p>Query the connection end of connection <code>connection-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connection end --chain ibc-1 --connection connection-1

</code></pre>
<pre><code class="language-json">Success: ConnectionEnd {
    state: Open,
    client_id: ClientId(
        "07-tendermint-1",
    ),
    counterparty: Counterparty {
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: Some(
            ConnectionId(
                "connection-0",
            ),
        ),
        prefix: ibc,
    },
    versions: [
        Version {
            identifier: "1",
            features: [
                "ORDER_ORDERED",
                "ORDER_UNORDERED",
            ],
        },
    ],
    delay_period: 0s,
}
</code></pre>
<h2 id="query-the-identifiers-of-all-channels-associated-with-a-given-connection"><a class="header" href="#query-the-identifiers-of-all-channels-associated-with-a-given-connection">Query the identifiers of all channels associated with a given connection</a></h2>
<p>Use the <code>query connection channels</code> command to query the identifiers of the channels associated with a given connection:</p>
<pre><code class="language-shell">DESCRIPTION:
Query connection channels

USAGE:
    hermes query connection channels --chain &lt;CHAIN_ID&gt; --connection &lt;CONNECTION_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;              Identifier of the chain to query
        --connection &lt;CONNECTION_ID&gt;    Identifier of the connection to query [aliases: conn]
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channels associated with connection <code>connection-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connection channels --chain ibc-1 --connection connection-1

</code></pre>
<pre><code class="language-json">Success: [
    PortChannelId {
        channel_id: ChannelId(
            "channel-0",
        ),
        port_id: PortId(
            "transfer",
        ),
    },
    PortChannelId {
        channel_id: ChannelId(
            "channel-1",
        ),
        port_id: PortId(
            "transfer",
        ),
    },
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents-11"><a class="header" href="#table-of-contents-11">Table of Contents</a></h1>
<ul>
<li><a href="documentation/commands/queries/channel.html#query-channels">Query Channels</a></li>
<li><a href="documentation/commands/queries/channel.html#query-channel-data">Query Channel Data</a>
<ul>
<li><a href="documentation/commands/queries/channel.html#query-the-channel-end-data">Query the channel end data</a></li>
<li><a href="documentation/commands/queries/channel.html#query-the-channel-data-for-both-ends-of-a-channel">Query the channel data for both ends of a channel</a></li>
<li><a href="documentation/commands/queries/channel.html#query-the-channel-client-state">Query the channel client state</a></li>
</ul>
</li>
</ul>
<h1 id="query-channels"><a class="header" href="#query-channels">Query Channels</a></h1>
<p>Use the <code>query channels</code> command to query the identifiers of all channels on a given chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Query the identifiers of all channels on a given chain

USAGE:
    hermes query channels [OPTIONS] --chain &lt;CHAIN_ID&gt;

OPTIONS:
        --counterparty-chain &lt;COUNTERPARTY_CHAIN_ID&gt;
            Filter the query response by the this counterparty chain

    -h, --help
            Print help information

        --show-counterparty
            Show the counterparty chain, port, and channel

        --verbose
            Enable verbose output, displaying the client and connection ids for each channel in the
            response

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all channels on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query channels --chain ibc-1

</code></pre>
<pre><code class="language-json">Success: [
    PortChannelId {
        channel_id: ChannelId(
            "channel-0",
        ),
        port_id: PortId(
            "transfer",
        ),
    },
    PortChannelId {
        channel_id: ChannelId(
            "channel-1",
        ),
        port_id: PortId(
            "transfer",
        ),
    },
]
</code></pre>
<h1 id="query-channel-data"><a class="header" href="#query-channel-data">Query Channel Data</a></h1>
<p>Use the <code>query channel</code> commands to query the information about a specific channel.</p>
<pre><code class="language-shell">DESCRIPTION:
Query information about channels

USAGE:
    hermes query channel &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    client    Query channel's client state
    end       Query channel end
    ends      Query channel ends and underlying connection and client objects
    help      Print this message or the help of the given subcommand(s)
</code></pre>
<h2 id="query-the-channel-end-data"><a class="header" href="#query-the-channel-end-data">Query the channel end data</a></h2>
<p>Use the <code>query channel end</code> command to query the channel end:</p>
<pre><code class="language-shell">DESCRIPTION:
Query channel end

USAGE:
    hermes query channel end [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

OPTIONS:
    -h, --help               Print help information
        --height &lt;HEIGHT&gt;    Height of the state to query

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channel end of channel <code>channel-1</code> on port <code>transfer</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query channel end --chain ibc-1 --port transfer --channel channel-1

</code></pre>
<pre><code class="language-json">Success: ChannelEnd {
    state: Open,
    ordering: Unordered,
    remote: Counterparty {
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-0",
            ),
        ),
    },
    connection_hops: [
        ConnectionId(
            "connection-1",
        ),
    ],
    version: "ics20-1",
}
</code></pre>
<h2 id="query-the-channel-data-for-both-ends-of-a-channel"><a class="header" href="#query-the-channel-data-for-both-ends-of-a-channel">Query the channel data for both ends of a channel</a></h2>
<p>Use the <code>query channel ends</code> command to obtain both ends of a channel:</p>
<pre><code class="language-shell">DESCRIPTION:
Query channel ends and underlying connection and client objects

USAGE:
    hermes query channel ends [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

OPTIONS:
    -h, --help               Print help information
        --height &lt;HEIGHT&gt;    Height of the state to query
        --verbose            Enable verbose output, displaying all details of channels, connections
                             &amp; clients

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channel end of channel <code>channel-1</code> on port <code>transfer</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query channel ends --chain ibc-0 --port transfer --channel channel-1

</code></pre>
<pre><code class="language-json">Success: ChannelEndsSummary {
    chain_id: ChainId {
        id: "ibc-0",
        version: 0,
    },
    client_id: ClientId(
        "07-tendermint-1",
    ),
    connection_id: ConnectionId(
        "connection-1",
    ),
    channel_id: ChannelId(
        "channel-1",
    ),
    port_id: PortId(
        "transfer",
    ),
    counterparty_chain_id: ChainId {
        id: "ibc-2",
        version: 2,
    },
    counterparty_client_id: ClientId(
        "07-tendermint-1",
    ),
    counterparty_connection_id: ConnectionId(
        "connection-1",
    ),
    counterparty_channel_id: ChannelId(
        "channel-1",
    ),
    counterparty_port_id: PortId(
        "transfer",
    ),
}
</code></pre>
<p>Passing the <code>--verbose</code> flag will additionally print all the details of the
channel, connection, and client on both ends.</p>
<h2 id="query-the-channel-client-state"><a class="header" href="#query-the-channel-client-state">Query the channel client state</a></h2>
<p>Use the <code>query channel client</code> command to obtain the channel's client state:</p>
<pre><code class="language-shell">DESCRIPTION:
Query channel's client state

USAGE:
    hermes query channel client --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
</code></pre>
<p>If the command is successful a message with the following format will be displayed:</p>
<pre><code>Success: Some(
    IdentifiedAnyClientState {
        client_id: ClientId(
            "07-tendermint-0",
        ),
        client_state: Tendermint(
            ClientState {
                chain_id: ChainId {
                    id: "network2",
                    version: 0,
                },
                trust_threshold: TrustThreshold {
                    numerator: 1,
                    denominator: 3,
                },
                trusting_period: 1209600s,
                unbonding_period: 1814400s,
                max_clock_drift: 40s,
                latest_height: Height {
                    revision: 0,
                    height: 2775,
                },
                proof_specs: ProofSpecs(
                    [
                        ProofSpec(
                            ProofSpec {
                                leaf_spec: Some(
                                    LeafOp {
                                        hash: Sha256,
                                        prehash_key: NoHash,
                                        prehash_value: Sha256,
                                        length: VarProto,
                                        prefix: [
                                            0,
                                        ],
                                    },
                                ),
                                inner_spec: Some(
                                    InnerSpec {
                                        child_order: [
                                            0,
                                            1,
                                        ],
                                        child_size: 33,
                                        min_prefix_length: 4,
                                        max_prefix_length: 12,
                                        empty_child: [],
                                        hash: Sha256,
                                    },
                                ),
                                max_depth: 0,
                                min_depth: 0,
                            },
                        ),
                        ProofSpec(
                            ProofSpec {
                                leaf_spec: Some(
                                    LeafOp {
                                        hash: Sha256,
                                        prehash_key: NoHash,
                                        prehash_value: Sha256,
                                        length: VarProto,
                                        prefix: [
                                            0,
                                        ],
                                    },
                                ),
                                inner_spec: Some(
                                    InnerSpec {
                                        child_order: [
                                            0,
                                            1,
                                        ],
                                        child_size: 32,
                                        min_prefix_length: 1,
                                        max_prefix_length: 1,
                                        empty_child: [],
                                        hash: Sha256,
                                    },
                                ),
                                max_depth: 0,
                                min_depth: 0,
                            },
                        ),
                    ],
                ),
                upgrade_path: [
                    "upgrade",
                    "upgradedIBCState",
                ],
                allow_update: AllowUpdate {
                    after_expiry: true,
                    after_misbehaviour: true,
                },
                frozen_height: None,
            },
        ),
    },
)
</code></pre>
<p><strong>JSON output:</strong></p>
<pre><code class="language-shell">hermes  --json query channel client --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

</code></pre>
<p>If the command is successful a message with the following format will be displayed:</p>
<pre><code class="language-json">{
    "result":
    {
        "client_id":"07-tendermint-0",
        "client_state":
        {
            "allow_update":
            {
                "after_expiry":true,
                "after_misbehaviour":true
            },
            "chain_id":"network2",
            "frozen_height":null,
            "latest_height":
            {
                "revision_height":2775,
                "revision_number":0
            },
            "max_clock_drift":
            {
                "nanos":0,
                "secs":40
            },
            "proof_specs":
            [
                {
                    "inner_spec":
                    {
                        "child_order":[0,1],
                        "child_size":33,
                        "empty_child":"",
                        "hash":1,
                        "max_prefix_length":12,
                        "min_prefix_length":4
                    },
                    "leaf_spec":
                    {
                        "hash":1,
                        "length":1,
                        "prefix":"AA==",
                        "prehash_key":0,
                        "prehash_value":1
                    },
                    "max_depth":0,
                    "min_depth":0
                },
                {
                    "inner_spec":
                    {
                        "child_order":[0,1],
                        "child_size":32,
                        "empty_child":"",
                        "hash":1,
                        "max_prefix_length":1,
                        "min_prefix_length":1
                    },
                    "leaf_spec":
                    {
                        "hash":1,
                        "length":1,
                        "prefix":"AA==",
                        "prehash_key":0,
                        "prehash_value":1
                    },
                    "max_depth":0,
                    "min_depth":0
                }
            ],
            "trust_threshold":
            {
                "denominator":3,
                "numerator":1
            },
            "trusting_period":
            {
                "nanos":0,
                "secs":1209600
            },
            "type":"Tendermint",
            "unbonding_period":
            {
                "nanos":0,
                "secs":1814400
            },
            "upgrade_path":["upgrade","upgradedIBCState"]
        },
        "type":"IdentifiedAnyClientState"
    },
    "status":"success"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-queries"><a class="header" href="#packet-queries">Packet Queries</a></h1>
<p>Use the <code>query packet</code> commands to query information about packets.</p>
<pre><code class="language-shell">DESCRIPTION:
Query information about packets

USAGE:
    hermes query packet &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    ack              Query packet acknowledgment
    acks             Query packet acknowledgments
    commitment       Query packet commitment
    commitments      Query packet commitments
    help             Print this message or the help of the given subcommand(s)
    pending          Output a summary of pending packets in both directions
    pending-acks     Query pending acknowledgments
    pending-sends    Query pending send packets
</code></pre>
<h2 id="table-of-contents-12"><a class="header" href="#table-of-contents-12">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/queries/packet.html#pending-packets">Pending Packets</a></li>
<li><a href="documentation/commands/queries/packet.html#packet-commitments">Packet Commitments</a></li>
<li><a href="documentation/commands/queries/packet.html#packet-commitment-with-sequence">Packet Commitment with Sequence</a></li>
<li><a href="documentation/commands/queries/packet.html#packet-acknowledgments">Packet Acknowledgments</a></li>
<li><a href="documentation/commands/queries/packet.html#packet-acknowledgment-with-sequence">Packet Acknowledgment with Sequence</a></li>
<li><a href="documentation/commands/queries/packet.html#unreceived-packets">Unreceived Packets</a></li>
<li><a href="documentation/commands/queries/packet.html#unreceived-acknowledgments">Unreceived Acknowledgments</a></li>
</ul>
<h2 id="pending-packets"><a class="header" href="#pending-packets">Pending Packets</a></h2>
<p>Use the <code>query packet pending</code> command to query the sequence numbers of all packets that have not yet been received or acknowledged, at both ends of a channel.</p>
<pre><code class="language-shell">DESCRIPTION:
Output a summary of pending packets in both directions

USAGE:
    hermes query packet pending --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain at one end of the channel
        --channel &lt;CHANNEL_ID&gt;    Channel identifier on the chain given by &lt;CHAIN_ID&gt; [aliases:
                                  chan]
        --port &lt;PORT_ID&gt;          Port identifier on the chain given by &lt;CHAIN_ID&gt;
</code></pre>
<p><strong>Example</strong></p>
<p>Query the sequence numbers of all packets that either not yet been received or not yet been acknowledged, at both ends of the channel <code>channel-1</code>.</p>
<pre><code class="language-shell">hermes query packet pending --chain ibc-0 --port transfer --channel channel-1

</code></pre>
<pre><code class="language-json">Success: Summary {
    forward: PendingPackets {
        unreceived_packets: [
            2203,
            ...
            2212,
        ],
        unreceived_acks: [
           2183,
           ...
           2202,
        ],
    },
    reverse: PendingPackets {
        unreceived_packets: [
           14,
           ...
           23,
        ],
        unreceived_acks: [
           4,
           ...
           13,
        ],
    },
}
</code></pre>
<h2 id="packet-commitments"><a class="header" href="#packet-commitments">Packet Commitments</a></h2>
<p>Use the <code>query packet commitments</code> command to query the sequence numbers of all packets that have been sent but not yet acknowledged (these are the packets that still have their commitments stored).</p>
<pre><code class="language-shell">DESCRIPTION:
Query packet commitments

USAGE:
    hermes query packet commitments [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

OPTIONS:
    -h, --help               Print help information
        --height &lt;HEIGHT&gt;    Height of the state to query. Leave unspecified for latest height.

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the sequence numbers of packets that still have commitments on <code>ibc-0</code> and that were sent on <code>transfer</code> port and <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes query packet commitments --chain ibc-0 --port transfer --channel channel-0

</code></pre>
<pre><code class="language-json">Success: PacketSeqs {
    height: Height {
        revision: 0,
        height: 9154,
    },
    seqs: [
        1,
        2,
        3
    ],
}
</code></pre>
<h2 id="packet-commitment-with-sequence"><a class="header" href="#packet-commitment-with-sequence">Packet Commitment with Sequence</a></h2>
<p>Use the <code>query packet commitment</code> command to query the commitment value of a packet with a given sequence number.</p>
<pre><code class="language-shell">DESCRIPTION:
Query packet commitment

USAGE:
    hermes query packet commitment [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt; --sequence &lt;SEQUENCE&gt;

OPTIONS:
    -h, --help               Print help information
        --height &lt;HEIGHT&gt;    Height of the state to query. Leave unspecified for latest height.

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
        --sequence &lt;SEQUENCE&gt;     Sequence of packet to query [aliases: seq]
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the commitment of packet with sequence <code>3</code> sent on <code>transfer</code> port and <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes query packet commitment --chain ibc-0 --port transfer --channel channel-0 --sequence 3

</code></pre>
<pre><code class="language-json">Success: "F9458DC7EBEBCD6D18E983FCAB5BD752CC2A74532BBD50B812DB229997739EFC"
</code></pre>
<h2 id="packet-acknowledgments"><a class="header" href="#packet-acknowledgments">Packet Acknowledgments</a></h2>
<p>Use the <code>query packet acks</code> command to query the sequence numbers of all packets that have been acknowledged.</p>
<pre><code class="language-shell">DESCRIPTION:
Query packet acknowledgments

USAGE:
    hermes query packet acks --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the sequence numbers of packets acknowledged that were received on <code>transfer</code> port and <code>channel-1</code>:</p>
<pre><code class="language-shell">hermes query packet acks --chain ibc-1 --port transfer --channel channel-1

</code></pre>
<pre><code class="language-json">Success: PacketSeqs {
    height: Height {
        revision: 1,
        height: 9547,
    },
    seqs: [
        1,
        2,
        3
    ],
}
</code></pre>
<h2 id="packet-acknowledgment-with-sequence"><a class="header" href="#packet-acknowledgment-with-sequence">Packet Acknowledgment with Sequence</a></h2>
<p>Use the <code>query packet acknowledgment</code> command to query the acknowledgment value of a packet with a given sequence number.</p>
<pre><code class="language-shell">DESCRIPTION:
Query packet acknowledgment

USAGE:
    hermes query packet ack [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt; --sequence &lt;SEQUENCE&gt;

OPTIONS:
    -h, --help               Print help information
        --height &lt;HEIGHT&gt;    Height of the state to query. Leave unspecified for latest height.

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
        --sequence &lt;SEQUENCE&gt;     Sequence of packet to query [aliases: seq]
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the acknowledgment of packet with sequence <code>2</code> received on <code>transfer</code> port and <code>channel-1</code>:</p>
<pre><code class="language-shell">hermes query packet ack --chain ibc-1 --port transfer --channel channel-1 --sequence 2

</code></pre>
<pre><code class="language-json">Success: "08F7557ED51826FE18D84512BF24EC75001EDBAF2123A477DF72A0A9F3640A7C"
</code></pre>
<h2 id="unreceived-packets"><a class="header" href="#unreceived-packets">Unreceived Packets</a></h2>
<p>Use the <code>query packet pending-sends</code> command to query the sequence numbers of all packets that have been sent on the source chain but not yet received on the destination chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Query pending send packets

USAGE:
    hermes query packet pending-sends --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain for the unreceived sequences
        --channel &lt;CHANNEL_ID&gt;    Channel identifier [aliases: chan]
        --port &lt;PORT_ID&gt;          Port identifier
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>transfer</code> port and <code>channel-1</code> on <code>ibc-1</code> for the sequence numbers of packets sent on <code>ibc-0</code> but not yet received:</p>
<pre><code class="language-shell">hermes query packet pending-sends --chain ibc-1 --port transfer --channel channel-1

</code></pre>
<pre><code class="language-json">Success: [
    1,
    2,
    3
]
</code></pre>
<h2 id="unreceived-acknowledgments"><a class="header" href="#unreceived-acknowledgments">Unreceived Acknowledgments</a></h2>
<p>Use the <code>query packet pending-acks</code> command to query the sequence numbers of all packets that have not yet been acknowledged.</p>
<pre><code class="language-shell">DESCRIPTION:
Query pending acknowledgments

USAGE:
    hermes query packet pending-acks --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query the unreceived acknowledgments
        --channel &lt;CHANNEL_ID&gt;    Channel identifier [aliases: chan]
        --port &lt;PORT_ID&gt;          Port identifier
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>transfer</code> port and <code>channel-0</code> on <code>ibc-0</code> for the sequence numbers of packets received by <code>ibc-1</code> but not yet acknowledged on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query packet pending-acks --chain ibc-0 --port transfer --channel channel-0

</code></pre>
<pre><code class="language-json">Success: [
    1,
    2,
    3
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tx-queries"><a class="header" href="#tx-queries">Tx Queries</a></h1>
<p>Use the <code>query tx</code> command to query information about transaction(s).</p>
<pre><code class="language-shell">DESCRIPTION:
Query information about transactions

USAGE:
    hermes query tx &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    events    Query the events emitted by transaction
    help      Print this message or the help of the given subcommand(s)
</code></pre>
<h2 id="table-of-contents-13"><a class="header" href="#table-of-contents-13">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/queries/tx.html#transaction-events">Transaction Events</a></li>
</ul>
<h2 id="transaction-events"><a class="header" href="#transaction-events">Transaction Events</a></h2>
<p>Use the <code>query tx events</code> command to obtain a list of events that a chain generated as a consequence of
delivering a transaction.</p>
<pre><code class="language-shell">DESCRIPTION:
Query the events emitted by transaction

USAGE:
    hermes query tx events --chain &lt;CHAIN_ID&gt; --hash &lt;HASH&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain to query
        --hash &lt;HASH&gt;         Transaction hash to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query chain <code>ibc-0</code> for the events emitted due to transaction with hash
<code>6EDBBCBCB779F9FC9D6884ACDC4350E69720C4B362E4ACE6C576DE792F837490</code>:</p>
<pre><code class="language-shell">hermes query tx events --chain ibc-0 --hash 6EDBBCBCB779F9FC9D6884ACDC4350E69720C4B362E4ACE6C576DE792F837490

</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 4,
                height: 6628239,
            },
            packet: PortId("transfer") ChannelId("channel-139") Sequence(2),
        },
    ),
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer-queries"><a class="header" href="#transfer-queries">Transfer Queries</a></h1>
<p>Use the <code>query transfer</code> command to query information about transfer(s).</p>
<pre><code class="language-shell">DESCRIPTION:
Query information about token transfers

USAGE:
    hermes query transfer &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    denom-trace    Query the denomination trace info from a trace hash
    help           Print this message or the help of the given subcommand(s)
</code></pre>
<h2 id="table-of-contents-14"><a class="header" href="#table-of-contents-14">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/queries/transfer.html#denomination-trace">Denomination Trace</a></li>
</ul>
<h2 id="denomination-trace"><a class="header" href="#denomination-trace">Denomination Trace</a></h2>
<p>Use the <code>query transfer denom-trace</code> command to obtain the path and base denomination of a given trace hash.</p>
<pre><code class="language-shell">DESCRIPTION:
Query the denomination trace info from a trace hash

USAGE:
    hermes query transfer denom-trace --chain &lt;CHAIN_ID&gt; --hash &lt;HASH&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain
        --hash &lt;HASH&gt;         Trace hash to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query chain <code>ibc-1</code> for the path and base denomination of the trace hash <code>27A6394C3F9FF9C9DCF5DFFADF9BB5FE9A37C7E92B006199894CF1824DF9AC7C</code>:</p>
<pre><code class="language-shell">hermes query transfer denom-trace --chain ibc-1 --hash 27A6394C3F9FF9C9DCF5DFFADF9BB5FE9A37C7E92B006199894CF1824DF9AC7C

</code></pre>
<pre><code class="language-shell">Success: base_denom: samoleans
 path: transfer/channel-0
</code></pre>
<p>Or with a JSON output:</p>
<pre><code class="language-shell">hermes  --json query transfer denom-trace --chain ibc-1 --hash 27A6394C3F9FF9C9DCF5DFFADF9BB5FE9A37C7E92B006199894CF1824DF9AC7C

</code></pre>
<pre><code class="language-json">{
    "result":{
        "base_denom":"samoleans",
        "path":"transfer/channel-0"
    },
    "status":"success"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p>There are a number of simple commands that perform minimal validation, build and send IBC transactions.</p>
<p>The <code>tx</code> command provides the following sub-commands:</p>
<div class="table-wrapper"><table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>conn-init</code></td><td><a href="documentation/commands/tx/./connection.html#connection-init">Initialize a connection (ConnectionOpenInit)</a></td></tr>
<tr><td><code>conn-try</code></td><td><a href="documentation/commands/tx/./connection.html#connection-try">Relay the connection attempt (ConnectionOpenTry)</a></td></tr>
<tr><td><code>conn-ack</code></td><td><a href="documentation/commands/tx/./connection.html#connection-ack">Relay acknowledgment of a connection attempt (ConnectionOpenAck)</a></td></tr>
<tr><td><code>conn-confirm</code></td><td><a href="documentation/commands/tx/./connection.html#connection-confirm">Confirm opening of a connection (ConnectionOpenConfirm)</a></td></tr>
<tr><td><code>chan-open-init</code></td><td><a href="documentation/commands/tx/./channel-open.html#channel-open-init">Initialize a channel (ChannelOpenInit)</a></td></tr>
<tr><td><code>chan-open-try</code></td><td><a href="documentation/commands/tx/./channel-open.html#channel-open-try">Relay the channel attempt (ChannelOpenTry)</a></td></tr>
<tr><td><code>chan-open-ack</code></td><td><a href="documentation/commands/tx/./channel-open.html#channel-open-ack">Relay acknowledgment of a channel attempt (ChannelOpenAck)</a></td></tr>
<tr><td><code>chan-open-confirm</code></td><td><a href="documentation/commands/tx/./channel-open.html#channel-open-close">Confirm opening of a channel (ChannelOpenConfirm)</a></td></tr>
<tr><td><code>chan-close-init</code></td><td><a href="documentation/commands/tx/./channel-close.html#channel-close-init">Initiate the closing of a channel (ChannelCloseInit)</a></td></tr>
<tr><td><code>chan-close-confirm</code></td><td><a href="documentation/commands/tx/./channel-close.html#channel-close-confirm">Confirm the closing of a channel (ChannelCloseConfirm)</a></td></tr>
<tr><td><code>ft-transfer</code></td><td><a href="documentation/commands/tx/./packet.html#fungible-token-transfer">Send a fungible token transfer test transaction (ICS20 MsgTransfer)</a></td></tr>
<tr><td><code>packet-recv</code></td><td><a href="documentation/commands/tx/./packet.html#relay-receive-and-timeout-packets">Relay receive or timeout packets</a></td></tr>
<tr><td><code>packet-ack</code></td><td><a href="documentation/commands/tx/./packet.html#relay-acknowledgment-packets">Relay acknowledgment packets</a></td></tr>
<tr><td><code>upgrade-chain</code></td><td><a href="documentation/commands/tx/./upgrade.html">Send an IBC upgrade plan</a></td></tr>
</tbody></table>
</div>
<p>The main purpose of these commands is to support development and testing, and continuous integration. These CLIs take quite a few parameters, and they are explained in the individual subsections.</p>
<p>At a high level, most commands follow this template:</p>
<pre><code class="language-shell">hermes tx &lt;IBC-MESSAGE&gt; --dst-chain-id &lt;CHAIN-ID&gt; --src-chain-id &lt;CHAIN-id&gt; --dst-obj-id &lt;OBJ-ID&gt; --src-obj-id &lt;SRC-OBJ-ID&gt;
</code></pre>
<p>In the command template above:</p>
<ul>
<li>
<p><code>ibc-message</code> - identifies the "main" IBC message that is being sent, e.g. <code>conn-init</code>, <code>conn-try</code>, <code>chan-open-init</code>, etc. To ensure successful processing on the receiving chain, the majority of these commands build and send two messages: one <code>UpdateClient</code> message followed by the actual IBC message. These two messages are included in a single transaction. This is done for all IBC messages that include proofs collected from the source chain.</p>
<p>The messages that do not require proofs are:</p>
<ul>
<li><code>MsgConnectionOpenInit</code> (<code>conn-open-init</code> command),</li>
<li><code>MsgChannelOpenInit</code> (<code>chan-open-init</code> command),</li>
<li><code>MsgChannelCloseInit</code> (<code>chan-close-init</code> command) and</li>
<li><code>MsgTransfer</code> (<code>ft-transfer</code> command)</li>
</ul>
</li>
<li>
<p><code>dst-chain-id</code> - is the identifier of the chain where the transaction will be sent.</p>
</li>
<li>
<p><code>src-chain-id</code> - is the identifier of the chain that is queried for the data that is included in the transaction, e.g. connection data, client proofs, etc. To ensure correct on-chain state, the relayer also queries the destination chain, however it does not include this information in the Tx to the destination chain.</p>
</li>
<li>
<p><code>dst-obj-id</code> - the identifier of an object on destination chain required by the message, e.g. the <code>client-id</code> associated with the connection on destination chain in connection messages. Or the <code>connection-id</code> in a <code>ConnOpenAck</code> message.</p>
</li>
<li>
<p><code>src-obj-id</code> - the identifier of an object on the source chain, required by the message, e.d. the <code>client-id</code> of the connection on source chain.</p>
</li>
<li>
<p>More details about the <code>tx</code> commands can be found in the following sections:</p>
<ul>
<li><a href="documentation/commands/tx/./connection.html">Connection</a></li>
<li><a href="documentation/commands/tx/./channel-open.html">Channel Open</a></li>
<li><a href="documentation/commands/tx/./channel-close.html">Channel Close</a></li>
<li><a href="documentation/commands/tx/./packet.html">Packet</a></li>
<li><a href="documentation/commands/tx/./upgrade.html">Upgrade</a></li>
</ul>
</li>
</ul>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><code class="language-shell">DESCRIPTION:
Create and send IBC transactions

USAGE:
    hermes tx &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    chan-close-confirm      Confirm the closing of a channel (ChannelCloseConfirm)
    chan-close-init         Initiate the closing of a channel (ChannelCloseInit)
    chan-open-ack           Relay acknowledgment of a channel attempt (ChannelOpenAck)
    chan-open-confirm       Confirm opening of a channel (ChannelOpenConfirm)
    chan-open-init          Initialize a channel (ChannelOpenInit)
    chan-open-try           Relay the channel attempt (ChannelOpenTry)
    chan-upgrade-ack        Relay the channel upgrade attempt (ChannelUpgradeAck)
    chan-upgrade-cancel     Relay the channel upgrade cancellation (ChannelUpgradeCancel)
    chan-upgrade-confirm    Relay the channel upgrade attempt (ChannelUpgradeConfirm)
    chan-upgrade-open       Relay the channel upgrade attempt (ChannelUpgradeOpen)
    chan-upgrade-timeout    Relay the channel upgrade timeout (ChannelUpgradeTimeout)
    chan-upgrade-try        Relay the channel upgrade attempt (ChannelUpgradeTry)
    conn-ack                Relay acknowledgment of a connection attempt (ConnectionOpenAck)
    conn-confirm            Confirm opening of a connection (ConnectionOpenConfirm)
    conn-init               Initialize a connection (ConnectionOpenInit)
    conn-try                Relay the connection attempt (ConnectionOpenTry)
    ft-transfer             Send a fungible token transfer test transaction (ICS20 MsgTransfer)
    help                    Print this message or the help of the given subcommand(s)
    packet-ack              Relay acknowledgment packets
    packet-recv             Relay receive or timeout packets
    upgrade-chain           Send an IBC upgrade plan

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection-handshake"><a class="header" href="#connection-handshake">Connection Handshake</a></h1>
<p>The <code>tx</code> commands can be used to establish a connection between two clients.</p>
<center>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant A as ibc-1
    participant B as ibc-0
    Note over A, B: No connection
    A-&gt;&gt;B: ConnectionOpenInit
    Note over B: connection: connection-0
    Note over B: counterparty: none
    B-&gt;&gt;A: ConnectionOpenTry
    Note over A: connection: connection-1
    Note over A: counterparty: connection-0
    A-&gt;&gt;B: ConnectionOpenAck
    note over B: connection: connection-0
    note over B: counterparty: connection-1
    B-&gt;&gt;A: ConnectionOpenConfirm
    Note over A, B: Connection open
</pre>
</center>
<h2 id="table-of-contents-15"><a class="header" href="#table-of-contents-15">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/tx/connection.html#connection-init">Connection Init</a></li>
<li><a href="documentation/commands/tx/connection.html#connection-try">Connection Try</a></li>
<li><a href="documentation/commands/tx/connection.html#connection-ack">Connection Ack</a></li>
<li><a href="documentation/commands/tx/connection.html#connection-confirm">Connection Confirm</a></li>
</ul>
<h2 id="connection-init"><a class="header" href="#connection-init">Connection Init</a></h2>
<p>Use the <code>conn-init</code> command to initialize a new connection on a chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Initialize a connection (ConnectionOpenInit)

USAGE:
    hermes tx conn-init --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-client &lt;DST_CLIENT_ID&gt; --src-client &lt;SRC_CLIENT_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;      Identifier of the destination chain
        --dst-client &lt;DST_CLIENT_ID&gt;    Identifier of the destination client
        --src-chain &lt;SRC_CHAIN_ID&gt;      Identifier of the source chain
        --src-client &lt;SRC_CLIENT_ID&gt;    Identifier of the source client
</code></pre>
<p><strong>Example</strong></p>
<p>Given that two clients were previously created with identifier <code>07-tendermint-0</code> on chain <code>ibc-0</code> and
identifier <code>07-tendermint-1</code> on chain <code>ibc-1</code>, we can initialize a connection between the two clients.</p>
<p>First, let's initialize the connection on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx conn-init --dst-chain ibc-0 --src-chain ibc-1 --dst-client 07-tendermint-0 --src-client 07-tendermint-1

</code></pre>
<pre><code class="language-json">Success: OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 73,
            },
            connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-0",
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                "07-tendermint-1",
            ),
        },
    ),
)
</code></pre>
<p>A new connection has been initialized on <code>ibc-0</code> with identifier <code>connection-0</code>.</p>
<blockquote>
<p>Note that the <code>counterparty_connection_id</code> field is currently empty.</p>
</blockquote>
<h2 id="connection-try"><a class="header" href="#connection-try">Connection Try</a></h2>
<p>Use the <code>conn-try</code> command to establish a counterparty to the connection on the other chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Relay the connection attempt (ConnectionOpenTry)

USAGE:
    hermes tx conn-try [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-client &lt;DST_CLIENT_ID&gt; --src-client &lt;SRC_CLIENT_ID&gt; --src-connection &lt;SRC_CONNECTION_ID&gt;

OPTIONS:
        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection (optional) [aliases: dst-conn]

    -h, --help
            Print help information

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-client &lt;DST_CLIENT_ID&gt;
            Identifier of the destination client

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-client &lt;SRC_CLIENT_ID&gt;
            Identifier of the source client

        --src-connection &lt;SRC_CONNECTION_ID&gt;
            Identifier of the source connection (required) [aliases: src-conn]
</code></pre>
<p><strong>Example</strong></p>
<p>Let's now create the counterparty to <code>connection-0</code> on chain <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx conn-try --dst-chain ibc-1 --src-chain ibc-0 --dst-client 07-tendermint-1 --src-client 07-tendermint-0 --src-connection connection-0

</code></pre>
<pre><code class="language-json">Success: OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height {
                revision: 1,
                height: 88,
            },
            connection_id: Some(
                ConnectionId(
                    "connection-1",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-1",
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            counterparty_client_id: ClientId(
                "07-tendermint-0",
            ),
        },
    ),
)
</code></pre>
<p>A new connection has been created on <code>ibc-1</code> with identifier <code>connection-1</code>.</p>
<blockquote>
<p>Note that the field <code>counterparty_connection_id</code> points to the connection on <code>ibc-0</code>.</p>
</blockquote>
<h2 id="connection-ack"><a class="header" href="#connection-ack">Connection Ack</a></h2>
<p>Use the <code>conn-ack</code> command to acknowledge the connection on the initial chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Relay acknowledgment of a connection attempt (ConnectionOpenAck)

USAGE:
    hermes tx conn-ack --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-client &lt;DST_CLIENT_ID&gt; --src-client &lt;SRC_CLIENT_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --src-connection &lt;SRC_CONNECTION_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-client &lt;DST_CLIENT_ID&gt;
            Identifier of the destination client

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection (required) [aliases: dst-conn]

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-client &lt;SRC_CLIENT_ID&gt;
            Identifier of the source client

        --src-connection &lt;SRC_CONNECTION_ID&gt;
            Identifier of the source connection (required) [aliases: src-conn]
</code></pre>
<p><strong>Example</strong></p>
<p>We can now acknowledge on <code>ibc-0</code> that <code>ibc-1</code> has accepted the connection attempt:</p>
<pre><code class="language-shell">hermes tx conn-ack --dst-chain ibc-0 --src-chain ibc-1 --dst-client 07-tendermint-0 --src-client 07-tendermint-1 --dst-connection connection-0 --src-connection connection-1

</code></pre>
<pre><code class="language-json">Success: OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height {
                revision: 0,
                height: 206,
            },
            connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-0",
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    "connection-1",
                ),
            ),
            counterparty_client_id: ClientId(
                "07-tendermint-1",
            ),
        },
    ),
)
</code></pre>
<blockquote>
<p>Note that the field <code>counterparty_connection_id</code> now points to the connection on <code>ibc-1</code>.</p>
</blockquote>
<h2 id="connection-confirm"><a class="header" href="#connection-confirm">Connection Confirm</a></h2>
<p>Use the <code>conn-confirm</code> command to confirm that the connection has been acknowledged,
and finish the handshake, after which the connection is open on both chains.</p>
<pre><code class="language-shell">DESCRIPTION:
Confirm opening of a connection (ConnectionOpenConfirm)

USAGE:
    hermes tx conn-confirm --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-client &lt;DST_CLIENT_ID&gt; --src-client &lt;SRC_CLIENT_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --src-connection &lt;SRC_CONNECTION_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-client &lt;DST_CLIENT_ID&gt;
            Identifier of the destination client

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection (required) [aliases: dst-conn]

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-client &lt;SRC_CLIENT_ID&gt;
            Identifier of the source client

        --src-connection &lt;SRC_CONNECTION_ID&gt;
            Identifier of the source connection (required) [aliases: src-conn]
</code></pre>
<p><strong>Example</strong></p>
<p>Confirm on <code>ibc-1</code> that <code>ibc-0</code> has accepted the connection attempt.</p>
<pre><code class="language-shell">hermes tx conn-confirm --dst-chain ibc-1 --src-chain ibc-0 --dst-client 07-tendermint-1 --src-client 07-tendermint-0 --dst-connection connection-1 --src-connection connection-0

</code></pre>
<pre><code class="language-json">Success: OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 239,
            },
            connection_id: Some(
                ConnectionId(
                    "connection-1",
                ),
            ),
            client_id: ClientId(
                "07-tendermint-1",
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    "connection-0",
                ),
            ),
            counterparty_client_id: ClientId(
                "07-tendermint-0",
            ),
        },
    ),
)
</code></pre>
<p>We have now successfully established a connection between the two chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel-open-handshake"><a class="header" href="#channel-open-handshake">Channel Open Handshake</a></h1>
<p>The <code>tx</code> commands can be used to establish a channel for a given connection. Only <code>unordered</code> channels are currently supported.</p>
<center>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant A as ibc-1
    participant B as ibc-0
    Note over A, B: No channel
    A-&gt;&gt;B: ChannelOpenInit
    Note over B: channel: channel-0
    Note over B: channel: counterparty: none
    B-&gt;&gt;A: ChannelOpenTry
    Note over A: channel: channel-1
    Note over A: channel: counterparty: channel-0
    A-&gt;&gt;B: ChannelOpenAck
    note over B: channel: channel-0
    note over B: counterparty: channel-1
    B-&gt;&gt;A: ChannelOpenConfirm
    Note over A, B: Channel open
</pre>
</center>
<h2 id="table-of-contents-16"><a class="header" href="#table-of-contents-16">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/tx/channel-open.html#channel-open-init">Channel Open Init</a></li>
<li><a href="documentation/commands/tx/channel-open.html#channel-open-try">Channel Open Try</a></li>
<li><a href="documentation/commands/tx/channel-open.html#channel-open-ack">Channel Open Ack</a></li>
<li><a href="documentation/commands/tx/channel-open.html#channel-open-confirm">Channel Open Confirm</a></li>
</ul>
<h2 id="channel-open-init"><a class="header" href="#channel-open-init">Channel Open Init</a></h2>
<p>Use the <code>chan-open-init</code> command to initialize a new channel.</p>
<pre><code class="language-shell">DESCRIPTION:
Initialize a channel (ChannelOpenInit)

USAGE:
    hermes tx chan-open-init [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt;

OPTIONS:
    -h, --help             Print help information
        --order &lt;ORDER&gt;    The channel ordering, valid options 'unordered' (default) and 'ordered'
                           [default: ORDER_UNORDERED]

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>First, let's initialize the channel on <code>ibc-0</code> using an existing connection identified by <code>connection-0</code>:</p>
<pre><code class="language-shell">hermes tx chan-open-init --dst-chain ibc-0 --src-chain ibc-1 --dst-connection connection-0 --dst-port transfer --src-port transfer

</code></pre>
<pre><code class="language-json">Success: OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 3091
            },
            port_id: PortId(
                "transfer",
            ),
            channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
            connection_id: ConnectionId(
                "connection-0",
            ),
            counterparty_port_id: PortId(
                "transfer",
            ),
            counterparty_channel_id: None,
        },
    ),
)
</code></pre>
<p>A new channel has been initialized on <code>ibc-1</code> with identifier <code>channel-0</code>.</p>
<blockquote>
<p>Note that the <code>counterparty_channel_id</code> field is currently empty.</p>
</blockquote>
<h2 id="channel-open-try"><a class="header" href="#channel-open-try">Channel Open Try</a></h2>
<p>Use the <code>chan-open-try</code> command to establish a counterparty to the channel on the other chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Relay the channel attempt (ChannelOpenTry)

USAGE:
    hermes tx chan-open-try [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

OPTIONS:
        --dst-channel &lt;DST_CHANNEL_ID&gt;
            Identifier of the destination channel (optional) [aliases: dst-chan]

    -h, --help
            Print help information

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel (required) [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>Let's now create the counterparty to <code>channel-0</code> on chain <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx chan-open-try --dst-chain ibc-1 --src-chain ibc-0 --dst-connection connection-1 --dst-port transfer --src-port transfer --src-channel channel-0

</code></pre>
<pre><code class="language-json">Success: OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height {
                revision: 1,
                height: 3213
            },
            port_id: PortId(
                "transfer",
            ),
            channel_id: Some(
                ChannelId(
                    "channel-1",
                ),
            ),
            connection_id: ConnectionId(
                "connection-1",
            ),
            counterparty_port_id: PortId(
                "transfer",
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
        },
    ),
)
</code></pre>
<p>A new channel has been created on <code>ibc-1</code> with identifier <code>channel-1</code>.</p>
<blockquote>
<p>Note that the field <code>counterparty_channel_id</code> points to the channel on <code>ibc-0</code>.</p>
</blockquote>
<h2 id="channel-open-ack"><a class="header" href="#channel-open-ack">Channel Open Ack</a></h2>
<p>Use the <code>chan-open-ack</code> command to acknowledge the channel on the initial chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Relay acknowledgment of a channel attempt (ChannelOpenAck)

USAGE:
    hermes tx chan-open-ack --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --dst-channel &lt;DST_CHANNEL_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-channel &lt;DST_CHANNEL_ID&gt;
            Identifier of the destination channel (required) [aliases: dst-chan]

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel (required) [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>We can now acknowledge on <code>ibc-0</code> that <code>ibc-1</code> has accepted the opening of the channel:</p>
<pre><code class="language-shell">hermes tx chan-open-ack --dst-chain ibc-0 --src-chain ibc-1 --dst-connection connection-0 --dst-port transfer --src-port transfer --dst-channel channel-0 --src-channel channel-1

</code></pre>
<pre><code class="language-json">Success: OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height {
                revision: 0,
                height: 3301
            },
            port_id: PortId(
                "transfer",
            ),
            channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
            connection_id: ConnectionId(
                "connection-0",
            ),
            counterparty_port_id: PortId(
                "transfer",
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    "channel-1",
                ),
            ),
        },
    ),
)
</code></pre>
<blockquote>
<p>Note that the field <code>counterparty_channel_id</code> now points to the channel on <code>ibc-1</code>.</p>
</blockquote>
<h2 id="channel-open-confirm"><a class="header" href="#channel-open-confirm">Channel Open Confirm</a></h2>
<p>Use the <code>chan-open-confirm</code> command to confirm that the channel has been acknowledged,
and finish the handshake, after which the channel is open on both chains.</p>
<pre><code class="language-shell">DESCRIPTION:
Confirm opening of a channel (ChannelOpenConfirm)

USAGE:
    hermes tx chan-open-confirm --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --dst-channel &lt;DST_CHANNEL_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-channel &lt;DST_CHANNEL_ID&gt;
            Identifier of the destination channel (required) [aliases: dst-chan]

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel (required) [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>Confirm on <code>ibc-1</code> that <code>ibc-0</code> has accepted the opening of the channel,
after which the channel is open on both chains.</p>
<pre><code class="language-shell">hermes tx chan-open-confirm --dst-chain ibc-1 --src-chain ibc-0 --dst-connection connection-1 --dst-port transfer --src-port transfer --dst-channel channel-1 --src-channel channel-0

</code></pre>
<pre><code class="language-json">    OpenConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 3483
            },
            port_id: PortId(
                "transfer",
            ),
            channel_id: Some(
                ChannelId(
                    "channel-1",
                ),
            ),
            connection_id: ConnectionId(
                "connection-1",
            ),
            counterparty_port_id: PortId(
                "transfer",
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
        },
    ),
)
</code></pre>
<p>We have now successfully opened a channel over an existing connection between the two chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel-close-handshake"><a class="header" href="#channel-close-handshake">Channel Close Handshake</a></h1>
<p>The channel close handshake involves two steps: init and confirm.</p>
<h2 id="table-of-contents-17"><a class="header" href="#table-of-contents-17">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/tx/channel-close.html#channel-close-init">Channel Close Init</a></li>
<li><a href="documentation/commands/tx/channel-close.html#channel-close-confirm">Channel Close Confirm</a></li>
</ul>
<h2 id="channel-close-init"><a class="header" href="#channel-close-init">Channel Close Init</a></h2>
<p>Use the <code>chan-close-init</code> command to initialize the closure of a channel.</p>
<pre><code class="language-shell">DESCRIPTION:
Initiate the closing of a channel (ChannelCloseInit)

USAGE:
    hermes tx chan-close-init --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --dst-channel &lt;DST_CHANNEL_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-channel &lt;DST_CHANNEL_ID&gt;
            Identifier of the destination channel (required) [aliases: dst-chan]

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel (required) [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes tx chan-close-init --dst-chain ibc-0 --src-chain ibc-1 --dst-connection connection-0 --dst-port transfer --src-port transfer --dst-channel channel-0 --src-channel channel-1

</code></pre>
<pre><code class="language-json">Success: CloseInitChannel(
    CloseInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 77,
            },
            port_id: PortId(
                "transfer",
            ),
            channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
            connection_id: ConnectionId(
                "connection-0",
            ),
            counterparty_port_id: PortId(
                "transfer",
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    "channel-1",
                ),
            ),
        },
    ),
)
</code></pre>
<h2 id="channel-close-confirm"><a class="header" href="#channel-close-confirm">Channel Close Confirm</a></h2>
<p>Use the <code>chan-close-confirm</code> command to confirm the closure of a channel.</p>
<pre><code class="language-shell">DESCRIPTION:
Confirm the closing of a channel (ChannelCloseConfirm)

USAGE:
    hermes tx chan-close-confirm --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --dst-channel &lt;DST_CHANNEL_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

OPTIONS:
    -h, --help    Print help information

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-channel &lt;DST_CHANNEL_ID&gt;
            Identifier of the destination channel (required) [aliases: dst-chan]

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel (required) [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes tx chan-close-confirm --dst-chain ibc-1 --src-chain ibc-0 --dst-connection connection-1 --dst-port transfer --src-port transfer --dst-channel channel-1 --src-channel channel-0

</code></pre>
<pre><code class="language-json">Success: CloseConfirmChannel(
    CloseConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 551,
            },
            port_id: PortId(
                "transfer",
            ),
            channel_id: Some(
                ChannelId(
                    "channel-1",
                ),
            ),
            connection_id: ConnectionId(
                "connection-1",
            ),
            counterparty_port_id: PortId(
                "transfer",
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    "channel-0",
                ),
            ),
        },
    ),
)
</code></pre>
<p><strong>NOTE</strong>: The <code>cosmos-sdk</code> transfer module implementation does not allow the user (<code>hermes</code> in this case) to initiate the closing of channels.
Therefore, when using the Gaia release image, the <code>chan-close-init</code> command
fails as the <code>MsgChannelCloseInit</code> message included in the transaction is rejected.
To be able to test channel closure, you need to <a href="documentation/commands/tx/../../../advanced/troubleshooting/patch-gaia.html">patch</a> your gaia deployments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-tx-commands"><a class="header" href="#packet-tx-commands">Packet Tx Commands</a></h1>
<h2 id="table-of-contents-18"><a class="header" href="#table-of-contents-18">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/tx/packet.html#fungible-token-transfer">Fungible token transfer</a></li>
<li><a href="documentation/commands/tx/packet.html#relay-receive-and-timeout-packets">Relay receive and timeout packets</a></li>
<li><a href="documentation/commands/tx/packet.html#relay-acknowledgment-packets">Relay acknowledgment packets</a></li>
</ul>
<h2 id="fungible-token-transfer"><a class="header" href="#fungible-token-transfer">Fungible token transfer</a></h2>
<p>Use the <code>tx ft-transfer</code> command to send ICS-20 fungible token transfer packets.
<strong>NOTE:</strong> This command is mainly used for testing the packet features of Hermes.</p>
<pre><code class="language-shell">DESCRIPTION:
Send a fungible token transfer test transaction (ICS20 MsgTransfer)

USAGE:
    hermes tx ft-transfer [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt; --amount &lt;AMOUNT&gt;

OPTIONS:
        --denom &lt;DENOM&gt;
            Denomination of the coins to send [default: samoleans]

    -h, --help
            Print help information

        --key-name &lt;KEY_NAME&gt;
            Use the given signing key name (default: `key_name` config)

        --memo &lt;MEMO&gt;
            Optional memo included in the transfer

        --number-msgs &lt;NUMBER_MSGS&gt;
            Number of messages to send

        --receiver &lt;RECEIVER&gt;
            The account address on the destination chain which will receive the tokens. If omitted,
            the relayer's wallet on the destination chain will be used

        --timeout-height-offset &lt;TIMEOUT_HEIGHT_OFFSET&gt;
            Timeout in number of blocks since current [default: 0]

        --timeout-seconds &lt;TIMEOUT_SECONDS&gt;
            Timeout in seconds since current [default: 0]

REQUIRED:
        --amount &lt;AMOUNT&gt;
            Amount of coins (samoleans, by default) to send (e.g. `100000`)

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>Send two transfer packets from the <code>transfer</code> module and <code>channel-0</code> of <code>ibc-0</code> to <code>ibc-1</code>. Each transfer if for <code>9999</code> <code>samoleans</code> (default denomination) and a timeout offset of <code>10</code> blocks. The transfer fee is paid by the associated account on <code>ibc-1</code>.</p>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-height-offset 1000 --number-msgs 2 --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-0 --amount 9999

</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 431,
            },
            packet: PortId("transfer") ChannelId("channel-0") Sequence(4),
        },
    ),
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 431,
            },
            packet: PortId("transfer") ChannelId("channel-0") Sequence(5),
        },
    ),
]
</code></pre>
<p>The transfer packets are stored on <code>ibc-0</code> and can be relayed.</p>
<blockquote>
<p>To send transfer packets with a custom receiver address use the <code>--receiver</code> flag.</p>
</blockquote>
<pre><code class="language-shell">hermes tx ft-transfer --timeout-height-offset 1000 --number-msgs 1 --receiver board:1938586739 --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-0 --amount 9999

</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 546,
            },
            packet: PortId("transfer") ChannelId("channel-0") Sequence(7),
        },
    ),
]
</code></pre>
<h2 id="relay-receive-and-timeout-packets"><a class="header" href="#relay-receive-and-timeout-packets">Relay receive and timeout packets</a></h2>
<p>Use the <code>tx packet-recv</code> command to relay the packets sent but not yet received. If the packets sent have timed out then a timeout packet is sent to the source chain.</p>
<pre><code class="language-shell">DESCRIPTION:
Relay receive or timeout packets

USAGE:
    hermes tx packet-recv [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

OPTIONS:
    -h, --help
            Print help information

        --packet-data-query-height &lt;PACKET_DATA_QUERY_HEIGHT&gt;
            Exact height at which the packet data is queried via block_results RPC

        --packet-sequences &lt;PACKET_SEQUENCES&gt;
            Sequences of packets to be cleared on `dst-chain`. Either a single sequence or a range
            of sequences can be specified. If not provided, all pending recv or timeout packets will
            be cleared. Each element of the comma-separated list must be either a single sequence or
            a range of sequences. Example: `1,10..20` will clear packets with sequences 1, 10, 11,
            ..., 20

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;        Identifier of the destination chain
        --src-chain &lt;SRC_CHAIN_ID&gt;        Identifier of the source chain
        --src-channel &lt;SRC_CHANNEL_ID&gt;    Identifier of the source channel [aliases: src-chan]
        --src-port &lt;SRC_PORT_ID&gt;          Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>Send the two transfer packets to the <code>ibc-1</code> module bound to the <code>transfer</code> port and the <code>channel-0</code>'s counterparty.</p>
<p><strong>NOTE</strong>: Hermes prepends a <code>Client Update</code> message before the <code>Receive</code> messages.</p>
<pre><code class="language-shell">hermes tx packet-recv --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-0

</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 1,
                    height: 439,
                },
                client_id: ClientId(
                    "07-tendermint-1",
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 0,
                    height: 449,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 1,
                height: 439,
            },
            packet: PortId("transfer") ChannelId("channel-0") Sequence(4),
            ack: [
                123,
                34,
                114,
                101,
                115,
                117,
                108,
                116,
                34,
                58,
                34,
                65,
                81,
                61,
                61,
                34,
                125,
            ],
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 1,
                height: 439,
            },
            packet: PortId("transfer") ChannelId("channel-0") Sequence(5),
            ack: [
                123,
                34,
                114,
                101,
                115,
                117,
                108,
                116,
                34,
                58,
                34,
                65,
                81,
                61,
                61,
                34,
                125,
            ],
        },
    ),
]
</code></pre>
<p>Both packets have been relayed to <code>ibc-1</code> and acknowledged.</p>
<h2 id="relay-acknowledgment-packets"><a class="header" href="#relay-acknowledgment-packets">Relay acknowledgment packets</a></h2>
<p>Use the <code>tx packet-ack</code> command to relay acknowledgments to the original source of the packets.</p>
<pre><code class="language-shell">DESCRIPTION:
Relay acknowledgment packets

USAGE:
    hermes tx packet-ack [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

OPTIONS:
    -h, --help
            Print help information

        --packet-data-query-height &lt;PACKET_DATA_QUERY_HEIGHT&gt;
            Exact height at which the packet data is queried via block_results RPC

        --packet-sequences &lt;PACKET_SEQUENCES&gt;
            Sequences of packets to be cleared on `dst-chain`. Either a single sequence or a range
            of sequences can be specified. If not provided, all pending ack packets will be cleared.
            Each element of the comma-separated list must be either a single sequence or a range of
            sequences. Example: `1,10..20` will clear packets with sequences 1, 10, 11, ..., 20

REQUIRED:
        --dst-chain &lt;DST_CHAIN_ID&gt;        Identifier of the destination chain
        --src-chain &lt;SRC_CHAIN_ID&gt;        Identifier of the source chain
        --src-channel &lt;SRC_CHANNEL_ID&gt;    Identifier of the source channel [aliases: src-chan]
        --src-port &lt;SRC_PORT_ID&gt;          Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>Send the acknowledgments to the <code>ibc-0</code> module bound to the <code>transfer</code> port and the <code>channel-1</code>'s counterparty.</p>
<p><strong>NOTE</strong>: The relayer prepends a client update message before the acknowledgments.</p>
<pre><code class="language-shell">hermes tx packet-ack --dst-chain ibc-0 --src-chain ibc-1 --src-port transfer --src-channel channel-1

</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 495,
                },
                client_id: ClientId(
                    "07-tendermint-0",
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 483,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 495,
            },
            packet: PortId("transfer") ChannelId("channel-0") Sequence(4),
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 495,
            },
            packet: PortId("transfer") ChannelId("channel-0") Sequence(5),
        },
    ),
]
</code></pre>
<p>Both acknowledgments have been received on <code>ibc-0</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-tx-commands"><a class="header" href="#upgrade-tx-commands">Upgrade Tx Commands</a></h1>
<h2 id="table-of-contents-19"><a class="header" href="#table-of-contents-19">Table of Contents</a></h2>
<ul>
<li><a href="documentation/commands/tx/upgrade.html#upgrade-chain">Upgrade Chain</a></li>
</ul>
<h2 id="upgrade-chain"><a class="header" href="#upgrade-chain">Upgrade Chain</a></h2>
<p>Use this to make an upgrade proposal.</p>
<pre><code class="language-shell">DESCRIPTION:
Send an IBC upgrade plan

USAGE:
    hermes tx upgrade-chain [OPTIONS] --reference-chain &lt;REFERENCE_CHAIN_ID&gt; --host-chain &lt;HOST_CHAIN_ID&gt; --host-client &lt;HOST_CLIENT_ID&gt; --amount &lt;AMOUNT&gt; --height-offset &lt;HEIGHT_OFFSET&gt;

OPTIONS:
        --denom &lt;DENOM&gt;
            Denomination for the deposit (default: 'stake')

        --gov-account &lt;GOV_ACCOUNT&gt;
            Authority account used to sign upgrade proposal. Note: This is only used for chains with
            ibc-go version v8.0.0 or higher

    -h, --help
            Print help information

        --new-chain &lt;CHAIN_ID&gt;
            New chain identifier to assign to the upgrading chain (optional)

        --new-unbonding &lt;UNBONDING_PERIOD&gt;
            New unbonding period to assign to the upgrading chain, in seconds (optional)

        --upgrade-name &lt;UPGRADE_NAME&gt;
            A string to name the upgrade proposal plan (default: 'plan')

REQUIRED:
        --amount &lt;AMOUNT&gt;
            Amount of stake

        --height-offset &lt;HEIGHT_OFFSET&gt;
            Upgrade height offset in number of blocks since current

        --host-chain &lt;HOST_CHAIN_ID&gt;
            Identifier of the host chain

        --host-client &lt;HOST_CLIENT_ID&gt;
            Identifier of the client on the host chain from which the plan is created

        --reference-chain &lt;REFERENCE_CHAIN_ID&gt;
            Identifier of the chain to upgrade
</code></pre>
<p><strong>Example</strong></p>
<p>An upgrade proposal is made for <code>ibc-0</code>, for height <code>300</code> blocks from the latest height, with <code>10000000stake</code> deposited. The proposal will include the upgraded client state constructed from the state of <code>07-tendermint-0</code> client on <code>ibc-1</code>.</p>
<p>If the chain is using ibc-go version <code>v8.0.0</code> or higher, the authority account for the governance module needs to be used. To query the account use:</p>
<pre><code class="language-shell">&lt;CHAIN_BINARY&gt; query auth module-account gov
</code></pre>
<p>or</p>
<pre><code class="language-shell">&lt;CHAIN_BINARY&gt; query auth module-accounts
</code></pre>
<p>And then</p>
<pre><code class="language-shell">hermes tx upgrade-chain --gov-account &lt;QUERIED_ACCOUNT&gt; --reference-chain ibc-0 --host-chain ibc-1 --host-client 07-tendermint-0 --amount 10000000 --height-offset 60

</code></pre>
<p>If the ibc-go version used is lower than <code>v8.0.0</code> you can ignore the <code>--gov-account</code> flag as it will not be used.</p>
<pre><code class="language-shell">hermes tx upgrade-chain --reference-chain ibc-0 --host-chain ibc-1 --host-client 07-tendermint-0 --amount 10000000 --height-offset 60

</code></pre>
<pre><code>Success: transaction::Hash(779713508B6103E37FADE60483BEE964A90BD67E5F20037B2CC4AE0E90B707C3)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fee"><a class="header" href="#fee">Fee</a></h1>
<p>Hermes supports querying for different objects that exist on a configured chain.</p>
<p>The <code>query</code> command provides the following sub-commands:</p>
<div class="table-wrapper"><table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>register-counterparty-payee</code></td><td><a href="documentation/commands/fee/./register-counterparty-payee.html">Register a counterparty payee for a channel</a></td></tr>
<tr><td><code>register-payee</code></td><td><a href="documentation/commands/fee/./register-payee.html">Register a payee for a channel</a></td></tr>
<tr><td><code>transfer</code></td><td><a href="documentation/commands/fee/./transfer.html">Perform a token transfer supported with a fee</a></td></tr>
</tbody></table>
</div>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<pre><code>DESCRIPTION:
Interact with the fee middleware

USAGE:
    hermes fee &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    help                           Print this message or the help of the given subcommand(s)
    register-counterparty-payee    Register a counterparty payee for a channel
    register-payee                 Register a payee for a channel
    transfer                       Perform a token transfer supported with a fee
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="register-counterparty-payee"><a class="header" href="#register-counterparty-payee">Register Counterparty Payee</a></h1>
<p>Use this command in order to specify the address which will receive the <code>recv_fee</code> from incentivised packets relayed by the specified chain on the specified channel.</p>
<p><strong>NOTE:</strong> If the Hermes configuration parameter <code>auto_register_counterparty_payee = true</code> is set, make sure to use the <code>hermes fee register-counterparty-payee</code> command after calling <code>hermes start</code>, otherwise <code>auto_register_counterparty_payee</code> will overwrite the address registered using <code>hermes fee register-counterparty-payee</code>.</p>
<pre><code class="language-shell">DESCRIPTION:
Register a counterparty payee for a channel

USAGE:
    hermes fee register-counterparty-payee --chain &lt;CHAIN_ID&gt; --channel &lt;CHANNEL_ID&gt; --port &lt;PORT_ID&gt; --counterparty-payee &lt;COUNTERPARTY_PAYEE_ADDRESS&gt;

OPTIONS:
    -h, --help    Print help information

FLAGS:
        --chain &lt;CHAIN_ID&gt;
            Identifier of the chain

        --channel &lt;CHANNEL_ID&gt;
            Identifier of the channel [aliases: chan]

        --counterparty-payee &lt;COUNTERPARTY_PAYEE_ADDRESS&gt;
            Address of the counterparty payee.
            
            Note that there exists a configuration parameter `auto_register_counterparty_payee` that
            can be enabled in order to have Hermes automatically register the counterparty payee on
            the destination chain to the relayer's address on the source chain. This option can be
            used for simple configuration of the relayer to receive fees for relaying RecvPackets on
            fee-enabled channels.

        --port &lt;PORT_ID&gt;
            Identifier of the port
</code></pre>
<p><strong>Example</strong></p>
<p>Register the address <code>cosmos10h9stc5v6ntgeygf5xf945njqq5h32r53uquvw</code> for the chain <code>ibc-1</code> on channel <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes fee register-counterparty-payee --chain ibc-1 --channel channel-0 --port transfer --counterparty-payee cosmos10h9stc5v6ntgeygf5xf945njqq5h32r53uquvw

</code></pre>
<pre><code class="language-json">SUCCESS Successfully registered counterparty payee
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="register-payee"><a class="header" href="#register-payee">Register Payee</a></h1>
<p>Use this command in order to specify the address which will receive the <code>ack_fee</code> and <code>timeout_fee</code> from incentivised packets relayed by the specified chain on the specified channel. By default this is the address of the reverse relayer's wallet.</p>
<p><strong>WARNING:</strong> Use this command with caution as some chains do not allow relayer address and payee to be equal. So reverting the payee address to the relayer address might be difficult after using this command.</p>
<pre><code class="language-shell">DESCRIPTION:
Register a payee for a channel

USAGE:
    hermes fee register-payee --chain &lt;CHAIN_ID&gt; --channel &lt;CHANNEL_ID&gt; --port &lt;PORT_ID&gt; --payee &lt;PAYEE_ADDRESS&gt;

OPTIONS:
    -h, --help    Print help information

FLAGS:
        --chain &lt;CHAIN_ID&gt;         Identifier of the chain
        --channel &lt;CHANNEL_ID&gt;     Identifier of the channel [aliases: chan]
        --payee &lt;PAYEE_ADDRESS&gt;    Address of the payee
        --port &lt;PORT_ID&gt;           Identifier of the port
</code></pre>
<p><strong>Example</strong></p>
<p>Register the address <code>cosmos10h9stc5v6ntgeygf5xf945njqq5h32r53uquvw</code> for the chain <code>ibc-1</code> on channel <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes fee register-payee --chain ibc-1 --channel channel-0 --port transfer --payee cosmos10h9stc5v6ntgeygf5xf945njqq5h32r53uquvw

</code></pre>
<pre><code class="language-json">SUCCESS Successfully registered payee
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fungible-token-transfer-with-fees"><a class="header" href="#fungible-token-transfer-with-fees">Fungible token transfer with fees</a></h1>
<p>Use the <code>fee transfer</code> command to send an <code>IncentivizedPacket</code>.</p>
<pre><code class="language-shell">DESCRIPTION:
Perform a token transfer supported with a fee

USAGE:
    hermes fee transfer [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt; --amount &lt;AMOUNT&gt;

OPTIONS:
        --ack-fee &lt;ACK_FEE&gt;
            Fee to pay for the Ack message. Default: 0 [default: 0]

        --denom &lt;DENOM&gt;
            Denomination of the coins to send. Default: samoleans [default: samoleans]

    -h, --help
            Print help information

        --key-name &lt;KEY_NAME&gt;
            Use the given signing key name (default: `key_name` config)

        --memo &lt;MEMO&gt;
            Optional memo included in the transfer

        --number-msgs &lt;NUMBER_MSGS&gt;
            Number of messages to send

        --receive-fee &lt;RECEIVE_FEE&gt;
            Fee to pay for the Recv message. Default: 0 [default: 0]

        --recipient &lt;RECIPIENT&gt;
            The account address on the destination chain which will receive the tokens. If omitted,
            the relayer's wallet on the destination chain will be used

        --timeout-fee &lt;TIMEOUT_FEE&gt;
            Fee to pay for the Timeout message. Default: 0 [default: 0]

        --timeout-height-offset &lt;TIMEOUT_HEIGHT_OFFSET&gt;
            Timeout in number of blocks since current. Default: 0 [default: 0]

        --timeout-seconds &lt;TIMEOUT_SECONDS&gt;
            Timeout in seconds since current. Default: 0 [default: 0]

FLAGS:
        --amount &lt;AMOUNT&gt;
            Amount of coins (samoleans, by default) to send (e.g. `100000`)

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>Send a transfer packet from the <code>transfer</code> module and <code>channel-0</code> of <code>ibc-0</code> to <code>ibc-1</code>. Each transfer is for <code>9999</code> <code>samoleans</code> (default denomination), ICS29 fees of 50 <code>samoleans</code> for <code>recv_fee</code>, 25 <code>samoleans</code> for <code>ack_fee</code>, <code>10</code> <code>samoleans</code> for <code>timeout_fee</code> and a timeout offset of <code>10</code> blocks. The transfer fee is paid by the associated account on <code>ibc-1</code>.</p>
<pre><code class="language-shell">hermes fee transfer  --receive-fee 50 --ack-fee 25 --timeout-fee 10 --timeout-height-offset 1000 --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-0 --amount 9999

</code></pre>
<pre><code class="language-json">SUCCESS [
    IbcEventWithHeight {
        event: IncentivizedPacket(
            IncentivizedPacket {
                port_id: PortId(
                    "transfer",
                ),
                channel_id: ChannelId(
                    "channel-0",
                ),
                sequence: Sequence(
                    8,
                ),
                total_recv_fee: [
                    Coin {
                        denom: "stake",
                        amount: Amount(
                            50,
                        ),
                    },
                ],
                total_ack_fee: [
                    Coin {
                        denom: "stake",
                        amount: Amount(
                            25,
                        ),
                    },
                ],
                total_timeout_fee: [
                    Coin {
                        denom: "stake",
                        amount: Amount(
                            10,
                        ),
                    },
                ],
            },
        ),
        height: Height {
            revision: 1,
            height: 1574,
        },
    },
    IbcEventWithHeight {
        event: SendPacket(
            SendPacket {
                packet: Packet {
                    sequence: Sequence(
                        8,
                    ),
                    source_port: PortId(
                        "transfer",
                    ),
                    source_channel: ChannelId(
                        "channel-0",
                    ),
                    destination_port: PortId(
                        "transfer",
                    ),
                    destination_channel: ChannelId(
                        "channel-0",
                    ),
                    data: [123, 34, 97, 109, 111, 117, 110, 116, 34, 58, 34, 49, 48, 48, 48, 34, 44, 34, 100, 101, 110, 111, 109, 34, 58, 34, 115, 116, 97, 107, 101, 34, 44, 34, 114, 101, 99, 101, 105, 118, 101, 114, 34, 58, 34, 99, 111, 115, 109, 111, 115, 49, 52, 122, 115, 50, 120, 51, 56, 108, 109, 107, 119, 52, 101, 113, 118, 108, 51, 108, 112, 109, 108, 53, 108, 56, 99, 114, 122, 97, 120, 110, 54, 109, 55, 119, 117, 122, 110, 120, 34, 44, 34, 115, 101, 110, 100, 101, 114, 34, 58, 34, 99, 111, 115, 109, 111, 115, 49, 109, 57, 108, 51, 53, 56, 120, 117, 110, 104, 104, 119, 100, 115, 48, 53, 54, 56, 122, 97, 52, 57, 109, 122, 104, 118, 117, 120, 120, 57, 117, 120, 114, 101, 53, 116, 117, 100, 34, 125],
                    timeout_height: Never,
                    timeout_timestamp: Timestamp {
                        time: Some(
                            Time(
                                2023-03-22 11:49:54.491498,
                            ),
                        ),
                    },
                },
            },
        ),
        height: Height {
            revision: 1,
            height: 1574,
        },
    },
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="set-log-level"><a class="header" href="#set-log-level">Set Log Level</a></h2>
<p>This command allows you to easily update the lowest log level displayed by Hermes.</p>
<pre><code class="language-shell">{{#include ../../../templates/help_templates/logs/log-level.md}}
</code></pre>
<h2 id="set-raw-filter"><a class="header" href="#set-raw-filter">Set Raw Filter</a></h2>
<p>This command allows you to update the tracing directive used to filter the logs. Please use this command with caution as it requires a precise syntax.</p>
<pre><code class="language-shell">{{#include ../../../templates/help_templates/logs/raw.md}}
</code></pre>
<h2 id="reset"><a class="header" href="#reset">Reset</a></h2>
<p>This command will restore the lowest log level displayed using the <code>log_level</code> defined in the <code>config.toml</code>.</p>
<pre><code class="language-shell">DESCRIPTION:
Subcommand to restore the log level by using the configuration defined in the config.toml file

USAGE:
    hermes logs reset

OPTIONS:
    -h, --help    Print help information
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>These are some definitions used in this guide:</p>
<div class="table-wrapper"><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody>
<tr><td>IBC transaction</td><td>A transaction that includes IBC messages (including packets). This is constructed by the relayer and sent over the physical network to a chain according to the chain rules. For example, for tendermint chains a <code>broadcast_tx_commit</code> request is sent to a tendermint RPC server.</td></tr>
<tr><td>IBC message</td><td>An element of the transaction payload sent by the relayer; it includes client, connection, channel and IBC packet data. Multiple IBC messages may be included in an IBC transaction.</td></tr>
<tr><td>IBC packet</td><td>A particular type of IBC message that includes the application packet and its commitment proof.</td></tr>
<tr><td>IBC Client</td><td>Client code running on chain, typically only the light client verification related functionality.</td></tr>
<tr><td>Relayer Light Client</td><td>Full light client functionality, including connecting to at least one provider (full node), storing and verifying headers, etc.</td></tr>
<tr><td>Source chain</td><td>The chain from which the relayer reads data to fill an IBC message.</td></tr>
<tr><td>Destination chain</td><td>The chain where the relayer submits transactions that include the IBC message.</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
